<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>주니어 프로그래머 딱지 떼는 7가지 팁! - Study: Do it C 언어 입문</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html" class="active"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="주니어-프로그래머-딱지-떼는-일곱-가지-팁"><a class="header" href="#주니어-프로그래머-딱지-떼는-일곱-가지-팁">주니어 프로그래머 딱지 떼는 일곱 가지 팁!</a></h1>
<h2 id="tip-1-공용체를-적재적소에-활용하면-메모리를-절약할-수-있다"><a class="header" href="#tip-1-공용체를-적재적소에-활용하면-메모리를-절약할-수-있다">Tip 1. 공용체를 적재적소에 활용하면 메모리를 절약할 수 있다</a></h2>
<h3 id="구조체-문법과-비슷한-공용체"><a class="header" href="#구조체-문법과-비슷한-공용체">구조체 문법과 비슷한 공용체</a></h3>
<ul>
<li>사용자 정의 자료형을 만드는 구조체와 문법 구조가 비슷한 공용체(union) 문법이 있다.</li>
<li>구조체에서 <code>struct</code>키워드를 적는 위치에 공용체는 <code>union</code>이라고 적는다.</li>
<li>그 외 공용체의 문법은 구조체의 문법과 거의 비슷하다.</li>
<li>다음은 공용체 문법과 <code>typedef</code>를 사용해서 <code>Convert Data</code>라는 새로운 자료형을 만드는 예제이다.</li>
</ul>
<pre><code class="language-c">typedef union ConvertData {
    char c_data;       // 1바이트
    short int s_data;  // 2바이트
    int i_data;        // 3바이트
} CD;
</code></pre>
<ul>
<li>공용체도 구조체와 마찬가지로 새로운 자료형을 만들거나 그 자료형으로 변수를 선언하려면 항상 <code>union</code>키워드를 적어주어야 한다.</li>
<li>위 예제에서는 <code>typedef</code>문법을 함께 사용해서 <code>CD</code>라는 자료형을 추가로 만들었다.</li>
<li>따라서 다음과 같이 <code>CD</code>를 사용하면 <code>union</code>키워드를 사용하지 않고도 간단하게 변수를 선언할 수 있다.</li>
</ul>
<pre><code class="language-c">CD temp;  // union ConvertData temp; 와 같음
</code></pre>
<h3 id="공용체의-요소들은-할당된-메모리를-공유한다"><a class="header" href="#공용체의-요소들은-할당된-메모리를-공유한다">공용체의 요소들은 할당된 메모리를 공유한다</a></h3>
<ul>
<li>이렇게 구조체 문법과 비슷한 공용체 문법이 있는 이유는 무엇일까?</li>
<li>구조체로 만든 자료형의 크기는 구조체를 구성하는 요소들의 크기를 모두 더한 것과 같다.</li>
<li>하지만 공용체로 만든 자료형의 크기는 공용체를 구성하는 요소들 중에서 가장 큰 크기와 같다.</li>
<li>따라서 이전에 선언한 <code>ConvertData</code> 공용체는 <code>i_data</code>요소가 4바이트로 가장 크기 때문에 <code>CD</code>로 선언한 <code>temp</code>변수의 크기는 4바이트가 된다.</li>
<li>공용체 내부에 선언한 나머지 요소 <code>c_data</code>와 <code>s_data</code>는 메모리를 할당 받지 않았으니 사용할 수 없는 것인가? Nope.</li>
<li>공용체라는 이름이 말해 주듯이 공용체를 구성하는 각 요소들은 서로 같은 메모리를 공유하는 형태로 되어 있다.</li>
<li>즉 <code>ConvertData</code> 공용체의 <code>i_data</code>요소는 4바이트 전체를 사용하고, <code>s_data</code>요소는 4바이트에서 첫 2바이트를 사용하며, <code>c_data</code>요소는 처음 1바이트만을 사용하는 개념이다.</li>
<li>그래서 다음과 같이 제일 큰 <code>i_data</code>요소에 값을 대입하면 <code>s_data</code>와 <code>c_data</code>에도 영향을 미친다.</li>
</ul>
<pre><code class="language-c">temp.i_data = 0x12345678;
</code></pre>
<p><img src="./images/union_1.png" alt="공용체의 요소들 - 1" /></p>
<ul>
<li>공용체는 각 요소들이 같은 메모리를 공유하기 때문에 위의 그림에서처럼 <code>temp.i_data</code>에 값을 대입했을 때 <code>temp.s_data</code>에는 <code>0x5678</code>, <code>temp.c_data</code>에는 <code>0x78</code>을 대입한 것과 같은 효과가 있다.</li>
<li>그래서 이런 공용체의 기능을 잘 이용하면 4바이트 크기를 갖는 정수 값에서 2바이트나 1바이트의 값을 추출할 수 있다.</li>
<li>예를 들어 4바이트 크기의 값을 입력 받아 앞에서 2바이트 크기만 사용하고 싶다면 다음과 같이 <code>temp.i_data</code>로 값을 입력 받고 <code>temp.s_data</code>로 사용하면 되는 것이다.</li>
</ul>
<pre><code class="language-c">CD temp;
short int s;
temp.i_data = 0x12345678;  // 4바이트 공간에 정수 값을 대입함
s = temp.s_data;           // 변수 s에 0x5678이 저장됨
</code></pre>
<p><img src="./images/union_2.png" alt="공용체의 요소들 - 2" /></p>
<h3 id="공용체는-메모리-절약의-끝판왕"><a class="header" href="#공용체는-메모리-절약의-끝판왕">공용체는 메모리 절약의 끝판왕</a></h3>
<ul>
<li>공용체는 메모리를 절약하는 용도로 더 많이 사용한다.</li>
<li>아래에 <code>MyData</code>라는 구조체를 선언했다.</li>
<li>구조체의 요소 중 <code>type</code>요소의 값이 <code>0</code>이면 <code>i_data</code> 변수에 정수 값을 저장하고, <code>type</code>요소의 값이 <code>1</code>이면 <code>f_data</code>에 실수 값을 저장한다고 가정해보자.</li>
<li>그리고 <code>i_data</code>와 <code>f_data</code>가 동시에 사용되는 경우는 없다고 가정하자.</li>
</ul>
<pre><code class="language-c">struct MyData {
    char type;
    int i_data;    // type 요소 값이 0이면 사용함
    float f_data;  // type 요소 값이 1이면 사용함
};
</code></pre>
<ul>
<li><code>MyData</code>구조체로 변수를 선언하면 <code>type</code>요소의 값이 무엇인지에 따라 <code>i_data</code>또는 <code>f_data</code>중에 하나만 사용되기 때문에 항상 4바이트를 낭비하게 된다.</li>
<li>왜냐하면 <code>type</code>요소의 값이 <code>0</code>이면 <code>f_data</code>가 선언된 메모리는 사용되지 않을 것이고, <code>type</code>요소의 값이 <code>1</code>이면 <code>i_data</code>가 선언된 메모리가 사용되지 않기 때문이다.</li>
</ul>
<p><img src="./images/union_3.png" alt="공용체 요소들 - 3" /></p>
<ul>
<li>위 상황처럼 구조체의 각 요소가 함께 사용되지 않고 서로 반대되는 경우에만 사용될 때, 두 요소가 메모리를 공유한다면 공간을 낭비하지 않을 것이다.</li>
<li>따라서 다음과 같이 공용체 문법을 사용해서 새로운 자료형을 만들고, 그 자료형으로 <code>MyData</code>구조체에 요소를 추가하면 위에서 발생한 메모리 낭비 문제를 해결할 수 있다.</li>
</ul>
<pre><code class="language-c">// i_data와 f_data가 4바이트 메모리를 공유하는 공용체 자료형을 정의함
union SharedType {
    int i_data;    // 정수 값을 저장할 변수
    float f_data;  // 실수 값을 저장할 변수
};

struct MyData {
    char type;
    union SharedType data;
};

void main() {
    struct MyData a, b;
    a.type = 0;  // a 구조체의 type 요소에 0을 저장함
    a.data.i_data = 100;
    b.type = 1;  // b 구조체의 type 요소에 1을 저장함
    b.data.f_data = 3.14f;
}
</code></pre>
<ul>
<li><code>type</code>요소의 값이 <code>0</code>일 때는 <code>data.i_data</code>요소를 사용해서 정수를 저장하고, <code>type</code>요소의 값이 <code>1</code>일 때는 <code>data.f_data</code>요소를 사용해서 실수를 저장하면 된다.</li>
<li>이렇게 하면 앞에서 구조체를 사용했던 것과 같은 기능을 할 것이다.</li>
<li>그리고 <code>SharedType</code>자료형이 공용체이기 때문에 결과적으로 동시에 사용하지 않는다는 조건만 만족한다면 몇 개의 변수를 사용하든지 상관없이 공용체로 해당 변수들을 묶어서 메모리를 절약할 수 있다.</li>
</ul>
<p><img src="./images/union_4.png" alt="공용체 요소들 - 4" /></p>
<h2 id="tip-2-비트-단위-연산이-복잡하다면-구조체와-공용체를-쓰자"><a class="header" href="#tip-2-비트-단위-연산이-복잡하다면-구조체와-공용체를-쓰자">Tip 2. 비트 단위 연산이 복잡하다면? 구조체와 공용체를 쓰자</a></h2>
<h3 id="구조체-문법으로-비트-단위-분리하기"><a class="header" href="#구조체-문법으로-비트-단위-분리하기">구조체 문법으로 비트 단위 분리하기</a></h3>
<ul>
<li>변수에 입력된 정보를 비트 단위로 값을 확인하거나 변경하고 싶은 경우에는 비트 연산자를 사용하면 된다.</li>
<li>C 언어는 구조체 문법에서 비트 단위로 데이터를 사용하는 기능을 추가로 제공하고 있다.</li>
<li>아래와 같이 구조체를 선언하면 새로운 자료형 <code>BitType</code>이 1바이트 크기로 만들어진다.</li>
</ul>
<pre><code class="language-c">// 비트 단위 정보를 다룰 수 있도록 구조체를 선언함
struct BitType {
    unsigned char bit_0 : 1;
    unsigned char bit_1 : 1;
    unsigned char bit_2 : 1;
    unsigned char bit_3 : 1;
    unsigned char bit_4 : 1;
    unsigned char bit_5 : 1;
    unsigned char bit_6 : 1;
    unsigned char bit_7 : 1;
};
</code></pre>
<ul>
<li>각 요소(<code>bit_0</code>~<code>bit_7</code>)의 오른쪽에 <code>: 1</code>이라고 적은 것은 비트 크기를 의미한다.</li>
<li>예를 들어 <code>unsigned char bit_0 : 1;</code>이라고 적으면 <code>bit_0</code>은 1비트 값을 사용한다는 뜻이다.</li>
<li>따라서 <code>BitType</code>구조체는 <code>bit_0</code>부터 <code>bit_7</code>까지 1비트 값을 총 8개 정의했기 때문에 크기가 1바이트(8비트)가 된다.</li>
<li>다음과 같이 <code>BitType</code>으로 <code>data</code>변수를 선언하면 <code>data</code>변수는 1바이트 크기로 메모리가 할당된다.</li>
<li>그리고 구조체의 요소에 비트 값을 대입하면 <code>data</code>변수에는 값 <code>0x05</code>가 저장된다.</li>
<li>따라서 비트 연산자를 사용하는 것보다는 좀 더 편하게 비트 값을 사용할 수 있다.</li>
</ul>
<pre><code class="language-c">struct BitType data;

data.bit_0 = 1;
data.bit_1 = 0;
data.bit_2 = 1;
data.bit_3 = 0;
data.bit_4 = 0;
data.bit_5 = 0;
data.bit_6 = 0;
data.bit_7 = 0;
</code></pre>
<p><img src="./images/stuct_bit_type_1.png" alt="구조체 비트타입 1" /></p>
<h4 id="구조체-비트-분리-기능을-사용한-변수는-다른-일반-변수와-값을-주고받기-어렵다"><a class="header" href="#구조체-비트-분리-기능을-사용한-변수는-다른-일반-변수와-값을-주고받기-어렵다">구조체 비트 분리 기능을 사용한 변수는 다른 일반 변수와 값을 주고받기 어렵다</a></h4>
<ul>
<li><code>data</code>변수에 입력된 값을 다음처럼 <code>unsigned char</code>형으로 선언한 <code>temp</code>변수에 대입하려고 하면 오류가 발생한다.</li>
</ul>
<pre><code class="language-c">unsigned char temp;
temp = data;  // 오류 발생: data는 BitType 구조체로 만든 변수임
</code></pre>
<ul>
<li><code>temp</code>도 1바이트이고 <code>data</code>변수도 1바이트이기 때문에 <code>data</code>값을 <code>temp</code>에 대입하면 문제가 없을 것이라 생각할 수도 있지만 구조체 변수는 <code>data.bit_0</code>과 같이 <code>.</code>(요소 지정) 연산자와 요소(<code>bit_0</code>)를 함께 사용해야만 대입 연산을 할 수 있다.</li>
<li>예외적으로 같은 구조체로 선언한 변수 간에는 변수 이름만으로도 복사가 된다.</li>
<li>위의 예제는 형 변환을 사용해도 오류를 해결할 수 없다.</li>
<li>왜냐하면 이 문제는 단순히 데이터 크기의 차이가 원인이 아니라 구조체의 비트 분리 문법을 사용해서 데이터 형식이 달라져버려서 발생한 것이기 때문이다.</li>
<li>예를 들어 <code>int</code>형과 <code>float</code>형의 경우에 데이터 크기는 같지만 데이터를 구성하는 형식이 다르기 때문에 <code>float</code>값을 <code>int</code>에 대입하면 값이 제대로 대입되지 않는 것과 비슷한 상황인 것이다.</li>
</ul>
<pre><code class="language-c">unsigned char temp;
temp = (unsigned char) data;  // 오류 발생: 데이터 형식이 달라서 형 변환에 실패함
</code></pre>
<ul>
<li>따라서 다음과 같이 메모리를 강제로 복사하는 <code>memcpy</code>함수를 사용해 문제를 해결할 수 있다.</li>
</ul>
<pre><code class="language-c">unsigned char temp;

// data 변수의 시작 주소에서 temp 변수의 시작 주소로 1바이트 크기만큼 메모리를 복사함
memcpy(&amp;temp, &amp;data, 1);
</code></pre>
<h3 id="공용체를-사용해서-좀-더-편하게-비트-단위-분리하기"><a class="header" href="#공용체를-사용해서-좀-더-편하게-비트-단위-분리하기">공용체를 사용해서 좀 더 편하게 비트 단위 분리하기</a></h3>
<ul>
<li>다음과 같이 공용체를 선언하면 <code>BitData</code>자료형의 크기는 1바이트가 되고 <code>bit_data</code>요소와 <code>byte_data</code>요소는 1바이트 크기의 메모리를 공유하게 된다.</li>
</ul>
<pre><code class="language-c">union BitData {  // 1바이트 크기의 자료형
    struct BitType bit_data;  // 1바이트
    unsigned char byte_data;  // 1바이트
};
</code></pre>
<ul>
<li>따라서 다음과 같이 <code>BitData</code>자료형으로 <code>temp</code>변수를 선언하고 <code>temp</code>변수의 <code>byte_data</code>요소에 값 <code>0x63</code>을 대입하면, 메모리를 공유하는 <code>temp</code>변수의 <code>bit_data</code>요소에도 비트 단위로 값을 대입한 것과 같다.</li>
</ul>
<pre><code class="language-c">union BitData = temp;
temp.byte_data = 0x63;
</code></pre>
<p><img src="./images/union_bit.png" alt="공용체로 비트 단위 분리하기" /></p>
<pre><code class="language-c">/* 구조체의 비트 분리 기능을 사용하여 변수의 비트 값 출력하기 */

#include &lt;stdio.h&gt;

struct BitType {  // 구조체를 비트 단위의 정보를 다룰 수 있도록 선언함
    unsigned char bit_0: 1;
    unsigned char bit_1: 1;
    unsigned char bit_2: 1;
    unsigned char bit_3: 1;
    unsigned char bit_4: 1;
    unsigned char bit_5: 1;
    unsigned char bit_6: 1;
    unsigned char bit_7: 1;  // 최상위 비트
};

union BitData {  // 1바이트 크기의 자료형
    struct BitType bit_data;
    unsigned char byte_data;
};

void main() {
    union BitData temp;
    temp.byte_data = 0x63;

    printf(&quot;byte_data : %x\n&quot;, temp.byte_data);
    printf(&quot;bit_data : %d%d%d%d %d%d%d%d\n&quot;, temp.bit_data.bit_7, temp.bit_data.bit_6, temp.bit_data.bit_5,
           temp.bit_data.bit_4, temp.bit_data.bit_3, temp.bit_data.bit_2, temp.bit_data.bit_1, temp.bit_data.bit_0);
}
</code></pre>
<pre><code class="language-text">byte_data : 63
bit_data : 0110 0011
</code></pre>
<ul>
<li>위 예제를 반대로 구성하여 <code>bit_data</code>에 비트 값을 넣고 <code>byte_data</code>로 확인하는 것도 가능하다.</li>
<li>연산 능력은 비트 연산자가 더 좋다.</li>
<li>개인적으로 비트 연산자를 사용하는 것을 더 추천한다.</li>
</ul>
<h2 id="tip-3-define과-typedef를-헷갈리지-말자"><a class="header" href="#tip-3-define과-typedef를-헷갈리지-말자">Tip 3. #define과 typedef를 헷갈리지 말자</a></h2>
<ul>
<li>전처리기인 <code>#define</code>문법과 사용자 정의 자료형을 만드는 <code>typedef</code>문법은 다음처럼 A를 B로 치환하는 형식을 가지고 있다.</li>
</ul>
<pre><code class="language-c">typedef unsigned short int * PSI;  // PSI라는 새로운 자료형을 정의함
</code></pre>
<pre><code class="language-c">#define PSI unsigned short int *  // 전처리기라서 끝에 ;이 필요 없음
</code></pre>
<ul>
<li><code>typedef</code>를 사용하면 <code>unsigned short int *</code>자료형을 <code>PSI</code>자료형으로 새롭게 정의할 수 있다.</li>
<li>그리고 <code>#define</code>문법을 사용하고 소스 코드에 <code>PSI</code>라고 쓰면 컴파일할 때 <code>PSI</code>가 <code>unsigned short int *</code>로 치환된다.</li>
<li>따라서 다음과 같이 사용하면 두 문법은 아주 비슷해 보인다.</li>
</ul>
<pre><code class="language-c">typedef unsigned short int *PSI;
PSI p_temp;  // unsigned short int *p_temp; 와 같음
</code></pre>
<pre><code class="language-c">#define PSI unsigned short int *

PSI p_test;  // unsigned short int *p_test; 와 같음
</code></pre>
<h3 id="define을-사용해-자료형을-치환하면-문제가-생긴다"><a class="header" href="#define을-사용해-자료형을-치환하면-문제가-생긴다">#define을 사용해 자료형을 치환하면 문제가 생긴다</a></h3>
<ul>
<li>단순하게 사용했을 때는 두 문법이 비슷하게 보이지만 내용을 조금 더 추가해 보면 두 문법이 다르다는 것을 알 수 있다.</li>
</ul>
<pre><code class="language-c">typedef unsigned short int *PSI;
PSI p_temp, p1;  // unsigned short int *p_temp, unsigned short int *p1; 을 의미함
</code></pre>
<pre><code class="language-c">#define PSI unsigned short int *

PSI p_test, p2;  // unsigned short int *p_test, unsigned short int p2; 를 의미함
</code></pre>
<ul>
<li><code>typedef</code> 문법을 사용하면 자료형을 새로 만든 것이기 때문에 <code>PSI</code>가 <code>unsigned short int *</code>를 의미한다.</li>
<li>따라서 <code>PSI p_temp, p1;</code>이라고 사용하면 <code>unsigned short int *p_temp, *p1;</code>을 의미한다.</li>
<li>즉 <code>p_temp, p1</code>변수 모두 <code>unsigned short int *</code>형식의 포인터로 선언된다.</li>
<li>하지만 <code>#define</code>을 사용하면 <code>p_test</code>만 <code>unsigned short int *</code>로 바뀐다.</li>
<li>따라서 <code>PSI p_test, p2;</code>라고 사용하면 <code>unsigned short int *p_test, p2;</code>를 의미한다.</li>
<li>즉 <code>p_test</code>는 <code>unsigned short int *</code>형식의 포인터로 선언되지만 <code>p2</code>는 <code>unsigned short int</code>형 일반 변수로 선언된다.</li>
<li>자료형을 치환하기 위해 <code>#define</code>을 사용하는 것은 편법일 뿐이다.</li>
<li>따라서 자료형을 치환할 때는 원칙을 지켜서 <code>typedef</code>문법을 사용하자.</li>
</ul>
<h3 id="typedef-문법으로-상수-치환은-불가능하다"><a class="header" href="#typedef-문법으로-상수-치환은-불가능하다">typedef 문법으로 상수 치환은 불가능하다</a></h3>
<ul>
<li>반대의 경우도 마찬가지이다.</li>
<li>두 문법이 비슷하다고 <code>typedef</code>문법을 자료형 치환이 아닌 단순 치환 형태로 사용하면 안된다.</li>
</ul>
<pre><code class="language-c">typedef 100 MAX_COUNT;  // 오류 발생: 상수는 자료형이 아님
</code></pre>
<ul>
<li><code>typedef</code>문법은 <code>typedef</code>키워드를 제거했을 때 변수를 선언하는 형식을 유지해야 한다.</li>
</ul>
<h2 id="tip-4-열거형-상수를-좀-더-효과적으로-치환하는-방법"><a class="header" href="#tip-4-열거형-상수를-좀-더-효과적으로-치환하는-방법">Tip 4. 열거형: 상수를 좀 더 효과적으로 치환하는 방법</a></h2>
<pre><code class="language-c">#define BLACK    0
#define WHITE    1
#define RED      2
#define GREEN    3
#define BLUE     4
#define YELLOW   5
</code></pre>
<ul>
<li>이렇게 나열해서 적으면 불편할 것이다.</li>
<li>상수를 연속적으로 치환하는 경우에는 열거형(enum) 상수를 사용해서 선언하자.</li>
</ul>
<pre><code class="language-c">enum MY_COLOR { BLACK, WHITE, RED, GREEN, BLUE, YELLOW };
</code></pre>
<ul>
<li>이렇게 열거형 상수를 사용하면서 상수 값을 따로 적지 않으면 처음 위치에 있는 <code>BLACK</code>값이 0으로 치환되고 그 뒤에 있는 치환문(<code>WHITE</code>, <code>RED</code>, ⋯)들은 차례대로 1씩 증가한다.</li>
<li>이렇게 선언한 열거형 상수는 <code>#define</code>을 선언한 것과 같은 형태로 사용할 수 있다.</li>
</ul>
<pre><code class="language-c">int my_data = GREEN;  // my_data 에 0을 대입함
</code></pre>
<h2 id="tip-5-조건부-컴파일-자기가-만든-코드를-테스트하는-것이-프로그래머의-기본이다"><a class="header" href="#tip-5-조건부-컴파일-자기가-만든-코드를-테스트하는-것이-프로그래머의-기본이다">Tip 5. 조건부 컴파일: 자기가 만든 코드를 테스트하는 것이 프로그래머의 기본이다</a></h2>
<ul>
<li>프로그램을 만들다 보면 소스 파일의 여러 곳에 자신의 코드를 체크하기 위한 테스트 코드를 추가하게 된다.</li>
</ul>
<pre><code class="language-c">int ProcessData(int data) {
    int result;
    if(data &lt; 256) {            // 예외 확인을 위한 테스트 코드
        result = data * 100;
    } else {                    // 예외 확인을 위한 테스트 코드
        printf(&quot;Error!!\n&quot;);
    }
    return result;
}
</code></pre>
<ul>
<li>테스트 코드를 한 곳에만 사용한 것이 아니고 소스 코드 전체에 여기저기 사용했다면 코드 정리가 어려울 것이다.</li>
</ul>
<h3 id="전처리기를-사용해서-조건에-따라-필요한-문장만-골라-컴파일하기"><a class="header" href="#전처리기를-사용해서-조건에-따라-필요한-문장만-골라-컴파일하기">전처리기를 사용해서 조건에 따라 필요한 문장만 골라 컴파일하기</a></h3>
<ul>
<li>C 언어는 주어진 조건에 따라 컴파일할 수 있도록 다양한 전처리기를 제공한다.</li>
</ul>
<h4 id="ifdef-전처리기와-endif-전처리기"><a class="header" href="#ifdef-전처리기와-endif-전처리기">#ifdef 전처리기와 #endif 전처리기</a></h4>
<ul>
<li><code>ifdef</code>는 if define의 줄임 표현이고 <code>endif</code>는 end of ifdef의 줄임 표현이다.</li>
<li>아래이 두 코드는 컴파일된 결과가 같다.</li>
</ul>
<pre><code class="language-c">int ProcessData(int data) {
    int result;
    if(data &lt; 256) {            // 예외 확인을 위한 테스트 코드
        result = data * 100;
    } else {                    // 예외 확인을 위한 테스트 코드
        printf(&quot;Error!!\n&quot;);
    }
    return result;
}
</code></pre>
<pre><code class="language-c">#define MY_DEBUG

int ProcessData(int data) {
    int result;
#ifdef MY_DEBUG                  // 이 구간은 MY_DEBUG가
    if(data &lt; 256)               // #define문으로 선언되어 있어야
#endif                           // 컴파일된다.
        result = data * 100;
#ifdef MY_DEBUG                  // 이 구간은 MY_DEBUG가
    else                         // #define문으로 선언되어 있어야
        printf(&quot;Error!!\n&quot;);     // 컴파일된다.
#endif                           //
    return result;
}
</code></pre>
<ul>
<li>결론적으로 소스 코드에서 <code>#define MY_DEBUG</code> 치환문만 제거하면 소스에 있는 모든 <code>#ifdef MY_DEBUG</code> ~ <code>#endif</code>가 주석으로 처리되는 효과가 생겨서 테스트 코드를 관리하기 편해진다.</li>
<li>이렇게 테스트 코드를 관리하는 방법을 '조건부 컴파일'이라고 부른다.</li>
</ul>
<h4 id="ifdef와-반대인-ifndef-전처리기"><a class="header" href="#ifdef와-반대인-ifndef-전처리기">#ifdef와 반대인 #ifndef 전처리기</a></h4>
<ul>
<li><code>#ifdef</code>와 반대되는 의미로 <code>#ifndef</code>가 제공되는데 이 전처리기는 if not define을 의미한다.</li>
<li>다음 예시에서 <code>MY_DEBUG</code>가 <code>#define</code>되지 않았기 때문에 <code>#ifndef MY_DEBUG</code>에서 <code>#endif</code>까지 컴파일에 포함된다.</li>
</ul>
<pre><code class="language-c">#ifndef MY_DEBUG  // if not define의 뜻
        
// 사용하고 싶은 코드(생략)

#endif
</code></pre>
<h3 id="헤더-파일-중복-참조를-막는-방법"><a class="header" href="#헤더-파일-중복-참조를-막는-방법">헤더 파일 중복 참조를 막는 방법</a></h3>
<ul>
<li>위에서 이야기한 조건부 컴파일 전처리기들은 실무에서 헤더 파일을 선언할 때 더 많이 사용한다.</li>
<li><code>#include</code>를 중복 사용해서 발생하는 오류는 <code>#ifndef</code>~<code>#endif</code>문을 사용하여 해결할 수 있다.</li>
</ul>
<blockquote>
<p><code>test.h</code></p>
<pre><code class="language-c">#ifndef _TEST_H_  // _TEST_H_ 가 정의되어 있지 않다면 이후 코드를 컴파일함
#define _TEST_H_  // _TEST_H_ 를 정의함

struct MyData {
    int a;
    int b;
};

#endif
</code></pre>
</blockquote>
<ul>
<li>위와 같이 헤더 파일을 구성하면 <code>test.h</code>헤더 파일이 처음 <code>#include</code>될 때는 <code>_TEST_H_</code>가 정의되어 있지 않아서 <code>#ifndef</code>를 처리한다.</li>
<li>그리고 <code>#define _TEST_H_</code>코드를 수행해서 <code>_TEST_H_</code>가 정의된다.</li>
<li>따라서 <code>test.h</code>헤더 파일이 다시 <code>#include</code>되더라도 <code>_TEST_H_</code>가 이미 정이되어 있기 때문에 <code>#ifndef</code>에서 <code>#endif</code>까지 컴파일에서 제외된다.</li>
</ul>
<h2 id="tip-6-포인터와-증감-연산자를-잘-써야-명령문이-간단해진다"><a class="header" href="#tip-6-포인터와-증감-연산자를-잘-써야-명령문이-간단해진다">Tip 6. 포인터와 증감 연산자를 잘 써야 명령문이 간단해진다</a></h2>
<ul>
<li>포인터를 사용하다 보면 비슷하게 생긴 명령문이 완전히 다르게 동작해서 오류가 발생하는 경우가 많다.</li>
<li>그 중에서도 포인터와 증감 연산자를 함께 사용하면 연산자 우선순위와 증감 연산자의 전위·후위 연산 특성 때문에 실수를 많이 할 수밖에 없습니다.</li>
<li>하지만 포인터와 증감 연산자를 잘 활용하면 명령문을 간단한 형태로 만들 수 있기 때문에 실무에 있는 프로그래머들이 즐겨 사용한다.</li>
<li>아래의 표현들을 정확하게 알아두자!</li>
</ul>
<h3 id="p와-p의-의미"><a class="header" href="#p와-p의-의미">*p++와 *++p의 의미</a></h3>
<ul>
<li><code>*p++</code>는 자신이 가리키는 주소에 저장된 값을 사용한 후 자신의 주소를 증가시킨다는 의미이고 <code>*++p</code>는 자신의 주소를 증가시킨 후에 그 주소에 가서 값을 사용한다는 뜻이다.</li>
</ul>
<pre><code class="language-c">char data[5] = {'a', 'b', 'c', 'd', 'e'};
char *p1 = data, *p2 = data, data1, data2;

// *p1이 먼저 처리되어 data1에는 'a'값이 저장된다.
// 저장 후에 p1++가 처리되어 주소가 증가하면 p1은 'b'의 위치로 이동하지만 data1에는 영향이 없다.
data1 = *p1++;

// p2의 주소가 먼저 증가되어 p2는 'b'이 위치로 이동한다.
// 이동후에 *p2가 처리되어 data2에는 'b'값이 저장된다.
data2 = *++p2;
</code></pre>
<ul>
<li>작업 후에 포인터 변수 <code>p1</code>과 <code>p2</code>는 둘 다 <code>data</code>배열의 두 번째 요소 주소를 가리킨다.</li>
<li>하지만 작업 순서 때문에 <code>data1</code>에는 값 <code>a</code>가, <code>data2</code>에는 값 <code>b</code>가 저장된다.</li>
</ul>
<h3 id="p와-p는-서로-다른-의미"><a class="header" href="#p와-p는-서로-다른-의미">*++p와 ++*p는 서로 다른 의미</a></h3>
<ul>
<li><code>*++p</code>는 <code>p</code>가 가지고 있는 주소를 증가시킨 후 그 주소에 저장된 값을 사용한다는 뜻이다.</li>
<li><code>++*p</code>는 <code>p</code>가 가지고 있는 주소에 저장된 값을 1만큼 증가시키겠다는 뜻이다.</li>
<li>따라서 <code>*++p</code>는 <code>p</code>의 주소가 변경되고, <code>++*p</code>는 <code>p</code>가 가리키는 대상의 값이 변경된다.</li>
</ul>
<pre><code class="language-c">char data[5] = {'a', 'b', 'c', 'd', 'e'};
char *p1 = data, *p2 = data, data1, data2;
</code></pre>
<p><img src="./images/pointer_operator_1.png" alt="포인터와 증감 연산자 1" /></p>
<pre><code class="language-c">// ++p1이 먼저 처리되어 p1은 'b'의 위치로 이동한다.
// 이동 후에 *p1이 처리되어 data1에는 값 'b'가 저장된다.
data1 = *++p1;
</code></pre>
<p><img src="./images/pointer_operator_2.png" alt="포인터와 증감 연산자 2" /></p>
<pre><code class="language-c">// p2가 가리키는 주소에 가서 해당 주소에 저장된 값을 1만큼 증가시키고
// 그 값을 data2에 저장한다.
// p2는 주소가 변경되지 않는다.
data2 = ++*p2;
</code></pre>
<p><img src="./images/pointer_operator_3.png" alt="포인터와 증감 연산자 3" /></p>
<ul>
<li>결과적으로 <code>data1</code>, <code>data2</code>에는 값 <code>b</code>가 똑같이 들어갔지만 처리 과정에 차이가 많이 난다.</li>
</ul>
<h2 id="tip-7-개발-도구의-도움말-웹-페이지를-활용하자"><a class="header" href="#tip-7-개발-도구의-도움말-웹-페이지를-활용하자">Tip 7. 개발 도구의 도움말 웹 페이지를 활용하자</a></h2>
<ul>
<li>문자열을 복사하는 함수, 문자열 길이를 얻는 함수를 프로그래머가 일일이 만들어 사용할 필요가 없다.</li>
<li>C 언어에서 제공하는 <code>strcpy</code>, <code>strlen</code>같은 런타임 함수를 사용하면 된다.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="tip_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="tip_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
