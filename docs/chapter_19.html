<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>파일 입출력 - Study: Do it C 언어 입문</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html" class="active"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="19-파일-입출력"><a class="header" href="#19-파일-입출력">19. 파일 입출력</a></h1>
<ul>
<li>대부분의 프로그램은 사용자가 입력한 데이터를 계속 유지하기 위해 파일에 정보를 저장하는 기능을 제공하낟.</li>
<li>프로그램에서 사용하던 데이터를 어떻게 파일에 저장하는지, 그리고 저장된 파일에서 데이터를 어떻게 읽어 오는지에 대해 배워보자.</li>
</ul>
<h2 id="19-1-표준-입출력-라이브러리"><a class="header" href="#19-1-표준-입출력-라이브러리">19-1. 표준 입출력 라이브러리</a></h2>
<h3 id="표준-입출력-라이브러리란"><a class="header" href="#표준-입출력-라이브러리란">표준 입출력 라이브러리란?</a></h3>
<ul>
<li>컴퓨터의 주기억 장치인 램(RAM, Random Access Memory)은 컴퓨터의 전원이 켜져 있을 때만 데이터를 유지할 수 있다.</li>
<li>전원이 꺼져도 데이터를 유지할 수 있는 보조기억 장치(디스크, HDD, SSD)가 필요하다.</li>
<li>많은 프로그램이 사용자가 입력한 데이터를 보관하기 위해 보조기억 장치에 데이터를 저장하고 있다.</li>
<li>하지만 보조기억 장치의 종류가 너무 다양하기 때문에 프로그래머가 일일이 보조 기억 장치의 특성을 파악해서 프로그래밍한다는 것은 불가능하다.</li>
<li>그래서 운영체제는 보조기억 장치의 종류에 상관없이 같은 함수로 데이터를 저장할 수 있도록 파일 입출력 라이브러리를 제공하고 있다.
<br><br></li>
<li>그런데 파일 입출력 라이브러리도 운영체제에 따라 조금씩 차이가 있다.</li>
<li>운영체제별로 제공하는 입출력 함수는 이름뿐만 아니라 사용법도 다르다.</li>
<li>윈도우 환경에서 파일 입출력 프로그래밍을 하다가 리눅스 환경에서 작업하게 되면 파일 입출력을 다시 공부해야 할 정도로 운영체제에 따라 차이가 있다.</li>
<li>이런 문제를 해결하기 위해 C 언어는 '표준 입출력 라이브러리'(Standard I/O Library)를 제공한다.</li>
<li>이 라이브러리를 사용하면 보조기억 장치에 파일 단위로 데이터를 저장하거나 읽을 수 있다.</li>
<li>그리고 많은 운영체제에서 이 라이브러리를 제공하기 때문에 호환성이 높다.</li>
<li>따라서 이 방식으로 파일 입출력을 배우게 되면 운영체제에 상관없이 같은 이름의 함수로 보조기억 장치를 사용하는 프로그램을 개발할 수 있다.
<br><br></li>
<li>표준 입출력 라이브러리는 데이터의 형식에 따라 다른 함수를 제공한다.</li>
<li>프로그램이 사용하는 데이터 형식은 '텍스트(문자열)'와 '바이너리(이진)'로 나누어지는데, 자신이 다루는 데이터가 텍스트 형식이면 텍스트 관련 함수를 사용해야 하고, 바이너리 형식이면 바이너리 관련 함수를
사용해야 한다.</li>
<li>그래서 자신이 사용할 데이터가 어떤 형식의 데이터인지 구별할 줄 알아야 한다.</li>
</ul>
<h2 id="19-2-텍스트-파일과-바이너리-파일"><a class="header" href="#19-2-텍스트-파일과-바이너리-파일">19-2. 텍스트 파일과 바이너리 파일</a></h2>
<h3 id="바이너리-속성과-문자열-속성"><a class="header" href="#바이너리-속성과-문자열-속성">바이너리 속성과 문자열 속성</a></h3>
<ul>
<li>프로그램이 사용하는 데이터 속성은 크게 두 가지로 나눌 수 있다.</li>
<li>데이터에 다른 의미를 부여하지 않고 숫자 그 자체로 보는 바이너리(Binary) 속성과 숫자를 아스키(ASCII) 값으로 변환해서 사용하는 문자열(String, Text) 속성이다.</li>
<li>예를 들어 97이라는 데이터를 단순히 숫자 97이 들어 있는 1바이트 크기의 정보라고 처리하는 것이 바이너리 속성이고, 아스키 값 'a'로 처리하는 것이 문자열 속성이다.</li>
<li>데이터를 이해하는 기준에 따라 97을 처리하는 방법이나 결과 값이 달라진다.</li>
<li>다음과 같이 배열로 선언한 크기가 8바이트인 <code>temp</code>변수가 있다.</li>
<li><code>temp</code>변수에는 <code>&quot;abc&quot;</code>문자열이 저장되어 있다.</li>
</ul>
<pre><code class="language-c">/* 마지막 ,(쉼표) 이후의 값은 모두 NULL 문자를 의미하는 아스키 값으로 0으로 초기화됨 */

char temp[8] = { 'a', 'b', 'c', 0, };
</code></pre>
<ul>
<li>먼저 바이너리 속성을 기준으로 하면 <code>temp</code>변수를 8바이트 크기 데이터로 생각하고 그 데이터에는 8개의 아스키 값 <code>97</code>, <code>98</code>, <code>99</code>, <code>0</code>, <code>0</code>, <code>0</code>, <code>0</code>, <code>0</code>이 들어 있다고
생각한다.</li>
<li>반면에 문자열 속성은 <code>temp</code>변수 크기에 별로 의미를 두지 않는다.</li>
<li>그 대신 <code>temp</code>변수에 저장된 값을 아스키 값으로 생각하고 <code>temp</code>변수에 저장된 값에서 <code>NULL</code>문자인 <code>0</code>(EOL, End Of Line)이 나올 때까지 찾는다.</li>
<li>즉 문자열 속성을 기준으로 할 때는 <code>temp</code>변수의 네 번째 요소에서 <code>0</code>을 찾ㄷ으면 데이터 크기가 3바이트고 데이터 내용은 <code>&quot;abc&quot;</code>라고 생각한다.</li>
</ul>
<p><img src="./images/binary_or_string.png" alt="바이너리 속성과 문자열 속성" /></p>
<h3 id="두-속성의-차이점-살펴보기"><a class="header" href="#두-속성의-차이점-살펴보기">두 속성의 차이점 살펴보기</a></h3>
<ul>
<li>데이터 속성에 따라 사용하는 기준이 다르기 때문에 코드를 작성할 때 각 속성별로 사용하는 함수가 다를 수밖에 없다.</li>
</ul>
<h4 id="변수에-저장된-데이터의-크기를-구할-때의-차이점"><a class="header" href="#변수에-저장된-데이터의-크기를-구할-때의-차이점">변수에 저장된 데이터의 크기를 구할 때의 차이점</a></h4>
<ul>
<li>예를 들어 <code>temp</code>변수에 저장된 데이터의 크기를 구하는 경우에 바이너리 속성은 메모리의 크기를 구해야 변수의 크기를 구할 수 있기 때문에 <code>sizeof</code>연산자를 사용한다.</li>
</ul>
<pre><code class="language-c">int data_size = sizeof(temp);  // 변수 크기를 구함. data_size에는 값 8이 저장됨
</code></pre>
<ul>
<li>반면에 문자열 속성은 <code>temp</code>변수에 저장된 문자열의 길이를 구하면 변수의 크기를 구할 수 있기 때문에 <code>string.h</code>에서 제공하는 <code>strlen</code>함수를 사용하여 문자열 길이를 구한다.</li>
</ul>
<pre><code class="language-c">int data_size = strlen(temp);  // 문자열 길이를 구함. data_size에는 값 3이 저장됨
</code></pre>
<h4 id="변수에-저장된-값을-다른-변수에-복사할-때의-차이점"><a class="header" href="#변수에-저장된-값을-다른-변수에-복사할-때의-차이점">변수에 저장된 값을 다른 변수에 복사할 때의 차이점</a></h4>
<ul>
<li>바이너리 속성과 문자열 속성은 <code>temp</code>변수에 저장된 데이터를 다른 변수에 복사할 때도 서로 다른 함수를 사용한다.</li>
<li>바이너리 모드는 변수에 들어 있는 값을 그대로 복사하는 개념을 사용하기 때문에 <code>temp</code>변수의 값을 <code>dest</code>변수로 복사하려면 <code>memcpy</code>함수를 사용한다.</li>
<li>바이너리 속성은 <code>mem</code>으로 시작하는 함수를 사용한다.</li>
</ul>
<pre><code class="language-c">char temp[8] = {'a', 'b', 'c', 0,};
char dest[8];
memcpy(dest, temp, sizeof(temp));  // temp에서 dest로 8바이트 크기만큼 메모리를 복사함
</code></pre>
<ul>
<li>반면에 문자열 속성은 <code>temp</code>변수에 저장되어 있는 문자열만 복사하면 되기 때문에 <code>strcpy</code>함수를 사용한다.</li>
<li>문자열 속성은 <code>str</code>로 시작하는 함수를 사용한다.</li>
</ul>
<pre><code class="language-c">char temp[8] = {'a', 'b', 'c', 0,};
char dest[8];
strcpy(dest, temp);  // temp에서 dest로 4바이트 크기(NULL 문자 0까지 포함)만큼 복사한다
/// 문자열을 복사할 때는 temp에 NULL 문자 0이 나올 때까지 복사하므로 strcpy 함수를 호출할 때 복사할 길이를 적지 않는다
</code></pre>
<ul>
<li><code>memcpy</code>와 <code>strcpy</code>함수를 비교해 보면 <code>strcpy</code>가 더 간단하고 메모리를 복사하는 양도 적다.</li>
<li>그래서 프로그램 효율이 더 좋다고 오해하는 경우가 있다.</li>
<li>하지만 <code>memcpy</code>는 특별한 체크나 데이터 가공 없이 메모리를 그대로 복사하는 함수이고 <code>strcpy</code>는 내부적으로 문자를 하나 복사할 때마다 문자열이 끝이 났는지 제대로 된 문자인지를 계속 체크하면서
복사하는 함수이다.</li>
<li>따라서 <code>memcpy</code>함수가 <code>strcpy</code>함수보다 더 빠르게 동작할 수밖에 없다.</li>
<li>결론적으로 어떤 속성을 사용할지를 결정하면 그에 맞는 함수를 사용해서 프로그래밍해야 원하는 결과를 얻을 수 있다.</li>
<li>그리고 어떤 속성을 사용하든지 데이터 자체가 변경되는 것이 아니라 데이터를 해석하는 개념이 달라지기 때문에 프로그램 개발 상황에 맞게 잘 판단해서 사용하면 된다.</li>
</ul>
<h3 id="바이너리-파일과-텍스트-파일"><a class="header" href="#바이너리-파일과-텍스트-파일">바이너리 파일과 텍스트 파일</a></h3>
<ul>
<li>바이너리 속성 개념이 적용된 파일을 바이너리(Binary) 파일이라고 하며, 문자열 속성이 적용된 파일을 텍스트(Text) 파일이라고 한다.</li>
<li>보통 이미지 파일, 음악 파일, 동영상 파일, 실행 파일은 바이너리 파일로 구성되고 간단한 문서 파일이나 프로그램에서 사용하는 소스 파일은 텍스트 파일로 구성된다.</li>
<li>대부분의 프로그램이 바이너리 파일을 더 많이 사용하고 있다.</li>
<li>그 이유는 텍스트 파일보다 저장 방식이나 처리 효율이 더 좋기 때문이다.</li>
<li>그런데도 텍스트 파일이 공존하는 이유는 무엇일까?</li>
<li>바이너리 파일은 해당 파일을 사용할 수 있는 프로그램이 설치되어 있어야 제대로 사용할 수 있기 때문이다.</li>
<li>소스 파일과 같이 텍스트로 되어 있는 파일은 아스키라는 표준으로 파일이 이루어져 있기 때문에 시스템에 특별한 프로그램이 설치되어 있지 않아도 텍스트 파일에 적힌 문자열을 확인할 수 있다.</li>
</ul>
<h2 id="19-3-파일-열기와-닫기"><a class="header" href="#19-3-파일-열기와-닫기">19-3. 파일 열기와 닫기</a></h2>
<h3 id="파일-입출력-함수의-도우미-file-구조체"><a class="header" href="#파일-입출력-함수의-도우미-file-구조체">파일 입출력 함수의 도우미! FILE 구조체</a></h3>
<ul>
<li>표준 입출력 라이브러리를 사용하여 파일에 데이터를 저장하거나 읽는 방법에 대해 알아보자.</li>
<li>표준 입출력 라이브러리는 'FILE 구조체'로 포인터 변수를 선언하고 파일 입출력 함수를 호출할 때마다 이 변수를 넘겨주도록 만들어져 있다.</li>
<li>FILE 구조체는 사용하려는 디스크(DISK)상의 파일이 어떤 상태로 사용 중인지에 대한 정보를 담고 있으며, 파일을 좀 더 편하게 사용할 수 있도록 도와준다.</li>
</ul>
<pre><code class="language-c">FILE *p_file;

// 파일 열기 생략
fseek(p_file, 0, SEEK_SET);
</code></pre>
<ul>
<li>FILE 구조체의 기본형은 <code>FILE *변수 이름</code>형태이다.</li>
<li>이렇게 'FILE 구조체로 선언한 포인터 변수'를 줄여서 '파일 포인터'라고 한다.</li>
<li>위와 같은 방법으로 <code>fseek</code>함수를 호출하면, 프로그램에서 파일을 사용하며 기억해야 할 내부 상태 값을 <code>p_file</code>파일 포인터에 저장한다.</li>
<li>즉 프로그래머가 파일 처리에 관련된 내부 정보를 몰라도 파일 포인터만 넘겨주면 파일 입출력 함수가 알아서 처리하도록 만들어져 있다.</li>
</ul>
<blockquote>
<h4 id="file-구조체의-내부는-어떤-모습일까"><a class="header" href="#file-구조체의-내부는-어떤-모습일까">FILE 구조체의 내부는 어떤 모습일까</a></h4>
<ul>
<li>FILE 구조체는 <code>stdio.h</code>파일에 다음과 같이 선언되어 있다.</li>
<li>사실 FILE 구조체를 사용하지 않더라도 C 언어의 표준 입출력 라이브러리에서 제공하는 파일 입출력 함수들을 사용하면 구조체의 요소들을 직접 관리할 수 있다.</li>
<li>하지만 FILE 구조체를 사용하는 표준 입출력 함수가 주기억 장치(램)에 비해 속도가 느린 보조기억 장(하드디스크)의 단점을 보완하기 때문에 나같은 초보 프로그래머가 사용하기에 좋다.</li>
<li>그리고 이런 기술은 표준 입출력 함수의 내부에서 이루어지는 것이라서 이 함수들이 사용하는 FILE 구조체의 요소들을 모두 이해할 필요는 없다.</li>
</ul>
<pre><code class="language-c">struct _iobuf {
    char *_ptr;
    int  _cnt;
    char *_base;
    int  _flag;
    int  _file;
    int  _charbuf;
    int  _bufsiz;
    char *_tmpfname;
};

typedef struct _iobuf FILE;
</code></pre>
</blockquote>
<h3 id="파일-열기-fopen-함수"><a class="header" href="#파일-열기-fopen-함수">파일 열기: fopen 함수</a></h3>
<ul>
<li>파일 열기를 할 때는 사용할 '파일 이름'과 '파일을 어떤 형식으로 사용할 것인지'를 먼저 결정하고 <code>fopen</code>함수를 사용하면 된다.</li>
<li><code>fopen</code>함수는 이 두 가지 정보를 문자열 형식이 매개변수로 받아서 처리한다.</li>
</ul>
<pre><code class="language-c">함수 원형: FILE *fopen(const char *filename, const char *mode);
함수 사용 형식: fopen(사용할 파일 이름, 파일 사용 형식)
</code></pre>
<ul>
<li>파일을 성공적으로 열면 <code>FILE *</code>형식의 메모리 주소 값을 반환한다.</li>
<li>만약 파일이 존재하지 않거나 파일 형식을 잘못 사용해서 파일 열기에 실패하면 <code>NULL</code>값을 반환한다.</li>
</ul>
<pre><code class="language-c">// 프로그램 작업 경로에 해당 파일이 있는 경우에 읽기 모드(r)로 jerok.dat 파일을 연다
FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;r&quot;);

if (NULL != p_file) {
// 파일 열기에 성공한 경우
} else {
// 파일 열기에 실패한 경우
}
</code></pre>
<ul>
<li><code>fopen</code>함수에 사용할 파일 이름은 문자열로 지정해야 하며 시스템은 프로그램의 작업 경로(Working Directory, 파일이 실행된 경로)에서 해당 파일을 찾게 된다.</li>
<li>예를 들어 <code>c:\temp</code> 경로에서 <code>exam.exe</code>파일을 실행했다면 <code>exam</code>프로그램의 작업 경로는 <code>c:\temp</code>이다.</li>
<li>그리고 이 작업 경로에서 <code>fopen</code>함수에 사용한 <code>jerok.dat</code>파일을 찾게 된다.</li>
<li>즉 <code>c:\temp\jerok.dat</code>경로에서 파일을 찾는다.</li>
<li>그런데 만약 사용할 파일이 현재 작업 경로에 없다면 파일 이름을 표기할 때 경로까지 같이 표기해 주면 된다.</li>
<li>현재 작업 경로가 <code>c:\temp</code>인데 자신이 사용할 <code>tips.dat</code>파일이 <code>c:\jerok</code>경로에 있다면 <code>&quot;c:\\jerok\\jerok.dat&quot;</code>라고 표기하면 된다.</li>
</ul>
<pre><code class="language-c">// 프로그램 작업 경로에 해당 파일이 없는 경우에 절대 경로를 사용하여 읽기 모드로 jerok.dat 파일을 연다
FILE *p_file = fopen(&quot;c:\\jerok\\jerok.dat&quot;, &quot;r&quot;);

if (NULL != p_file) {
// 파일 열기에 성공한 경우
} else {
// 파일 열기에 실패한 경우
}
</code></pre>
<h3 id="파일-사용-형식-알아보기"><a class="header" href="#파일-사용-형식-알아보기">파일 사용 형식 알아보기</a></h3>
<ul>
<li>파일 사용 형식이란 파일을 어떻게 사용할 것인지 지정하는 형식을 말한다.</li>
<li>즉 '파일 읽기'를 할 것인지, '파일 쓰기'를 할 것인지를 정하는 것이다.</li>
<li>파일 사용 형식은 <code>fopen</code>함수의 두 번째 매개변수인 문자열 형식으로 지정한다.</li>
</ul>
<blockquote>
<h4 id="파일-입출력은-반드시-정해진-형식을-지켜야-한다"><a class="header" href="#파일-입출력은-반드시-정해진-형식을-지켜야-한다">파일 입출력은 반드시 정해진 형식을 지켜야 한다</a></h4>
<ul>
<li>파일을 어떤 형식으로 사용할 것인지를 결정하는 작업은 표준 입출력 라이브러리가 정한 형식을 따라야 한다.</li>
<li>따라서 정해 놓은 규칙을 지키지 않거나 자신이 사용할 파일에 다른 프로그램이 제한을 걸어 놓았다면 파일 열기에 실패할 수 있다.</li>
<li>예를 들어 A 프로그램이 <code>jerok.dat</code>파일에 쓰기 금지 모드를 설정해 놓고 있는데 B 프로그램이 <code>jerok.dat</code>파일을 쓰기 모드로 열려고 시도하면 파일 열기에 실패한다는 뜻이다</li>
</ul>
</blockquote>
<ul>
<li>먼저 파일이 다루는 속성에 따라 기본적으로 나누어지는 형식을 알아보자.</li>
<li>이 두 가지 형식은 단독으로 쓸 수는 없고 뒤에 배우게 될 다른 형식들과 함께 써야 한다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">형식</th><th>설명</th></tr></thead><tbody>
<tr><td style="text-align: center">t</td><td>- 텍스트 속성으로 파일을 사용하겠다는 뜻이다.<br>- 만약 이 형식으로 바이너리 파일을 열면 파일 열기는 성공하겠지만 파일 입출력 함수를 사용하면 오류가 발생한다.<br>- 그 이유는 바이너리 파일은 파일의 실제 크기를 사용하고 텍스트 파일은 EOF(파일의 끝, End Of File)라는 아스키 값을 사용해서 파일의 끝을 구별하기 때문이다.<br>- 그래서 바이너리 파일을 텍스트 속성으로 열면 파일의 끝을 찾는데 문제가 생긴다.</td></tr>
<tr><td style="text-align: center">b</td><td>- 바이너리 속성의 파일을 사용한다는 뜻이다.<br>- 이 형식이 기본값이기 때문에 형식을 지정할 때 <code>t</code>또는 <code>b</code>를 포함하고 있지 않다면 기본적으로 이 형식을 사용한다고 보면 된다.</td></tr>
</tbody></table>
</div>
<h4 id="파일-내용-읽기-모드-r"><a class="header" href="#파일-내용-읽기-모드-r">파일 내용 읽기 모드 &quot;r&quot;</a></h4>
<ul>
<li>이 형식을 사용하면 파일의 내용을 읽기(Read) 위한 목적으로 파일을 연다.</li>
<li>이 형식을 지정하여 <code>fopen</code>함수를 사용했는데 파일이 없으면 파일 열기에 실패하고 <code>NULL</code>값을 반환한다.</li>
<li>바이너리 파일을 여는 경우에 다음과 같이 <code>&quot;rb&quot;</code>를 사용한다.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;rb&quot;);  // &quot;rb&quot; 대신 &quot;r&quot;만 사용해도 됨
</code></pre>
<ul>
<li>텍스트 파일을 열 때는 다음과 같이 <code>&quot;rt&quot;</code>를 사용한다.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.txt&quot;, &quot;rt&quot;);
</code></pre>
<h4 id="파일에-데이터-쓰기-모드-w"><a class="header" href="#파일에-데이터-쓰기-모드-w">파일에 데이터 쓰기 모드 &quot;w&quot;</a></h4>
<ul>
<li>이 형식을 사용하면 파일에 데이터를 쓰기(Write) 위한 목적으로 파일을 연다.</li>
<li>만약 <code>fopen</code>함수에 명시한 파일이 작업 경로에 없다면 그 이름으로 파일을 만든 후에 파일을 열기 때문에 <code>&quot;w&quot;</code>형식을 사용하면 파일 열기에 실패하지 않는다.</li>
<li>하지만 같은 이름을 가진 파일이 이미 존재하는 경우에는 파일을 열면서 그 파일이 가지고 있던 내용을 모두 지우고 시작하기 때문에 주의해야 한다.</li>
<li>바이너리 파일을 여는 경우에 다음과 같이 <code>&quot;wb&quot;</code>를 사용한다.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;wb&quot;);  // &quot;wb&quot; 대신 &quot;w&quot;만 사용해도 됨
</code></pre>
<ul>
<li>텍스트 파일을 열 때는 다음과 같이 <code>&quot;wt&quot;</code>를 사용한다.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;wt&quot;);
</code></pre>
<ul>
<li>그런데 쓰기 모드 형식을 제대로 사용해도 디스크(Disk)에 용량이 부족해서 파일을 만들 수 없거나, CD와 같이 읽기 전용 디스크에 쓰기 모드로 사용하면 파일 열기에 실패한다.</li>
</ul>
<h4 id="파일에-데이터-이어-쓰기-모드-a"><a class="header" href="#파일에-데이터-이어-쓰기-모드-a">파일에 데이터 이어 쓰기 모드 &quot;a&quot;</a></h4>
<ul>
<li>이 형식을 사용하면 파일에 데이터를 확장(Append, 이어 쓰기)하기 위한 목적으로 파일을 연다.</li>
<li>만약 <code>fopen</code>함수에 명시한 파일이 작업 경로에 없다면 그 이름으로 파일을 만든 후에 파일을 열기 때문에 <code>&quot;a&quot;</code>형식을 사용하면 파일 열기에 실패하지 않는다.</li>
<li>하지만 <code>&quot;w&quot;</code>속성과 달리 기존에 파일이 존재하더라도 파일 내용을 지우지 않고 기존 파일 내용에 이어 쓰기를 한다.</li>
<li>바이너리 파일을 여는 경우에 다음과 같이 <code>&quot;ab&quot;</code>를 사용한다.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;ab&quot;);  // &quot;ab&quot; 대신 &quot;a&quot;만 사용해도 됨
</code></pre>
<ul>
<li>텍스트 파일을 열 때는 다음과 같이 &quot;at&quot;를 사용한다.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;at&quot;);
</code></pre>
<ul>
<li>이 형식도 디스크에 용량이 부족하거나 읽기 전용 디스크에 사용하면 파일 읽기에 실패한다.</li>
</ul>
<h3 id="파일-사용-형식에서-읽기와-쓰기를-같이-사용하기"><a class="header" href="#파일-사용-형식에서-읽기와-쓰기를-같이-사용하기">파일 사용 형식에서 읽기와 쓰기를 같이 사용하기</a></h3>
<h4 id="읽기-강조-r"><a class="header" href="#읽기-강조-r">읽기 강조 &quot;r+&quot;</a></h4>
<ul>
<li>읽기와 쓰기를 같이 사용할 때 '읽기'를 더 강조하는 형식이다.</li>
<li>이 형식으로 파일을 여는 경우 기존 파일이 없으면 파일을 새로 만들지 않고 파일 읽기에 실패한다.</li>
<li>기존 파일이 있는 경우에는 해당 파일의 내용을 지우지는 않지만 기존 데이터의 위치로 이동해서 해당 위치의 내용을 덮어쓸 수 있다.</li>
<li>이 형식을 바이너리 파일에 사용하는 경우에 <code>&quot;r+&quot;</code>, <code>&quot;rb+&quot;</code>또는 <code>&quot;r+b&quot;</code>라고 쓰며, 텍스트 파일에 사용하는 경우에는 <code>&quot;rt+&quot;</code>또는 <code>&quot;r+t&quot;</code>라고 쓴다.</li>
</ul>
<h4 id="쓰기-강조-w"><a class="header" href="#쓰기-강조-w">쓰기 강조 &quot;w+&quot;</a></h4>
<ul>
<li>읽기와 쓰기를 같이 사용할 때 '쓰기'를 더 강조하는 형식이다.</li>
<li>이 형식으로 파일을 여는 경우 기존 파일이 없으면 파일을 새로 만들고, 파일이 이미 존재하면 기존 파일의 내용을 모두 지우고 시작한다.</li>
<li>이 형식을 바이너리 파일에 사용하는 경우에 <code>&quot;w+&quot;</code>, <code>&quot;wb+&quot;</code>또는 <code>&quot;w+b&quot;</code>라고 쓸 수 있으며 텍스트 파일에 사용하는 경우에는 <code>&quot;wt+&quot;</code>또는 <code>&quot;w+t&quot;</code>라고 쓴다.</li>
</ul>
<h4 id="읽기와-이어-쓰기를-같이-사용하기-a"><a class="header" href="#읽기와-이어-쓰기를-같이-사용하기-a">읽기와 이어 쓰기를 같이 사용하기 &quot;a+&quot;</a></h4>
<ul>
<li>읽기 모드와 이어 쓰기 모드를 같이 사용해야 하는 경우에 사용하며 '확장'을 더 강조하는 형식이다.</li>
<li>확장을 더 강조한다는 뜻은 이 형식으로 파일을 여는 경우에 기존 파일이 없으면 파일을 새로 만들고 파일이 존재하면 파일의 내용을 지우지 않고 기존 내용에 이어서 시작한다는 뜻이다.</li>
<li>하지만 <code>&quot;r+&quot;</code>와 달리 기존 데이터 위치로 이동할 수 있고 읽기도 가능하지만 쓰기를 사용하면 현재 위치와 상관없이 파일의 끝에 내용이 추가된다.</li>
<li>이 형식을 바이너리 파일에 사용하는 경우에 <code>&quot;a+&quot;</code>, <code>&quot;ab+&quot;</code>또는 <code>&quot;a+b&quot;</code>라고 쓸 수 있으며 텍스트 파일에 사용하는 경우에는 <code>&quot;at+&quot;</code>또는 <code>&quot;a+t&quot;</code>라고 쓴다.</li>
<li><code>&quot;r+&quot;</code>모드처럼 기존 데이터 위치로 이동하거나 읽는 것은 가능하다.</li>
<li>읽기나 쓰기를 같이 사용하려면 <code>&quot;r+&quot;</code>나 <code>&quot;w+&quot;</code>와 같이 적어야 하는데 <code>&quot;rw&quot;</code>라고 적기도 한다.</li>
<li>하지만 <code>&quot;rw&quot;</code>는 표준이 아니기 때문에 컴파일러에 따라 <code>&quot;r+&quot;</code>나 <code>&quot;w+&quot;</code>로 자동 변환하거나 <code>fopen</code>함수의 실행이 실패한다.</li>
<li>따라서 가능하면 위에 나열한 형식 중 하나를 선택해서 사용하는 것이 좋다.</li>
</ul>
<h3 id="파일-닫기-fclose-함수"><a class="header" href="#파일-닫기-fclose-함수">파일 닫기: fclose 함수</a></h3>
<ul>
<li>이렇게 <code>fopen</code>함수를 사용하여 파일을 열어서 사용하다가 사용이 끝나면 <code>fclose</code>함수를 사용하여 파일을 닫아야 한다.</li>
<li>만약 파일을 열어 놓고 파일을 닫지 않으면 파일의 내용이 지워지거나 파일을 사용할 수 없는 상태가 될 수 있으니 주의하자.</li>
<li>그리고 파일을 열지 않은 상태에서 파일 닫기를 시도하거나 이미 닫은 <code>FILE *</code>주소(파일 포인터 주소)로 파일 닫기를 다시 시도하면 프로그램 실행에 오류가 발생할 수 있으니 이 또한 주의하자.</li>
</ul>
<pre><code class="language-c">FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;r+b&quot;);  // 읽기+쓰기 모드로 바이너리 파일을 오픈함

if(NULL != p_file) {  // 파일 열기에 성공한 경우
    fclose(p_file);  // 파일을 닫음
} else {
    // 파일 열기에 실패한 경우
}
</code></pre>
<h2 id="19-4-텍스트-파일에-데이터-읽고-쓰기"><a class="header" href="#19-4-텍스트-파일에-데이터-읽고-쓰기">19-4. 텍스트 파일에 데이터 읽고 쓰기</a></h2>
<h3 id="텍스트-파일에-문자열-저장하기-fprintf-함수1"><a class="header" href="#텍스트-파일에-문자열-저장하기-fprintf-함수1">텍스트 파일에 문자열 저장하기: fprintf 함수(1)</a></h3>
<ul>
<li>텍스트 파일에 데이터를 읽고 쓰는 개념은 콘솔에서 문자열을 입력 또는 출력하는 개념과 비슷하기 때문에 매우 쉽다.</li>
<li>모니터 화면에 문자 또는 숫자를 출력하고 싶으면 <code>printf</code>함수를 사용한다.</li>
<li>파일 입출력 함수에는 <code>print</code>함수와 모든 기능이 비슷하고 이름까지 비슷한 <code>fprintf</code>함수가 있다.</li>
<li><code>fprintf</code>함수는 첫 매개변수에 파일 포인터를 받아서 출력할 문자열을 파일에 저장한다.</li>
<li>예를 들어 화면에 <code>abc</code>문자열을 출력하고 싶으면 <code>printf(&quot;abc&quot;);</code>라고 사용하지만 파일에 <code>abc</code>문자열을 저장하고 싶다면 <code>fprintf(파일 포인터, &quot;abc&quot;);</code>라고 사용한다.</li>
</ul>
<pre><code class="language-c">함수 원형: int fprintf(FILE *stream, const char *format [, argument ] ... );
함수 사용 형식: fprintf(파일 포인터, 파일에 입력할 문자열 형식, 출력할 값들, ... )
</code></pre>
<ul>
<li>다음은 파일 포인터가 가리키는 파일에 <code>Hello</code>문자열을 출력하고 줄을 바꾸는 코드이다.</li>
</ul>
<pre><code class="language-c">fprintf(p_file, &quot;Hello\n&quot;);  // 파일에 &quot;Hello&quot; 문자열을 쓰고 줄 바꿈을 함
</code></pre>
<ul>
<li><code>fprintf</code>함수를 사용해서 파일에 문자열을 출력하는 예제를 하나 만들어 보자.</li>
<li>다음은 <code>jerok.txt</code>파일에 <code>Hello</code>문자열을 저장하는 예제이다.</li>
<li>그리고 <code>fopen</code>함수에서 파일 사용 형식에 <code>&quot;w&quot;</code>가 있을 경우에 첫 번째 매개변수로 넘겨준 파일(<code>jerok.txt</code>)이 없으면 파일을 만들어서 사용하고 파일이 존재하면 덮어쓰기를 한다.</li>
<li>파일에 문자열을 출력한다는 것은 문자열을 저장한다는 뜻과 같다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    FILE *p_file = fopen(&quot;jerok.txt&quot;, &quot;wt&quot;);  // 쓰기 모드로 텍스트 파일을 오픈함
    if (NULL != p_file) {                          // 파일 열기에 성공한 경우
        fprintf(p_file, &quot;Hello\n&quot;);  // 파일에 &quot;Hello&quot; 문자열을 쓰고 줄 바꿈을 함 
        fclose(p_file);                       // 파일을 닫음
    }
}
</code></pre>
<pre><code class="language-text">Hello
</code></pre>
<p><img src="./images/file_io.png" alt="파일 입출력" /></p>
<ul>
<li>위와 같이 <code>jerok.txt</code>파일이 생성되고 파일 안에 <code>Hello</code>라는 문자열이 저장된 것을 볼 수 있다.</li>
</ul>
<h3 id="바이너리-형태를-문자열-형태로-저장하기-fprintf-함수2"><a class="header" href="#바이너리-형태를-문자열-형태로-저장하기-fprintf-함수2">바이너리 형태를 문자열 형태로 저장하기: fprintf 함수(2)</a></h3>
<ul>
<li><code>int</code>형 변수에 들어 있는 값은 바이너리 데이터이기 때문에 텍스트 파일에 저장하려면 문자열 형식으로 변환해서 저장해야 한다.</li>
<li><code>fprintf</code>함수는 <code>printf</code>함수와 마찬가지로 변수 값을 문자열로 출력할 수 있다.</li>
<li>따라서 표준 입출력 함수에서 제공하는 <code>%d</code>, <code>%f</code>같은 형식 지정 키워드를 사용해 파일에 문자열 형태로 저장한다.</li>
<li>다음처럼 코드를 작성하면 별도의 변환 작업 없이 <code>data</code>변수의 값을 파일에 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">short int data = 0x0412;
fprint(p_file, &quot;%x\n&quot;, data);  // 파일에 &quot;412&quot;라고 저장하고 줄 바꿈을 함
</code></pre>
<ul>
<li><code>fprintf</code>함수는 호출될 때마다 자신이 파일에 저장한 문자열의 개수만큼 파일 포인터를 이동시킨다.</li>
<li>즉 파일의 현재 사용 상태를 가리키는 정보 중에서 '파일 내부 데이터를 읽거나 쓰기 시작하는 위치'가 문자열의 개수만큼 이동한다는 뜻이다.</li>
<li>따라서 연속적으로 <code>fprintf</code>함수를 호출하면 문자열이 차례대로 각 파일에 저장된다.</li>
</ul>
<pre><code class="language-c">short int data = 0x0412;
fprintf(p_file, &quot;Hello\n&quot;);     // 파일에 &quot;Hello&quot; 문자열을 쓰고 줄 바꿈을 함
fprintf(p_file, &quot;%x\n&quot;, data);  // 파일에 &quot;412&quot; 문자열을 저장하고 줄 바꿈을 함
</code></pre>
<h3 id="텍스트-파일에서-문자열-읽기-fscanf-함수"><a class="header" href="#텍스트-파일에서-문자열-읽기-fscanf-함수">텍스트 파일에서 문자열 읽기: fscanf 함수</a></h3>
<ul>
<li>텍스트 파일에서 문자열을 얻으려면 <code>fscanf</code>함수를 사용하면 된다.</li>
<li>이 함수는 키보드로 문자 또는 숫자를 입력 받는 <code>scanf</code>함수와 비슷하지만 첫 번째 매개변수에 어떤 파일에서 입력 값을 가져올 것인지를 명시하는 점이 다르다.</li>
</ul>
<pre><code class="language-c">함수 원형: int fscanf(FILE *stream, const char *format [, argument ] ... );
함수 사용 형식: fscanf(파일 포인터, 파일에서 데이터를 입력 받을 형식, 입력 받을 변수 목록);
</code></pre>
<ul>
<li>아래는 파일에 저장된 문자열을 읽어 10진 정수 값으로 변환하여 <code>data</code>변수에 대입하는 코드이다.</li>
</ul>
<pre><code class="language-c">int data;
fscanf(p_file, &quot;%d&quot;, &amp;data);
</code></pre>
<ul>
<li>파일에 저장된 문자열을 <code>fscanf</code>함수로 읽어 오는 예제에 사용하기 위해 아래 이미지 처럼 <code>jerok.txt</code>파일을 만들었다.</li>
<li>이 파일은 예제 소스 파일과 같은 경로에 있어야 프로그램이 정상적으로 수행되기 때문에 경로에 주의하자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int num1, num2, num3;

    FILE *p_file = fopen(&quot;jerok.txt&quot;, &quot;rt&quot;);  // 읽기 모드로 텍스트 파일을 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우
        // num1에 412, num2에 100, num3에 123 값을 저장함
        fscanf(p_file, &quot;%d %d %d&quot;, &amp;num1, &amp;num2, &amp;num3);
        // 파일에서 읽은 값을 화면에 출력함
        printf(&quot;%d %d %d\n&quot;, num1, num2, num3);
        fclose(p_file);  // 파일을 닫음
    }
}
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int num;
    
    FILE *p_file = fopen(&quot;jerok.txt&quot;, &quot;rt&quot;);  // 읽기 모드로 텍스트 파일을 오픈함
    
    if(NULL != p_file) {  // 파일 열기에 성공한 경우
        /// 텍스트 파일의 끝은 EOF(End Of File) 문자로 구별하는데 fscanf 함수가 EOF 문자를 만나면 EOF값을 반환한다
        /// 따라서 EOF를 반환할 때까지 반복하면서 숫자 값을 읽어온다
        while(EOF != fscanf(p_file, &quot;%d&quot;, &amp;num)) {
            printf(&quot;%d\n&quot;, num);
        }
        fclose(p_file);
    }
}
</code></pre>
<h4 id="fscanf-함수로-문자열을-읽을-때-주의-사항"><a class="header" href="#fscanf-함수로-문자열을-읽을-때-주의-사항">fscanf 함수로 문자열을 읽을 때 주의 사항</a></h4>
<ul>
<li><code>fscanf</code>함수는 기본적으로 공백(Space) 문자를 만나면 다음 입력이 시작된 것으로 처리한다.</li>
<li><code>fscanf</code>함수를 사용했을때 한 줄씩 출력될 것으로 예상했지만, 공백으로 입력을 구별하는 <code>fscanf</code>함수의 특성 때문에 예상과 다른 결과를 볼 수 있다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char temp[64];  // 파일에서 문자열을 입력 받을 배열 변수

    FILE *p_file = fopen(&quot;jerok.txt&quot;, &quot;rt&quot;);  // 읽기 모드로 텍스트 파일 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우
        while (EOF != fscanf(p_file, &quot;%s&quot;, temp)) {  // temp는 &amp;temp[0]과 같다
            // 파일에서 읽은 문자열을 화면에 출력함
            printf(&quot;%s\n&quot;, temp);
        }
        fclose(p_file);  // 파일을 닫음
    }
}
</code></pre>
<pre><code class="language-text">Hello,
Jerok
Text
file
input
</code></pre>
<h3 id="텍스트-파일에서-한-줄-단위로-문자열-읽기-fgets-함수"><a class="header" href="#텍스트-파일에서-한-줄-단위로-문자열-읽기-fgets-함수">텍스트 파일에서 한 줄 단위로 문자열 읽기: fgets 함수</a></h3>
<ul>
<li><code>fscanf</code>함수는 문자열 사이에 공백이 있기 때문에 한 줄 단위로 입력 받지 못하고 단어 단위로 파일에서 읽어온다.</li>
<li>따라서 텍스트 파일에서 한 줄 단위로 문자열을 처리하고 싶은 경우에는 <code>fgets</code>함수를 사용한다.</li>
<li>이 함수는 <code>gets</code>함수와 비슷하며 함수의 세 번째 매개변수에 어떤 파일에서 입력 값을 가져올 것인지 파일 포인터를 표기하면 된다.</li>
</ul>
<pre><code class="language-c">함수 원형: char *fgets(char *string, int n, FILE *stream);
함수 사용 형식: fgets(파일에서 읽은 문자열을 저장할 메모리의 주소, 첫 번째 매개변수로 사용한 메모리의 크기, 파일 포인터);
</code></pre>
<ul>
<li>아래는 텍스트 파일에서 문자열 한 줄을 읽어 와서 <code>temp</code>배열에 저장하는 코드이다.</li>
</ul>
<pre><code class="language-c">char temp[64];
fgets(temp, sizeof(temp), p_file);
</code></pre>
<ul>
<li><code>fgets</code>함수를 사용하여 <code>jerok.txt</code>파일을 읽으면 어떻게 되는지 확인해 보자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char temp[64];  // 파일에서 문자열을 입력 받을 배열 변수

    FILE *p_file = fopen(&quot;jerok.txt&quot;, &quot;rt&quot;);  // 읽기 모드로 텍스트 파일을 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우

        /// fgets 함수의 두 번째 매개변수는 첫 번째 매개변수에 사용되는 메모리의 크기를 표기한다
        while (NULL != fgets(temp, sizeof(temp), p_file)) {

            /// 파일에서 읽은 문자열을 화면에 출력한다.
            /// fgets 함수는 fscanf 함수와 달리 줄의 끝에 있는 \n도 읽어서 temp 배열 마지막에 넣어 주기 때문에
            /// printf 함수를 사용할 때 \n을 적지 않는다.
            printf(&quot;%s&quot;, temp);
        }
        
        fclose(p_file);
    }
}
</code></pre>
<pre><code class="language-text">Hello, Jerok
Test file input
</code></pre>
<ul>
<li>출력 결과를 비교해 보면 알 수 있듯이 <code>fscanf</code>함수는 줄 바꿈뿐만 아니라 공백 문자 입력도 구별한다.</li>
<li>하지만 <code>fgets</code>함수는 입력이 구분을 줄 바꿈으로만 판단하기 때문에 파일에 저장된 문자열을 한 줄 단위로 읽어 온다.</li>
<li>그 외에도 <code>fscanf</code>함수는 EOF 문자를 만나면 EOF를 반환하지만 <code>fgets</code>함수는 EOF 문자를 만나면 <code>NULL</code>을 반환한다.</li>
<li>그리고 <code>fscanf</code>함수는 읽은 문자열에서 <code>\n</code>을 제외하는데 <code>fgets</code>함수는 <code>\n</code>을 문자열에 포함한다는 것이 다르다.</li>
</ul>
<h2 id="19-5-바이너리-파일에-데이터-읽고-쓰기"><a class="header" href="#19-5-바이너리-파일에-데이터-읽고-쓰기">19-5. 바이너리 파일에 데이터 읽고 쓰기</a></h2>
<h3 id="문자열-속성과-바이너리-속성의-차이점"><a class="header" href="#문자열-속성과-바이너리-속성의-차이점">문자열 속성과 바이너리 속성의 차이점</a></h3>
<ul>
<li>문자열 속성은 문자열에 포함된 <code>NULL</code>문자 0을 찾아서 데이터 크기를 체크하기 때문에 문자열 길이를 추가로 적을 필요가 없다.</li>
<li>예를 들어 <code>abc</code>문자열이 있으면 a, b, c다음에 <code>NULL</code>문자인 0이 있으므로 문자열을 체크하여 데이터 크기가 3이라는 것을 알 수 있다.</li>
<li>하지만 바이너리 속성은 데이터를 그냥 숫자로만 판단하기 때문에 표준 입출력 함수가 데이터를 분석해서 길이나 크기를 알아낼 수 없다.</li>
<li>따라서 바이너리 속성으로 데이터를 읽거나 쓰려면 반드시 프로그래머가 직접 크기를 적어주어야 한다.</li>
<li>이런 특성은 바이너리 속성을 사용하는 바이너리 파일에서도 마찬가지로 적용된다.</li>
<li>따라서 바이너리와 관련된 파일 입출력 함수는 대부분 데이터 크기를 적도록 되어 있다.</li>
</ul>
<h3 id="바이너리-파일에-데이터-저장하기-fwrite-함수"><a class="header" href="#바이너리-파일에-데이터-저장하기-fwrite-함수">바이너리 파일에 데이터 저장하기: fwrite 함수</a></h3>
<ul>
<li><code>fwrite</code>함수는 다음과 같은 형식으로 호출해서 데이터를 저장한다.</li>
</ul>
<pre><code class="language-c">함수 원형: size_t fwrite(const void *buffer, size_t size, size_t count, FILE *stream);
사용 형식: fwrite(저장할 데이터의 시작 주소, 저장할 데이터의 기준 단위 크기, 반복 횟수, 파일 포인터);
</code></pre>
<ul>
<li>예를 들어 <code>int</code>형 변수 <code>data</code>에 저장되어 있는 16진수 값을 파일에 저장하고 싶다면 다음과 같이 코드를 구성하면 된다.</li>
</ul>
<pre><code class="language-c">int data = 0x00000412;

// data 변수가 할당된 메모리를 4바이트 크기만큼 1회만 p_file 포인터가 가리키는 파일에 저장함
fwrite(&amp;data, sizeof(int), 1, p_file);
</code></pre>
<ul>
<li>이렇게 <code>fwrite</code>를 사용하면 <code>p_file</code>파일 포인터가 가리키는 바이너리 파일에 <code>data</code>변수의 값이 4바이트 크기로 복사된다.</li>
<li><code>fwrite</code>함수는 저장할 데이터의 시작 주소부터 데이터의 기준 단위 크기로 반복 횟수만큼 파일에 데이터를 쓰게 된다.</li>
<li>따라서 실제로 파일에 저장되는 크기는 '기준 단위 크기 x 반복 횟수'이다.</li>
<li>따라서 앞의 예시에서 4바이트가 저장된 이유는 <code>fwrite</code>함수를 호출할 때 사용한 두 번째와 세 번째 매개변수를 곱한 크기만큼 데이터가 저장되기 때문이다.</li>
<li>즉 데이터가 <code>sizeof(int) x 1</code>크기로 저장된다.</li>
<li><code>fwrite</code>함수를 사용해서 바이너리 파일에 <code>int</code>형으로 만든 변수의 값을 저장하는 예제를 만들어 보자.</li>
<li>다음은 <code>jerok.dat</code>파일을 바이너리 속성으로 열어서 <code>data</code>변수에 <code>0x00000412</code>값을 저장하는 예제이다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data = 0x00000412;

    FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;wb&quot;);  // 쓰기 모드로 바이너리 파일을 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우

        /// data의 시작 주소부터 4바이트 크기만큼 한 번만 p_file 파일 포인터가 가리키는 파일에 저장한다.
        fwrite(&amp;data, sizeof(int), 1, p_file);
        fclose(p_file);  // 파일을 닫음
    }
}
</code></pre>
<ul>
<li>위의 예제를 실행했을 때 소스 파일이 있는 경로에 <code>jerok.dat</code>파일이 없다면 파일이 새로 만들어지고, <code>jerok.dat</code>파일이 있다면 내용이 전부 지워진 채로 열릴 것이다.</li>
<li>하지만 이 파일이 바이너리 파일이기 때문에 <code>0x00000412</code>값이 제대로 저장되었는지 확인하기 어렵다.</li>
<li>뒤에서 배우게 될 <code>fread</code>함수를 사용하면 작성한 프로그램으로 값이 제대로 저장되었는지 확인할 수 있다.</li>
</ul>
<h4 id="fwrite-함수의-세-번째-매개변수-반복-횟수의-용도"><a class="header" href="#fwrite-함수의-세-번째-매개변수-반복-횟수의-용도">fwrite 함수의 세 번째 매개변수 '반복 횟수'의 용도</a></h4>
<ul>
<li><code>fwrite</code>함수를 사용하여 <code>int</code>형 배열의 내용을 파일에 저장하고 싶다면 다음과 같이 사용한다.</li>
</ul>
<pre><code class="language-c">int data[5] = {0, 1, 2, 3, 4};

// data 배열의 시작 주소부터 4바이트 단위로 5회 반복해서 파일에 저장함
fwrite(data, sizeof(int), 5, p_file);
</code></pre>
<ul>
<li>위 코드에서 <code>data</code>는 <code>&amp;data[0]</code>의 줄임 표현이다.</li>
<li>즉 <code>data</code>배열의 시작 주소를 의미한다.</li>
<li>위 예제에서 배열로 선언한 <code>data</code>변수는 <code>int</code>크기의 변수 5개를 의미한다.</li>
<li>따라서 <code>fwrite</code>함수를 사용할 때 두 번째 매개변수에는 <code>int</code>형 크기를 적고, 세 번째 매개변수에는 5번 반복을 의미하는 값 5를 적었다.</li>
<li>하지만 <code>fwrite</code>함수를 사용해서 배열을 저장한다고 해서 저장할 크기를 반드시 '단위 크기'와 '반복 횟수'로 나누어야 하는 것은 아니다.</li>
<li>다음과 같이 사용하는 경우가 더 많다.</li>
</ul>
<pre><code class="language-c">fwrite(data, sizeof(int) * 5, 1, p_file);
</code></pre>
<ul>
<li>단위 크기를 <code>sizeof(int)</code>, 반복 횟수를 5라고 적은 경우는 배열 요소에 의미를 더 부여한 것이고, 단위 크기를 <code>sizeof(int) * 5</code>, 반복 횟수를 1이라고 적은 것은 20바이트 메모리라는
것을 더 강조하는 형태이다.</li>
<li>그렇지 않고 배열의 크기를 사용해서 다음과 같이 적기도 한다.</li>
<li><code>sizeof(data)</code>를 사용하면 <code>data</code>배열의 크기를 의미하기 때문에 20으로 번역된다.</li>
</ul>
<pre><code class="language-c">fwrite(data, sizeof(data), 1, p_file);
</code></pre>
<h4 id="fwrite-함수의-작업이-실패할-때도-있다"><a class="header" href="#fwrite-함수의-작업이-실패할-때도-있다">fwrite 함수의 작업이 실패할 때도 있다</a></h4>
<ul>
<li><code>fwrite</code>함수는 반드시 작업에 성공하는 함수가 아니다.</li>
<li>디스크 용량이나 파일 속성(쓰기 제한) 때문에 실패할 수 있다.</li>
<li>따라서 <code>fwrite</code>함수의 반환값을 체크해서 파일에 데이터를 제대로 저장했는지 확인해야 한다.</li>
<li><code>fwrite</code>함수가 작업에 성공하면 실제로 반복한 횟수를 반환하기 때문에 이 값을 체크하여 오류를 처리하는 것이 좋다.</li>
</ul>
<pre><code class="language-c">if(5 == fwrite(&amp;data, sizeof(int), 5, p_file)) {
    // 쓰기에 성공한 경우 수행할 명령문
}
</code></pre>
<ul>
<li><code>fwrite</code>함수를 사용해서 데이터를 저장하면 파일 포인터가 가리키는 정보 중에서 '파일 내부 데이터를 읽거나 쓰기 시작하는 위치'가 데이터를 저장한(단위 크기 x 횟수) 크기만큼 자동으로 증가한다.</li>
<li>따라서 파일에 데이터를 저장한 만큼 이동하는 함수를 추가로 사용할 필요가 없다.</li>
<li>즉 현재 열어 놓은 파일의 내부 위치를 이동시키는 작업을 하지 않고 나열식으로 <code>fwrite</code>함수를 사용하더라도 같은 위치에 계속 데이터를 덮어쓰지 않고 순차적으로 저장된다.</li>
<li>파일 포인터는 파일의 현재 사용 상태를 나타내는 메모리의 주소를 가지고 있다.</li>
<li>예를 들어 다음 예제처럼 나열식으로 <code>fwrite</code>함수를 사용하면 바이너리 파일에는 4바이트 크기로 100값이 저장되고 그 다음 위치에 20바이트만큼 0, 1, 2, 3, 4값이 저장된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data = 100, data_list[5] = {0, 1, 2, 3, 4};

    FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;wb&quot;);  // 쓰기 모드로 바이너리 파일을 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우
        fwrite(&amp;data, sizeof(int), 1, p_file);
        fwrite(data_list, sizeof(int), 5, p_file);
        fclose(p_file);  // 파일을 닫음
    }
}
</code></pre>
<ul>
<li>아래 그림처럼 파란색 화살표가 파일 안에서 쓰기 작업을 할 위치를 표시한 것인데, <code>fwrite</code>함수가 호출될 때마다 이 위치가 자동으로 이동해서 파일 안에 데이터를 쓴다는 뜻이다.</li>
</ul>
<p><img src="./images/fwrite_function.png" alt="fwrite 함수로 바이너리 파일에 순차적으로 값 저장하기" /></p>
<h3 id="바이너리-파일에서-데이터-읽기-fread-함수"><a class="header" href="#바이너리-파일에서-데이터-읽기-fread-함수">바이너리 파일에서 데이터 읽기: fread 함수</a></h3>
<ul>
<li>바이너리 파일에서 데이터를 읽을 때에는 <code>fread</code>함수를 사용하여 다음처럼 호출한다.</li>
</ul>
<pre><code class="language-c">함수 원형: size_t fread(void *buffer, size_t size, size_t count, FILE *stream);
사용 형식: fread(읽은 데이터를 저장할 주소, 저장할 데이터의 기준 단위 크기, 반복 횟수, 파일 포인터);
</code></pre>
<ul>
<li>예를 들어 파일에 저장되어 있는 데이터를 읽어서 <code>int</code>형 변수 <code>data</code>에 저장하고 싶다면 다음과 같이 코드를 구성하면 된다.</li>
</ul>
<pre><code class="language-c">int data;

// p_file이 가리키는 파일에서 4바이트 크기만큼 1회만 데이터를 읽어 와서 data 변수에 저장함
fread(&amp;data, sizeof(int), 1, p_file);
</code></pre>
<ul>
<li>이렇게 <code>fread</code>함수를 사용하면 <code>p_file</code>파일 포인터가 가리키는 바이너리 파일에서 4바이트 크기로 데이터를 읽어서 <code>data</code>변수에 저장한다.</li>
<li><code>fread</code>함수를 다시 한 번 정리해 보면 파일에서 기준 단위 크기로 반복 횟수만큼 데이터를 읽어 와서 '데이터를 저장할 주소'에 읽은 데이터를 저장한다.</li>
<li>따라서 실제로 파일에서 읽은 데이터의 크기는 '단위 크기 x 반복 횟수'이다.</li>
<li>위의 예시에서 4바이트를 파일에서 읽은 이유는 <code>fread</code>함수를 호출할 때 사용한 두 번째 매개변수와 세 번째 매개변수를 곱한 크기만큼 읽어 오기 때문이다.</li>
<li>즉 <code>sizeof(int) * 1</code> 크기만큼 읽는다.</li>
<li><code>fread</code>함수를 사용해 바이너리 파일의 첫 4바이트를 읽어 와서 <code>int</code>형으로 만든 변수에 값을 저장하는 예제를 만들어 보자.</li>
<li>다음은 <code>jerok.dat</code>파일에 있는 첫 4바이트 데이터를 읽어 와서 <code>data</code>변수에 저장하는 예제이다</li>
<li>이 예제에서 <code>jerok.dat</code>파일을 제대로 읽기 위해서는 소스 파일이 저장된 경로에 <code>jerok.dat</code>파일을 복사해야 한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data;

    FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;rb&quot;);  // 읽기 모드로 바이너리 파일을 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우

        /// 읽기 모드(r)로 파일을 열면 파일의 처음 위치부터 데이터를 읽을 수 있다.
        /// 파일의 첫 4바이트(int)만큼 읽어 와서 data의 시작 주소에 넣는다.
        fread(&amp;data, sizeof(int), 1, p_file);
        fclose(p_file);  // 파일을 닫음
        printf(&quot;file data : %d(0x%08x)&quot;, data, data);  // 파일에서 읽은 값을 출력함
    }
}
</code></pre>
<pre><code class="language-text">file data : 100(0x00000064)
</code></pre>
<ul>
<li><code>fread</code>함수를 호출하면 실제로 데이터를 읽어 온 크기만큼 '파일 내부 데이터를 읽거나 쓰기 시작하는 위치'가 증가한다.</li>
<li>그 다음 <code>fread</code>함수를 호출하면 증가한 위치에서부터 파일 읽기를 시작한다.</li>
<li>따라서 <code>fread</code>함수도 특별한 위치 지정 없이 파일에서 데이터를 순차적으로 읽어 올 수 있다.</li>
</ul>
<h4 id="fread-함수의-세-번째-매개변수-반복-횟수의-용도"><a class="header" href="#fread-함수의-세-번째-매개변수-반복-횟수의-용도">fread 함수의 세 번째 매개변수 '반복 횟수'의 용도</a></h4>
<ul>
<li><code>fread</code>함수를 사용하여 파일에서 20바이트의 데이터를 읽어 와서 <code>int</code>형 배열에 저장하고 싶다면 다음과 같이 코드를 구성하면 된다.</li>
</ul>
<pre><code class="language-c">int data[5];

// 파일에서 4바이트 단위로 5회 반복해서 데이터를 읽어와 data 배열에 저장함
fread(data, sizeof(int), 5, p_file);
</code></pre>
<ul>
<li>배열로 선언한 <code>data</code>변수는 <code>int</code>크기의 변수 5개를 의미한다.</li>
<li>따라서 <code>fread</code>함수를 사용할 때 두 번째 매개변수에는 <code>int</code>형의 크기를, 세 번째 매개변수에는 5회 반복을 의미하는 값 5를 적었다.</li>
<li>하지만 <code>fread</code>함수가 배열을 사용한다고 해서 읽어 올 전체 데이터 크기를 반드시 '단위 크기'와 '반복 횟수'로 나누어야 하는 것은 아니다.</li>
<li>사실 다음과 같이 사용하는 경우가 더 많다.</li>
</ul>
<pre><code class="language-c">fread(data, sizeof(int) * 5, 1, p_file);
</code></pre>
<ul>
<li>단위 크기를 <code>sizeof(int)</code>로 적은 경우는 배열 요소에 의미를 더 부여한 것이고, 앞 예제처럼 <code>sizeof(int) * 5</code>라고 적은 것은 전체 데이터 크기가 20바이트 메모리라는 것을 더 강조하는
형태이다.</li>
<li>아니면 배열의 크기를 사용해서 다음과 같이 적기도 한다.</li>
<li><code>sizeof(data)</code>라고 사용하면 <code>data</code>배열의 크기를 의미하기 때문에 값 20으로 번역된다.</li>
</ul>
<pre><code class="language-c">fread(data, sizeof(data), 1, p_file);
</code></pre>
<blockquote>
<h4 id="fread-함수의-작업도-실패할-수-있다"><a class="header" href="#fread-함수의-작업도-실패할-수-있다">fread 함수의 작업도 실패할 수 있다</a></h4>
<ul>
<li><code>fread</code>함수도 반드시 작업에 성공하는 함수가 아니다.</li>
<li>디스크 섹터에 문제가 발생하여 파일 읽기에 실패하거나 실제 파일에 있는 데이터보다 더 많이 읽으라고 명령하면 작업에 실패할 수 있다.</li>
<li>예를 들어 실제 파일에는 데이터가 10바이트밖에 없는데 <code>fread</code>함수를 사용할 때 20바이트를 읽으라고 설정하면 읽기 작업에 실패한다.</li>
<li>따라서 <code>fread</code>함수의 반환값을 체크해 파일에서 데이터를 제대로 읽어 왔는지 확인하는게 좋다.</li>
<li>다음과 같이 <code>fread</code>함수는 작업에 성공하면 실제로 반복한 횟수만큼 반환하기 때문에 이 값을 확인하여 오류를 처리한다.</li>
</ul>
<pre><code class="language-c">if(5 == fread(&amp;data, sizeof(int), 5, p_file)) {
    // 읽기 성공
}
</code></pre>
</blockquote>
<h3 id="파일-내부의-작업-위치-탐색하고-확인하기-fseek-ftell-함수"><a class="header" href="#파일-내부의-작업-위치-탐색하고-확인하기-fseek-ftell-함수">파일 내부의 작업 위치 탐색하고 확인하기: fseek, ftell 함수</a></h3>
<ul>
<li>파일에 저장된 데이터를 꼭 순차적으로 읽을 필요는 없다.</li>
<li>필요에 따라 <code>fseek</code>함수를 사용하여 원하는 위치로 건너뛰거나, 읽은 위치로 돌아가서 읽었던 데이터를 다시 읽을 수도 있다.</li>
<li><code>fseek</code>함수는 다음과 같은 형식으로 호출한다.</li>
</ul>
<pre><code class="language-c">함수 원형: int fseek(FILE *stream, long offset, int origin);
함수 사용 형식: fseek(파일 포인터, 이동 거리, 기준 위치);
</code></pre>
<ul>
<li>이 함수는 파일의 데이터를 읽을 기준 위치로 <code>SEEK_SET</code>(파일의 시작), <code>SEEK_END</code>(파일의 끝), <code>SEEK_CUR</code>(현재 위치)를 사용할 수 있고 지정한 기준 위치로부터 사용자가 지정한 '이동
거리'만큼 이동한다.</li>
<li>이동 거리는 양수 또는 음수로 지정할 수 있으며 양수를 명시하면 지정한 기준 위치에서 뒤로 이동하며 음수를 명시하면 앞으로 이동한다.</li>
<li>그리고 실제로 이동한 위치는 파일 포인터에 저장된다.</li>
<li><code>fseek</code>함수를 사용하는 예시 코드는 다음과 같다.</li>
</ul>
<pre><code class="language-c">fseek(p_file, 0, SEEK_SET);  // 파일의 시작 위치로 이동함
</code></pre>
<pre><code class="language-c">fseek(p_file, 32, SEEK_CUR);  // 현재 위치에서 32바이트만큼 뒤로 이동함
</code></pre>
<ul>
<li>이렇게 이동한 위치를 값으로 확인하고 싶으면 <code>ftell</code>함수를 사용하면 된다.</li>
<li><code>ftell</code>함수가 반환하는 값은 시작 위치를 0으로 계산한 값이기 때문에 파일의 끝으로 이동한 후에 <code>ftell</code>함수를 사용하면 파일의 전체 크기를 알아낼 수도 있다.</li>
</ul>
<pre><code class="language-c">함수 원형: long ftell(FILE *stream);
함수 사용 형식: 현재 열려 있는 파일 내에서 데이터를 읽거나 저장할 위치 = ftell(파일 포인터);
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int file_size = 0;

    FILE *p_file = fopen(&quot;jerok.dat&quot;, &quot;rb&quot;);  // 읽기 모드로 바이너리 파일을 오픈함

    if (NULL != p_file) {  // 파일 열기에 성공한 경우 
        fseek(p_file, 0, SEEK_END);  // 파일의 끝을 이동함
        file_size = ftell(p_file);  // 현재 파일 위치로 파일의 크기를 구함
        printf(&quot;파일 크기: %d\n&quot;, file_size);
        fclose(p_file);  // 파일을 닫음
    }
}
</code></pre>
<pre><code class="language-text">파일 크기: 24
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_18.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter_20.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_18.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter_20.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
