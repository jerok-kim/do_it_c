<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>함수 - Study: Do it C 언어 입문</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html" class="active"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="5-함수"><a class="header" href="#5-함수">5. 함수</a></h1>
<h2 id="5-1-c-언어와-함수"><a class="header" href="#5-1-c-언어와-함수">5-1. C 언어와 함수</a></h2>
<h3 id="작업-단위로-명령을-표현하는-방법"><a class="header" href="#작업-단위로-명령을-표현하는-방법">작업 단위로 명령을 표현하는 방법</a></h3>
<ul>
<li>컴퓨터의 CPU는 단순화된 명령을 한 번에 하나씩 처리하도록 설계되어 있다.</li>
<li>프로그래밍 언어도 복잡한 표현법보다는 간단한 표현법을 나열하여 상황을 표현한다.</li>
<li>연속적인 행위들을 하나의 작업 단위로 묶어서 정의해 놓는다면 효율적이다.</li>
</ul>
<h3 id="함수란"><a class="header" href="#함수란">함수란?</a></h3>
<ul>
<li>C 언어 프로그램도 특별한 단위나 구분 없이 명령문들을 주욱 나열해서 작성하는 것보다 어떤 작업을 수행하는 일련의 명령문들을 한데 묶어서 그룹으로 만들어 두는 게 좋다.</li>
<li>작업별 그룹으로 나누어 작성한 소스 코드는 관리하기도 편할뿐더러 다른 프로그래머가 보거나 나중에라도 코드의 내용을 쉽게 이해할 수 있다.</li>
<li>C 언어는 소스 코드를 그룹화할 수 있도록 함수(Function)라는 문법을 제공한다.</li>
<li>C 언어는 소스 코드를 함수 단위로 나누어서 작성하는 것을 권장하기 때문에, 잘 작성한 C 언어 프로그램은 수많은 함수들로 이루어진 함수의 집합체라고 할 수 있다.</li>
</ul>
<h4 id="특별한-기능을-가진-main-함수"><a class="header" href="#특별한-기능을-가진-main-함수">특별한 기능을 가진 main 함수</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<ul>
<li>소스 코드를 번역하는 컴파일러 입장에서는 어떤 함수가 최초로 시작되는 함수인지를 알아야 제대로 된 번역을 할 수 있다.</li>
<li>C 언어는 <code>main</code>이라는 이름의 함수를 '프로그램 시작 함수'로 정해 놓았다.</li>
<li>즉 <code>main</code>함수는 '컴파일러에게 프로그램이 시작한다'고 알려주는 특별한 함수라고 생각하면 된다.</li>
</ul>
<h3 id="c-언어-프로그램은-함수의-집합체이다"><a class="header" href="#c-언어-프로그램은-함수의-집합체이다">C 언어 프로그램은 함수의 집합체이다</a></h3>
<ul>
<li>C 언어의 소스 파일에는 꼭 하나 이상의 함수가 있다.</li>
<li>C 언어로 작성한 프로그램은 함수들의 집합체이고 그 함수들끼리 서로 불러서 사용하는 형태로 진행된다.</li>
</ul>
<h2 id="5-2-함수-정의하고-호출하기"><a class="header" href="#5-2-함수-정의하고-호출하기">5-2. 함수 정의하고 호출하기</a></h2>
<h3 id="함수-정의하기"><a class="header" href="#함수-정의하기">함수 정의하기</a></h3>
<pre><code class="language-c">int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}
</code></pre>
<ul>
<li>함수의 이름은 Sum이며 int형 정수 값 두 개를 입력 받아서 int형 결과 값을 반환하는 함수이다.</li>
<li>함수 이름, 변수 이름은 모두 프로그래머가 임의로 지은 이름이고 나머지는 예약어이다.</li>
<li>이렇게 코드를 써서 함수를 실제로 구현하는 행위를 '함수를 정의한다'라고 한다.</li>
</ul>
<ol>
<li>함수 이름: 함수가 하는 일을 짐작하기 쉽게 짓는 것이 좋다.</li>
<li>매개변수: 함수가 작업을 수행할 때 필요한 데이터가 있다면 변수 단위로 명시한다.</li>
<li>작업 내용: 함수가 작업할 내용을 중괄호 {} 안에 명령문으로 나열한다.</li>
<li>반환값: 함수가 작업한 결과 값을 반환해야 할 때 사용한다(선택 사항).</li>
</ol>
<h3 id="함수-호출하기"><a class="header" href="#함수-호출하기">함수 호출하기</a></h3>
<ul>
<li>함수가 다른 함수를 사용하는 것을 '함수를 호출한다'고 한다.</li>
<li>즉 C 언어 프로그램은 함수가 다른 함수를 호출하면서 프로그램이 진행된다.</li>
<li>함수를 호출하는 함수를 호출자(Caller)라고 부르고 호출되는 함수를 피호출자(Callee)라고 한다.</li>
</ul>
<pre><code class="language-c">int Sum(int value1, int value2) {
    int result = value1 + value2;
    return value1 + value2;
}

void main() {
    int a = 2, b = 3, value;
    value = Sum(2, 3);
}
</code></pre>
<h4 id="함수-호출-과정-살펴보기"><a class="header" href="#함수-호출-과정-살펴보기">함수 호출 과정 살펴보기</a></h4>
<ol>
<li><code>main</code>함수가 <code>Sum</code>함수를 호출하면서 a와 b 값을 <code>Sum</code>함수에 전달한다.</li>
<li><code>Sum</code>함수의 매개변수에 <code>main</code>함수에서 전달 받은 값이 복사된다.</li>
<li>입력된 값으로 더하기 작업을 수행한다.</li>
<li><code>main</code>함수로 결과 값을 반환한다.</li>
</ol>
<h3 id="함수의-매개변수-자세히-살펴보기"><a class="header" href="#함수의-매개변수-자세히-살펴보기">함수의 매개변수 자세히 살펴보기</a></h3>
<ul>
<li>프로그램에서 사용하는 데이터는 필요할 때만 존재해야 효율적이므로 함수에서 필요할 때 만들었다가 함수가 끝날 때 함께 사라지도록 만드는 게 보통이다.</li>
<li>그래서 어떤 함수가 가지고 있던 데이터를 다른 함수에 전달하려면 다소 복잡한 표현법을 사용해야 한다.</li>
<li><code>main</code>함수는 <code>a</code>, <code>b</code>에 저장된 값을 더하기 위해 <code>Sum</code>함수를 호출하도록 구성했다.</li>
<li>그런데 함수 안에서 선언한 변수들은 해당 함수에서만 사용할 수 있기 때문에 <code>Sum</code>함수 내부에 선언된 <code>value1</code>, <code>value2</code>, <code>result</code>변수는 <code>Sum</code>함수에서만 사용할 수 있고, <code>main</code>함수 내부에 선언된 <code>a</code>, <code>b</code>변수는 <code>main</code>함수에서만 사용할 수 있다.</li>
<li>즉 <code>Sum</code>함수가 <code>a</code>, <code>b</code>를 직접 사용할 수 없기 때문에 <code>main</code>함수의 <code>a</code>, <code>b</code>변수 값을 <code>Sum</code>함수가 사용하기 위해 매개변수(Parameter)가 필요한 것이다.</li>
<li>매개변수는 호출자(<code>main</code>)에서 전달하는 값을 피호출자(<code>Sum</code>)에서 전달 받는 역할을 하는 변수를 의미하며 <code>Sum</code>함수의 <code>value1</code>과 <code>value2</code>가 여기에 해당한다.</li>
<li>이때 <code>main</code>에서 전달한 순서대로 <code>Sum</code>함수의 매개변수가 값을 전달 받기 때문에 순서와 개수를 잘 맞추어야 한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}

void main() {
    int s;
    s = Sum(2, 3);
    printf(&quot;더하기 작업의 결과는 %d \n&quot;, s);
}
</code></pre>
<ul>
<li><code>Sum</code>함수는 프로그램의 시작인 <code>main</code>함수보다 먼저 작성해야 한다.</li>
<li><code>main</code>함수 뒤에 작성하면 오류가 발생하는데, 이에 대한 자세한 내용은 [5-4]를 보자.</li>
<li><code>%d</code>는 정수를 출력할 때 사용하는 키워드이다.</li>
<li>이와 같이 출력을 위해 사용하는 여러 키워드들은 [6장]에서 배우자.</li>
<li>모든 함수가 매개변수를 가지는 것은 아니다.</li>
<li>특별히 호출자로부터 넘겨받을 정보가 없다면()안을 비워두거나 ()안에 <code>void</code>라고 적어 인자가 없음을 명시하면 된다.</li>
</ul>
<h3 id="함수의-반환값-자세히-살펴보기"><a class="header" href="#함수의-반환값-자세히-살펴보기">함수의 반환값 자세히 살펴보기</a></h3>
<h4 id="반환값이란"><a class="header" href="#반환값이란">반환값이란?</a></h4>
<ul>
<li><code>Sum</code>함수가 수행한 결과 값을 호출자로 넘겨주면 <code>Sum</code>함수의 역할은 끝이 난다.</li>
<li>함수에서 <code>return</code>이라는 예약어를 사용하면 함수는 그 위치에서 종결되며, <code>return</code>뒤에 명시된 <code>result</code>변수 값이 <code>Sum</code>함수의 반환값(Return Value)이 된다.</li>
<li>함수가 값을 반환한다는 뜻은 호출자의 어떤 변수에 값을 대입한다는 뜻이기도 하다.</li>
<li>따라서 변수를 선언할 때처럼 함수 이름 앞에 함수의 반환값에 대한 자료형을 명시해야 한다.</li>
</ul>
<blockquote>
<h4 id="함수의-반환값이-없는-경우도-있을까"><a class="header" href="#함수의-반환값이-없는-경우도-있을까">함수의 반환값이 없는 경우도 있을까?</a></h4>
<ul>
<li>모든 함수가 반환값을 가지는 것은 아니다.</li>
<li>[12장]이후에 배울 포인터나 배열 문법은 문법 자체에 값을 반환하는 기능을 가지고 있다.</li>
<li>따라서 <code>return</code>을 사용하여 결과 값을 반환할 필요가 없다.</li>
<li>반환할 값이 없으면 함수 이름 앞에 <code>void</code>를 적고 <code>return</code>을 사용하지 않으면 된다.</li>
</ul>
<pre><code class="language-c">void ZeroData(int *p) {
    *p = 0;  // 전달된 주소에 가서 0을 대입한다(의미적으로 0이 반환된 것).
}
</code></pre>
<ul>
<li><code>void</code>형식으로 정의한 함수의 <code>return</code>뒤에 반환값을 적으면 오류로 처리된다.</li>
</ul>
<pre><code class="language-c">void Test(int value1, int value2) {
    int result = value1 + value2;
    return result;  // 오류 발생
}
</code></pre>
</blockquote>
<h4 id="return의-또-다른-역할"><a class="header" href="#return의-또-다른-역할">return의 또 다른 역할</a></h4>
<ul>
<li><code>return</code>문은 값을 반환하는 기능 외에도 함수를 종료하는 기능도 가지고 있다.</li>
<li>따라서 단순히 함수를 종결할 목적으로 <code>return</code>을 사용할 때는 <code>return</code>뒤에 반환 값을 적지 않아도 오류가 발생하지 않는다.</li>
</ul>
<pre><code class="language-c">void Test(int value1, int value2) {
    int a = 5;
    return;  // Test 함수가 정상적으로 종료됨
    a = a + 1; // 오류는 아니지만 함수가 이미 종료되었기 때문에 실행되지 않음
}
</code></pre>
<ul>
<li><code>return</code>문을 두 번 적으면 오류가 발생하지는 않지만 두 번째 <code>return</code>문은 실행되지 않는다.</li>
</ul>
<h3 id="함수-이름을-짓는-방법"><a class="header" href="#함수-이름을-짓는-방법">함수 이름을 짓는 방법</a></h3>
<ul>
<li>C 언어로 작성한 소스 코드는 '함수의 집합체'이다.</li>
<li>따라서 이 함수들은 서로를 구별하고 사용할 수 있는 기준이 필요한데 그것이 함수 이름(Function Name)이다.</li>
<li>함수 이름을 짓는 법은 변수 이름 짓는 법과 똑같다.</li>
<li>영문자(a~z, A~Z), 숫자(0~9) 그리고 밑줄(_)을 조합하여 구성할 수 있다.</li>
<li>하지만 이름 전체를 숫자로 구성하거나 숫자로 시작하는 이름은 오류가 발생하기 때문에 함수 이름으로 사용할 수 없다.</li>
<li>공백을 포함할 수 없다.</li>
<li>대·소문자를 구별한다.</li>
<li>C 언어의 예약어는 함수 이름으로 사용할 수 없다.</li>
<li>한 프로그램에서 이름이 같은 함수가 두 개 이상 존재하는 경우에도 오류로 처리된다.</li>
</ul>
<blockquote>
<h4 id="프로그래밍에서-버그란-무엇일까"><a class="header" href="#프로그래밍에서-버그란-무엇일까">프로그래밍에서 버그란 무엇일까?</a></h4>
<ul>
<li>프로그래밍을 하다 보면 종종 오류가 발생한다.</li>
<li>이때 겪는 오류는 크게 두 가지인데 구문 오류(Syntax Error)와 의미상 오류(Semantic Error)가 있다.</li>
<li>구문 오류는 프로그래밍 언어가 제공하는 규칙을 제대로 지키지 않았을 때 발생한다.</li>
<li>이런 경우는 컴파일하기 전에 편집기에서 표시해 주거나, 컴파일할 때 컴파일러가 체크해 알려주기 때문에 찾기 쉽다.</li>
<li>반면에 의미상 오류는 '깡통이 맛있다'와 같은 문장처럼 문법적으로는 맞지만 의미적으로 틀릴 때 발생한다.</li>
<li>이런 오류는 정말 찾기 어렵다.</li>
<li>기계어로 번역할 때는 오류 없이 잘 번역되지만 프로그램을 실행하면 오류가 나서 중단되어 버리기 때문이다.</li>
<li>이러한 상황을 프로그래밍에서 '버그가 발생했다'고 한다.</li>
<li>프로그램에 버그가 발생하면 문법적으로는 문제가 없기 때문에 컴파일러가 오류 사항을 체크해주지 않는다.</li>
<li>따라서 프로그래머가 일일이 소스를 보면서 왜 잘못된 결과가 나오는지 체크해야 하는데, 이렇게 버그를 해결하기 위해 작업하는 행위를 디버깅(Debugging)이라고 한다.</li>
</ul>
</blockquote>
<h2 id="5-3-main-함수-정리하기"><a class="header" href="#5-3-main-함수-정리하기">5-3. main 함수 정리하기</a></h2>
<ul>
<li>한 개의 프로그램에서 <code>main</code>함수는 반드시 한 개만 있어야 한다.</li>
<li><code>main</code>함수가 없거나 두 개 이상 존재하면 컴파일할 때 오류가 발생한다.</li>
<li><code>main</code>함수는 반환형이나 매개변수를 사용자가 별도로 정할 수 없다.</li>
<li>그 대신 몇 가지 정해진 형식을 사용할 수 있도록 되어 있다.</li>
</ul>
<h3 id="main-함수의-반환값"><a class="header" href="#main-함수의-반환값">main 함수의 반환값</a></h3>
<ul>
<li>사용자가 직접 프로그램을 실행시키는 경우도 있지만 특정 프로그램이 다른 프로그램을 실행시키는 경우도 있다.</li>
<li>만약 A라는 프로그램이 B라는 프로그램을 실행시켰다고 생각해보자.</li>
<li>A프로그램 입장에서는 자신이 실행시킨 B프로그램이 정상적으로 작업을 완료했는지, 어떤 상태로 종료했는지 등을 확인해야 할 때가 있다.</li>
<li>이때 B프로그램이 A프로그램에게 자신의 상태 값을 알려주는 방법이 여러 가지 있는데, 그 중 하나가 <code>main</code>함수의 반환값이다.</li>
</ul>
<h4 id="int형으로-반환하기"><a class="header" href="#int형으로-반환하기">int형으로 반환하기</a></h4>
<ul>
<li>프로그램의 상태를 알려주기 위해 <code>main</code>함수의 반환값으로 <code>int</code>형을 사용한다.</li>
</ul>
<pre><code class="language-c">int main() {
    return 1;  // 값 1을 반환함
}
</code></pre>
<ul>
<li>예시에서 <code>return 1;</code>라고 한 것은 1이 참을 의미하므로 프로그램이 성공적으로 실행되었다는 것을 보여주기 위함이다.</li>
<li><code>main</code>함수의 반환값은 0, 1뿐만 아니라 어떤 값을 사용해도 상관없다.</li>
</ul>
<h4 id="void형으로-반환하기"><a class="header" href="#void형으로-반환하기">void형으로 반환하기</a></h4>
<ul>
<li>프로그램에 특별히 반환할 내용이 없다면 <code>void</code>를 사용하면 된다.</li>
</ul>
<pre><code class="language-c">void main() {
    // 반환값 없음
}
</code></pre>
<h3 id="main함수의-매개변수"><a class="header" href="#main함수의-매개변수">main함수의 매개변수</a></h3>
<ul>
<li>명령 프롬프트로 프로그램을 실행할 때, 실행 인자(Argument)를 적을 수 있다.</li>
<li>실행 인자는 공백으로 구분한다.</li>
<li>실행 인자는 프로그램이 시작할 때 넘겨 받는 정보를 말한다.</li>
<li>실행 인자 또한 프로그램 입장에서는 변수로 받기 때문에 <code>main</code>함수의 매개변수가 받는다.</li>
</ul>
<pre><code class="language-c">void main(int argc, char *argv[]) {
    // argc에는 실행 인자의 개수, argv에는 실행 인자값이 들어감
}
</code></pre>
<ul>
<li><code>*argv[]</code>는 포인터형 배열인데, 이것은 뒤에서 포인터와 배열을 배워야 이해할 수 있다.</li>
<li>포인터가 n개 있다는 것을 의미하는 문법이다.</li>
<li>사용자가 실행 인자를 사용하든 사용하지 않든 프로그램에서 실행 인자를 받을 필요가 없다면 매개변수 없이 <code>main()</code>이라고 명시하거나, <code>void</code>를 사용하여 <code>main(void)</code>와 같이 매개변수가 없음을 확실히 명시하면 된다.</li>
</ul>
<h2 id="5-4-함수-원형-선언하기"><a class="header" href="#5-4-함수-원형-선언하기">5-4. 함수 원형 선언하기</a></h2>
<h3 id="함수를-호출할-때-기억해야-할-것"><a class="header" href="#함수를-호출할-때-기억해야-할-것">함수를 호출할 때 기억해야 할 것</a></h3>
<ul>
<li>컴파일러는 C 언어 소스 코드를 기계어로 번역할 때, 코드의 위쪽에서 아래쪽으로 내용을 읽으며 번역한다.</li>
<li>따라서 피호출자가 호출자의 위쪽에 있는 경우에는 번역에 문제가 생기지 않는다.</li>
<li>왜냐하면 컴파일러가 호출자에서 피호출자를 호출하는 명령을 기계어로 번역할 때 피호출자가 어떤 형태의 매개변수를 원하는지, 작업 후에 결과 값을 어떻게 반환하는지를 이미 읽어서 알고 있기 때문이다.</li>
<li>하지만 호출자가 피호출자보다 위에 놓이는 경우에는 피호출자를 호출하는 명령을 번역하는 시점에 아직 컴파일러는 피호출자를 본 적이 없어서 호출 작업과 관련된 코드를 구성할 수 없기 때문이다.</li>
</ul>
<h3 id="함수-원형이란"><a class="header" href="#함수-원형이란">함수 원형이란?</a></h3>
<ul>
<li>프로그래밍을 하다 보면 두 함수가 서로를 호출하는 경우도 생긴다.</li>
<li>따라서 피호출자가 항상 호출자의 위쪽에 놓일 수는 없다.</li>
<li>이런 경우에 함수 원형(Function Prototype)을 사용해서 해결한다.</li>
<li>함수의 원형은 함수가 호출될 때 필요한 정보인 함수 이름, 매개변수, 반환 자료형을 포함하는 표현식이다.</li>
</ul>
<pre><code class="language-c">int Sum(int value1, int value2);  // 함수 원형 선언

void main() {
    int s;
    s = Sum(2, 3);
}

int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}
</code></pre>
<ul>
<li>함수 원형을 미리 선언해 두면 이 프로그램의 소스 파일 어딘가에 해당 형식을 가진 함수가 존재한다는 것을 컴파일러가 인지하게 된다.</li>
<li>따라서 컴파일러는 함수의 원형을 참조하여 <code>main</code>함수에서 <code>Sum</code>함수를 호출하는 구조를 만들 수 있다.</li>
</ul>
<blockquote>
<h4 id="함수-원형을-선언할-때-매개변수-이름을-생략할-수-있다"><a class="header" href="#함수-원형을-선언할-때-매개변수-이름을-생략할-수-있다">함수 원형을 선언할 때 매개변수 이름을 생략할 수 있다.</a></h4>
<ul>
<li>함수의 호출 구조를 만들 때 매개변수 정보는 개수나 자료형만 사용하기 때문에 함수 원형을 적을 때 매개변수 이름을 생략해도 된다.</li>
<li>하지만 오류가 발생하지 않는다고 해도 코드의 가독성을 위해 매개변수 이름은 생략하지 않는 것이 좋다.</li>
</ul>
</blockquote>
<ul>
<li>함수를 '정의'하는 것과 '선언'하는 것을 헷갈리지 말자.</li>
<li>함수를 정의한다는 것은 실제로 함수를 만드는, 함수를 구현하는 행위를 의미한다.</li>
<li>함수를 선언한다는 뜻은 좀 더 명확히 이야기하면 '함수의 원형을 선언한다'는 뜻과 같다.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_04.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter_06.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_04.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter_06.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
