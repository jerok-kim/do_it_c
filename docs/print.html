<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Study: Do it C 언어 입문</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="이-작업을-왜-하는가"><a class="header" href="#이-작업을-왜-하는가">이 작업을 왜 하는가?</a></h2>
<ul>
<li>C 언어의 기본적인 문법을 공부하고 정리하기 위한 글입니다.</li>
<li>다른 프로그래밍 언어보다 조금 더 low-level에 가까운 C 언어에 대해 공부해보고 싶었고,</li>
<li>'포인터', '메모리 할당', '구조체' 등의 주제에 대해 궁금했습니다.</li>
<li>'Do it C 언어 입문'라는 책의 내용을 위주로 정리 하였습니다.</li>
</ul>
<h2 id="방향과-계획"><a class="header" href="#방향과-계획">방향과 계획</a></h2>
<ul>
<li>이 작업은 'C'라는 주제의 첫 시작입니다.</li>
<li>1: &quot;Do it C&quot;라는 책의 내용을 정리하면서 기본적인 내용을 학습해 보고자 합니다.</li>
<li>2: &quot;C 기초 플러스&quot;를 통해 많이 연습해보려고 합니다.</li>
<li>3: &quot;전문가를 위한 C&quot;(Extreme C by Kamran Amini 의 번역서)를 통해 좀 더 'C'에 대해 이해해 보고 다음 주제로 넘어가고자 합니다.</li>
<li>4: 컴퓨터 구조, 운영체제에 관한 주제와, 개인적으로 가장 관심있는 주제인 'Rust'로 넘어갈 계획입니다.</li>
</ul>
<h2 id="저장소"><a class="header" href="#저장소">저장소</a></h2>
<ul>
<li>Github Repository에 모든 md파일, 작성해본 예제 파일, 빌드 파일들을 저장해 놓았습니다.</li>
<li>https://github.com/jerok-kim/do_it_c</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-프로그램과-c-언어"><a class="header" href="#1-프로그램과-c-언어">1. 프로그램과 C 언어</a></h1>
<h2 id="1-1-프로그래밍-기초"><a class="header" href="#1-1-프로그래밍-기초">1-1. 프로그래밍 기초</a></h2>
<h3 id="프로그램이란"><a class="header" href="#프로그램이란">프로그램이란?</a></h3>
<ul>
<li>어떤 목적을 이룰 수 있도록 프로그래밍 언어로 진행 순서를 기술한 것을 프로그램이라고 한다.</li>
<li>프로그램은 보통 확장자가 .exe인 파일을 의미한다.</li>
<li>이 파일을 실행 파일이라고 하며, 컴퓨터가 작업할 내용이 컴퓨터가 이해할 수 있는 언어(기계어)로 작성되었다.</li>
</ul>
<h3 id="프로그래밍-언어란"><a class="header" href="#프로그래밍-언어란">프로그래밍 언어란?</a></h3>
<ul>
<li>컴퓨터는 2진수(0과 1)로 이루어진 기계어를 사용한다.</li>
<li>기계어는 2진수로 이루어져 있으며, 컴퓨터의 CPU가 직접 사용할 수 있는 형태의 명령문이다.</li>
<li>사람들이 사용하기 편한 언어로 작성한 작업 내용을 컴파일러(Compiler)가 기계어로 번역한다.</li>
</ul>
<h2 id="1-2-c-언어-소개"><a class="header" href="#1-2-c-언어-소개">1-2. C 언어 소개</a></h2>
<h3 id="c-언어의-탄생"><a class="header" href="#c-언어의-탄생">C 언어의 탄생</a></h3>
<ul>
<li>1960년대에 개발되었던 운영체제들은 하드웨어 종속적인 언어를 사용하여 개발되었다.</li>
<li>따라서 하드웨어가 바뀌면 운영체제의 많은 부분을 다시 개발해야 했다.</li>
<li>켄 톰슨(Ken Thompson)과 데니스 리치(Dennis Ritchie)는 하드웨어로부터 독립된 운영체제를 만드는데 적합한 언어를 개발하는데 이것이 C 언어이다.</li>
<li>C 언어는 하드웨어의 세밀한 부분까지 제어할 수 있다.</li>
<li>그리고 특정 하드웨어를 직접 표현하지 않도록 문법을 구성하였기 때문에 하드웨어에 독립된 형태로 프로그램을 개발할 수 있다.</li>
<li>C 언어는 유닉스(UNIX) 운영체제를 만드는 데 사용한 프로그래밍 언어이다.</li>
</ul>
<h3 id="c-언어의-특징-4가지"><a class="header" href="#c-언어의-특징-4가지">C 언어의 특징 4가지</a></h3>
<ul>
<li>구조화된 언어, 이식성, 확장성, 생산성</li>
</ul>
<h4 id="c-언어는-구조화된-언어이다"><a class="header" href="#c-언어는-구조화된-언어이다">C 언어는 구조화된 언어이다</a></h4>
<ul>
<li>C 언어는 일정한 단위로 명령들을 그룹으로 묶는 방법을 제공한다.</li>
<li>C 언어로 만든 프로그램은 작업 단위가 명확하게 구분되어 유지 보수가 편리하고 기존 프로그램에서 자신이 원하는 작업을 분리하기도 쉬워서 새로운 프로그램을 개발할 때 재사용하기에도 좋다.</li>
</ul>
<h4 id="c-언어는-이식성이-높다"><a class="header" href="#c-언어는-이식성이-높다">C 언어는 이식성이 높다</a></h4>
<ul>
<li>C 언어이 이식성(Portability)이 높다는 말은 C 언어로 만든 프로그램을 거의 수정하지 않고 다른 하드웨어 또는 운영체제로 가져갔을 때도 잘 동작한다는 뜻이다.</li>
<li>이를 위해 하드웨어에 종속적일 수 있는 부분은 C 언어에서 분리해 런타임 라이브러리(Runtime Library)라는 개념으로 제공한다.</li>
<li>이 런타임 라이브러리는 각 하드웨어 또는 운영체제별로 만들어졌기 때문에 사용자가 작성한 C 언어 프로그램에는 영향을 미치지 않는다.</li>
<li>즉 하드웨어에 변화가 생기더라도 C 언어 문법이 영향을 받지 않도록 C 언어를 디자인 한 것이다.</li>
</ul>
<h4 id="c-언어는-확장성이-좋고-표현법이-다양해서-자기만의-표현법을-개발할-수-있다"><a class="header" href="#c-언어는-확장성이-좋고-표현법이-다양해서-자기만의-표현법을-개발할-수-있다">C 언어는 확장성이 좋고, 표현법이 다양해서 자기만의 표현법을 개발할 수 있다</a></h4>
<ul>
<li>C 언어는 사용할 확률이 높은 문법만 최소한으로 유지하고 사용 빈도가 낮은 문법은 사용자들이 스스로 구현하기 때문에 언어의 기능을 확장할 수 있다.</li>
<li>따라서 C 언어는 다른 언어에 비해 표현법이 더 많고, 개발자가 개발 상황에 따라 선택할 수 있는 문법 구조나 표현법이 다양하여 자율성이 높다.</li>
</ul>
<h4 id="c-언어는-생산성이-높다"><a class="header" href="#c-언어는-생산성이-높다">C 언어는 생산성이 높다</a></h4>
<ul>
<li>C 언어를 사용하는 프로그래머들은 스스로 개발 인프라(명령 그룹, 함수 등)를 구축하기 때문에 경력이 쌓일수록 인프라가 다양해져서 프로그램 개발 속도가 빨라진다.</li>
<li>그 뿐만 아니라 사용자의 여러 가지 요구에 대해 스스로 대처할 수 있어서 프로그램의 완성도와 만족도가 더 높을 수 밖에 없다.</li>
</ul>
<h2 id="1-3-전자계산기-원리와-프로그래밍-개념"><a class="header" href="#1-3-전자계산기-원리와-프로그래밍-개념">1-3. 전자계산기 원리와 프로그래밍 개념</a></h2>
<ul>
<li>모든 프로그래밍 언어는 비슷한 요소를 가지고 있다.</li>
</ul>
<h3 id="입력-버튼"><a class="header" href="#입력-버튼">입력 버튼</a></h3>
<ul>
<li>대부분의 프로그래밍 언어는 입력문을 가지고 있다.</li>
<li>ex) 키보드, 마우스</li>
<li>C 언어는 다음과 같이 표준 입력 및 콘솔 입력 방식으로 이 두 장치를 제어한다.</li>
</ul>
<pre><code>scanf, getc, getch, gets, ⋯
</code></pre>
<h3 id="lcd-출력"><a class="header" href="#lcd-출력">LCD 출력</a></h3>
<ul>
<li>대부분의 프로그래밍 언어는 출력문을 가지고 있다.</li>
<li>컴퓨터는 주로 모니터를 통해 정보를 출력하며, C 언어는 표준 출력·콘솔 출력 이라는 두 가지 형태의 출력 방식이 있다.</li>
</ul>
<pre><code>printf, putc, puts, ⋯
</code></pre>
<h3 id="상수"><a class="header" href="#상수">상수</a></h3>
<ul>
<li>숫자와 기호, 문자 등 한정된 입력 대상을 상수라고 한다.</li>
<li>프로그래밍 언어에서는 숫자 상수, 문자 상수, 문자열 상수로 나누어 표현한다.</li>
</ul>
<pre><code>1, 2, 3, 'a', 'b', &quot;abc&quot;, ⋯
</code></pre>
<h3 id="연산자"><a class="header" href="#연산자">연산자</a></h3>
<ul>
<li>덧셈, 뺄셈, 나눗셈과 같은 연산 기능이 있다.</li>
<li>모든 프로그래밍 언어는 연산 기능을 수행할 수 있는 연산자를 가지고 있다.</li>
</ul>
<pre><code>+, -, *, /, %, ⋯
</code></pre>
<h3 id="변수"><a class="header" href="#변수">변수</a></h3>
<ul>
<li>계산기나 컴퓨터는 연산 과정에서 사용자가 입력한 값을 기억하고 연산 결과로 나온 값도 기억해야 하기 때문에 기억 공간이 필요하다.</li>
<li>이 기억 공간을 변수라고 한다.</li>
</ul>
<pre><code>int sum; double money; char type; ⋯
</code></pre>
<h3 id="조건문"><a class="header" href="#조건문">조건문</a></h3>
<ul>
<li>사용자가 어떤 연산자를 선택하는지에 따라 다른 작업을 수행하도록 표현하는 문법을 프로그래밍 언어에서는 조건문이라고 한다.</li>
</ul>
<pre><code>if, switch, ⋯
</code></pre>
<h3 id="반복문"><a class="header" href="#반복문">반복문</a></h3>
<ul>
<li>계산기는 계산 작업을 반복해서 수행하도록 만들어졌다.</li>
<li>프로그래밍 언어도 사용자가 원하는 작업을 반복해서 수행할 수 있도록 반복문을 제공한다.</li>
</ul>
<pre><code>for, while, do ~ while, ⋯
</code></pre>
<blockquote>
<h4 id="고급스러운-언어-저급한-언어"><a class="header" href="#고급스러운-언어-저급한-언어">고급스러운 언어, 저급한 언어?</a></h4>
<ul>
<li>프로그래밍 언어의 표현법이 사람들이 쓰는 언어와 비슷할수록 고급(High-level) 언어이고 컴퓨터의 기계어와 비슷할수록 저급(Low-level) 언어이다.</li>
<li>고급 언어를 대표하는 것으로 Java나 C#과 같은 프로그래밍 언어가 있고,</li>
<li>저급 언어를 대표하는 것은 기계어나 어셈블리어가 있다.</li>
<li>C 언어는 고급 언어이지만, 양쪽의 특성을 모두 가지고 있기 때문에 중간(Middle-level) 언어로도 볼 수 있다.</li>
</ul>
</blockquote>
<h2 id="1-4-c-언어-서술-형식"><a class="header" href="#1-4-c-언어-서술-형식">1-4 C 언어 서술 형식</a></h2>
<ul>
<li>사용자는 번역기가 제공하는 프로그래밍 언어의 문법에 맞게 프로그램을 작성해야 한다.</li>
<li>프로그래밍 언어가 요구하는 문법을 나열하는 것을 서술(Statement) 형식이라고 한다.</li>
</ul>
<h3 id="c-언어의-기본-서술-형식"><a class="header" href="#c-언어의-기본-서술-형식">C 언어의 기본 서술 형식</a></h3>
<ul>
<li>C 언어가 문장을 서술하는 기본 형식은 단일 서술문과 복합 서술문이다.</li>
</ul>
<h4 id="단일-서술문"><a class="header" href="#단일-서술문">단일 서술문</a></h4>
<ul>
<li>단일 서술문(Single Statement)은 논리적인 최소 명령 실행 단위이다.</li>
<li>즉 한 개의 서술문 단위로 작업이 진행된다.</li>
<li>C 언어는 ;(세미콜론)으로 문장을 구분하기 때문에 한 줄에 여러 개의 서술문을 쓸 수도 있다.</li>
</ul>
<pre><code class="language-c">a = a + 30;  // 한 줄로 이루어진 단일 서술문

a = a
   + 30;  // 두 줄로 이루어진 단일 서술문

a = a + 30; b = b + 50;  // 한 줄에 두 개의 단일 서술문을 사용
</code></pre>
<h4 id="복합-서술문"><a class="header" href="#복합-서술문">복합 서술문</a></h4>
<ul>
<li>복합 서술문(Compound Statement)은 여러 단일 서술문을 {} 중괄호를 사용해 하나로 묶은 형태이다.</li>
<li>중괄호 안의 단일 서술문이 모두 수행되면 이 복합 서술문이 수행된 것으로 처리된다.</li>
<li>다음과 같이 적으면 단일 서술문 2개를 사용한 것이 아니라 복합 서술문 1개를 사용한 것이다.</li>
</ul>
<pre><code class="language-c">{
    a = a + 30;
    b = b + 50;
}
</code></pre>
<ul>
<li>복합 서술문은 {} 중괄호를 사용하기 때문에 자신의 영역이 구분된다.</li>
<li>따라서 ;(세미콜론)을 사용할 필요가 없다.</li>
</ul>
<h3 id="역할에-따른-서술-형식"><a class="header" href="#역할에-따른-서술-형식">역할에 따른 서술 형식</a></h3>
<h4 id="수식-서술문"><a class="header" href="#수식-서술문">수식 서술문</a></h4>
<ul>
<li>수식 서술문(Expression Statement)은 계산 수식을 표현한 단일 서술문이다.</li>
</ul>
<pre><code class="language-c">average = (a + b) / 2;
</code></pre>
<h4 id="조건-서술문"><a class="header" href="#조건-서술문">조건 서술문</a></h4>
<ul>
<li>조건 서술문(Selection Statement)은 조건을 만족하면 지정한 서술문을 수행하도록 작성한 서술문이다.</li>
</ul>
<pre><code class="language-c">if(a &gt; 5) a = 0;
</code></pre>
<h4 id="반복-서술문"><a class="header" href="#반복-서술문">반복 서술문</a></h4>
<ul>
<li>반복 서술문(Iteration Statement)은 단일 서술문 또는 복합 서술문을 반복하여 수행하도록 작성한 서술문이다.</li>
</ul>
<pre><code class="language-c">int sum = 0, i;
for(i = 0; i &lt; 5; i++) sum = sum + i;
</code></pre>
<h4 id="라벨-서술문"><a class="header" href="#라벨-서술문">라벨 서술문</a></h4>
<ul>
<li>라벨 서술문(Labeled Statement)은 소스 파일의 특정 위치에 라벨을 지정하고 goto 문을 사용해 그 위치로 이동할 수 있도록 작성한 서술문이다.</li>
<li>원칙 없이 프로그래머가 원하는 위치로 실행 지점을 이동하는 것은 구조화된 언어인 C 언어의 소스 코드 구성을 파괴할 수 있는 문법이기 때문에 되도록 사용하지 않는 것이 좋다.</li>
</ul>
<pre><code class="language-c">if(a &lt; 0) goto EXIT;
a = a - 1;
EXIT :
</code></pre>
<h4 id="분기-서술문"><a class="header" href="#분기-서술문">분기 서술문</a></h4>
<ul>
<li>분기 서술문(Jump Statement)은 자신이 소속된 서술문을 벗어나거나 흐름을 바꾸어 놓을 때 사용한다.</li>
<li><code>break</code>, <code>continue</code>와 같은 문법들이 분기 서술문에 해당하는데 <code>return</code>문, <code>goto</code>문 처럼 실행 흐름을 마음대로 조정(서술문의 범위를 마음대로 벗어날 수 있음)하는 것이 아니라 특정 조건 서술문이나 반복 서술문 안에서만 적용되기 때문에 잘 활용하는 것이 좋다.</li>
</ul>
<h4 id="주석문"><a class="header" href="#주석문">주석문</a></h4>
<ul>
<li>상황을 설명하거나 작업 내용을 기억하기 위해 소스 파일에 메모를 남겨야 하는 경우에 주석문(Comment)을 사용한다.</li>
<li>주석문은 /* 기호로 시작해서 */ 기호로 끝나고, 여러 줄에 걸쳐서 사용할 수 있다.</li>
<li>// 를 사용하여 한줄 주석문을 사용할 수 있다.</li>
</ul>
<h3 id="예약어"><a class="header" href="#예약어">예약어</a></h3>
<ul>
<li>프로그래밍 언어의 문법에 사용되는 단어들을 예약어(Reserved Word)라고 한다.</li>
<li>예약어는 의미나 역할이 정해져 있기 때문에 그 뜻을 바꾸거나 다른 용도로 사용할 수 없다.</li>
</ul>
<h2 id="1-5-c-프로그램-실행-파일"><a class="header" href="#1-5-c-프로그램-실행-파일">1-5. C 프로그램 실행 파일</a></h2>
<p><img src="./images/program_diagram.png" alt="프로그램 생성 과정" /></p>
<h3 id="소스-파일c"><a class="header" href="#소스-파일c">소스 파일(*.c)</a></h3>
<ul>
<li>소스 파일(Source File)은 프로그래머가 만들고 싶은 프로그램을 C 언어 문법을 사용해서 작성한 파일을 말한다.</li>
<li>소스 파일은 텍스트 형식의 파일이며 파일 확장자는 .c를 사용한다.</li>
</ul>
<h3 id="목적-파일obj"><a class="header" href="#목적-파일obj">목적 파일(*.obj)</a></h3>
<ul>
<li>목적 파일(Object File)은 컴파일러(번역기)가 소스 파일을 번역(컴파일)하면 만들어지는 파일이다.</li>
<li>컴파일러가 실행 파일 만드는 시간을 줄이기 위해 만드는 파일이기도 하다.</li>
<li>목적 파일은 컴파일러가 만들어 주기 때문에 사용자가 직접 만들 필요는 없다.</li>
<li>왜 중간에 목적 파일을 만들어 두었을까?
<ul>
<li>소스 파일을 번역해서 바로 실행 파일을 만들면, 소스 파일의 일부만 바뀌어도 소스 파일 전체를 다시 번역해서 실행 파일을 만들어야 하기 때문에 비효율적이다.</li>
<li>그래서 내용이 많은 소스 파일에서 비슷한 작업들을 모아서 여러 개의 파일로 나누고 각각의 파일을 컴파일하는 방식을 사용한다.</li>
<li>여기에서 소스 파일을 나누는 것은 C 언어의 작업이 아니라 개발자가 판단하여 진행하는 일이다.</li>
<li>큰 프로그램을 기능별로 적절하게 나누어 컴파일하자.</li>
</ul>
</li>
</ul>
<h3 id="소스-파일을-나누는-이유"><a class="header" href="#소스-파일을-나누는-이유">소스 파일을 나누는 이유</a></h3>
<ul>
<li>C 언어 컴파일러는 컴파일을 할 때 먼저 소스 파일의 내용이 변경되었는지 체크한 후 변경되었으면 다시 컴파일하여 목적 파일을 만들고, 변경되지 않았다면 이전에 만든 목적 파일을 재사용한다.</li>
<li>따라서 소스 파일이 여러 개로 나누어져 있을 때 소스 파일의 일부가 바뀌었다면, 변경된 소스 파일만 컴파일되어 새로운 목적 파일이 만들어지고 나머지 소스 파일들은 이전에 만들었던 목적 파일을 그대로 재사용하기 때문에 컴파일 시간이 줄어드는 효과가 있다.</li>
</ul>
<h3 id="실행-파일exe"><a class="header" href="#실행-파일exe">실행 파일(*.exe)</a></h3>
<ul>
<li>실행 파일(Executable File)은 컴퓨터에서 실행할 수 있는 파일을 말한다.</li>
<li>하나 이상의 목적 파일을 연결자(Linker)가 연결(Link)해서 실행 파일을 만든다.</li>
<li>이렇게 만들어진 실행 파일은 기계어로 나열된 프로그램 파일로서 더 이상의 컴파일 작업 없이 컴퓨터에서 바로 실행할 수 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-c언어로-만드는-첫-번째-프로그램"><a class="header" href="#2-c언어로-만드는-첫-번째-프로그램">2. C언어로 만드는 첫 번째 프로그램</a></h1>
<h2 id="2-1-c-언어-개발-환경-구축하기"><a class="header" href="#2-1-c-언어-개발-환경-구축하기">2-1. C 언어 개발 환경 구축하기</a></h2>
<ul>
<li>이 부분은 책과는 다르게 개발 환경을 구축하였다.</li>
<li>Jetbrains의 Clion IDE를 사용하였다.</li>
<li>C99, C23 버전을 사용해 보았다.</li>
</ul>
<h2 id="2-3-내가-만든-첫-번째-프로그램"><a class="header" href="#2-3-내가-만든-첫-번째-프로그램">2-3. 내가 만든 첫 번째 프로그램</a></h2>
<pre><code class="language-c">/* 첫 번째 프로그램 */
#include &lt;stdio.h&gt;

void main(void) {
    printf(&quot;Hello world!&quot;);
}
</code></pre>
<h4 id="include-stdioh"><a class="header" href="#include-stdioh">#include &lt;stdio.h&gt;</a></h4>
<ul>
<li>C 언어에서는 #으로 시작하는 문장을 전처리기라고 부른다.</li>
<li>전처리기(Preprocessor)는 '미리, 사전'에 처리한다는 뜻이다.</li>
<li>여기에서는 컴파일러에게 이 예제 소스 코드를 번역하기 위해 <code>stdio.h</code> 파일을 먼저 참조하라고 지시하는 것이다.</li>
<li><code>stdio.h</code>파일을 참조하라고 지시한 이유는 <code>main</code>함수에서 사용한 <code>printf</code>함수를 사용하기 위한 정보가 <code>stdio.h</code>파일에 기록되어 있기 때문이다.</li>
</ul>
<h4 id="main"><a class="header" href="#main">main</a></h4>
<ul>
<li>C 언어는 명령들을 일정한 작업 단위로 묶어서 코드를 작성하기 위해 함수(Function)라는 문법을 제공한다.</li>
<li>C 언어 프로그램은 사용자가 만든 함수의 집합체로 구성되는데, 프로그램의 시작을 나타내려면 main 함수를 반드시 정의해야 한다.</li>
</ul>
<h4 id="void"><a class="header" href="#void">void</a></h4>
<ul>
<li>'정해지지 않았다'는 의미의 예약어(Reserved Word)이다.</li>
<li><code>main</code>앞에 있는 <code>void</code>는 '함수의 수행 결과 값이 정해지지 않았다'라는 뜻이고 <code>main</code>뒤 ()괄호 안에 있는 <code>void</code>는 '<code>main</code>함수로 전달되는 정보가 정해지지 않았다'라는 뜻이다.</li>
</ul>
<h4 id="printfhello-world"><a class="header" href="#printfhello-world">printf(&quot;Hello world!&quot;);</a></h4>
<ul>
<li><code>printf</code>는 C 언어이 표준 출력 함수로, 모니터 등의 콘솔(Console)화면에 'Hello world!'라고 출력한다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-자료형"><a class="header" href="#3-자료형">3. 자료형</a></h1>
<h2 id="3-1-컴퓨터의-자료-기억-방식"><a class="header" href="#3-1-컴퓨터의-자료-기억-방식">3-1. 컴퓨터의 자료 기억 방식</a></h2>
<h3 id="데이터정보를-저장하는-공간-메모리"><a class="header" href="#데이터정보를-저장하는-공간-메모리">데이터(정보)를 저장하는 공간, 메모리</a></h3>
<ul>
<li>컴퓨터는 주기억 장치로 램(RAM, Random Access Memory)를 사용하기 때문에 보통 메모리라고 하면 램을 의미한다.</li>
<li>메모리는 1바이트(Byte) 단위로 주소가 매겨져 있으며 운영체제마다 주소를 관리하는 방법이 조금씩 다르다.</li>
<li>하지만 주소가 1바이트 단위로 부여되어 있다고 해서 데이터가 꼭 1바이트 단위로 저장되어야 하는 것은 아니다.</li>
<li>1바이트 단위는 운영체제가 메모리를 관리하는 단위이고, 컴퓨터는 이보다 더 작은 비트 단위로 정보를 저장하거나 읽을 수 있다.</li>
</ul>
<h4 id="1비트는-0-또는-1을-저장할-수-있는-공간이다"><a class="header" href="#1비트는-0-또는-1을-저장할-수-있는-공간이다">1비트는 0 또는 1을 저장할 수 있는 공간이다</a></h4>
<ul>
<li>메모리의 최소 저장 단위는 비트(Bit)이다.</li>
<li>1비트는 0, 1 중에서 한 개를 저장할 수 있는 크기이다.</li>
</ul>
<h4 id="저장-단위가-1비트-증가할-때마다-저장-단위는-2배로-늘어난다"><a class="header" href="#저장-단위가-1비트-증가할-때마다-저장-단위는-2배로-늘어난다">저장 단위가 1비트 증가할 때마다 저장 단위는 2배로 늘어난다</a></h4>
<ul>
<li>1비트는 숫자 2개(0~1)중 하나,</li>
<li>2비트는 숫자 4개(0~3)중 하나,</li>
<li>3비트는 숫자 8개(0~7)중 하나를 저장할 수 있는 크기이다.</li>
<li>즉 1비트 증가할 때마다 저장 단위가 2의 배수만큼 늘어난다.</li>
<li>비트가 8개 모이면 새로운 단위를 사용하며 이것을 바이트(Byte)라고 한다.</li>
<li>1바이트는 비트 8개로 이루어지기 때문에 숫자 256개(0~255)중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<blockquote>
<h4 id="메모리-단위를-더-자세하게-알아보자"><a class="header" href="#메모리-단위를-더-자세하게-알아보자">메모리 단위를 더 자세하게 알아보자</a></h4>
<ul>
<li>메모리 단위를 작은 것에서 큰 순서로 정리해 보면 다음과 같다.</li>
<li>1,024Byte = 1KB(킬로바이트, Kilo Byte)</li>
<li>1,024KB = 1MB(메가바이트, Mega Byte)</li>
<li>1,024MB = 1GB(기가바이트, Giga Byte)</li>
<li>1,024GB = 1TB(테라바이트, Tera Byte)</li>
<li>1,024TB = 1PB(페타바이트, Peta Byte)</li>
<li>1,024PB = 1EB(엑사바이트, Exa Byte)</li>
</ul>
</blockquote>
<h4 id="부호-비트를-사용하여-양수와-음수를-구별한다"><a class="header" href="#부호-비트를-사용하여-양수와-음수를-구별한다">부호 비트를 사용하여 양수와 음수를 구별한다</a></h4>
<ul>
<li>숫자는 음수도 있기 때문에 데이터에 음수가 들어 있다면 메모리에 데이터를 저장할 때 조금 다른 표현을 사용해야 한다.</li>
<li>1바이트를 기준으로 살펴보면 비트 9개에 모두 숫자를 저장하는 것이 아니라 비트 1개에는 음수 또는 양수인지의 상태를 저장하고 나머지 비트 7개에는 숫자를 저장한다.</li>
<li>여기에서 양수와 음수를 구별하는 비트를 부호 비트라고 한다.</li>
</ul>
<p><img src="./images/sign_bit_diagram.png" alt="부호 비트 다이어그램" /></p>
<ul>
<li>부호를 표현하는 데 1비트를 사용했기 때문에 나머지 7비트에만 데이터를 저장한다.</li>
<li>7비트는 양수일 때 숫자 128개(0~127)중 하나,</li>
<li>음수일 때 숫자 128개(-128~-1)중 하나를 저장할 수 있는 크기이다.</li>
<li>즉 -128~127 사이의 숫자 중 하나를 저장한다.</li>
<li>0을 양수에 포함시켜서, 0이나 양수일 때는 0을 부호 비트에 저장한다.</li>
<li>음수 표현법은 2의 보수법과 관련있고, 자세한 내용은 [한 권으로 끝내는 컴퓨터 구조와 프로그래밍] 이라는 책 스터디를 통해 알아보겠다.</li>
</ul>
<h3 id="데이터를-저장할-때-메모리를-절약하려면"><a class="header" href="#데이터를-저장할-때-메모리를-절약하려면">데이터를 저장할 때 메모리를 절약하려면?</a></h3>
<ul>
<li>컴퓨터의 CPU는 모든 데이터를 숫자로 인지하고 처리하기 때문에 문자도 숫자로 변경해주어야 한다.</li>
<li>데이터를 숫자로 변경해서 사용하면 일반적으로 유효 범위를 가지게 된다.</li>
<li>예를 들어 사람의 나이 정보를 저장하려고 한다면, 컴퓨터 메모리를 기준으로 1바이트는 0에서 255 사이의 값을 저장할 수 있기 때문에 1바이트 메모리 공간에 나이 데이터를 저장하면 된다는 결론이 나온다.</li>
<li>이렇게 데이터의 유효 범위를 예상하고 적합한 크기를 결정하는 것은 메모리에 데이터를 저장하는 데 필요한 가장 기본적인 작업이다.</li>
<li>요즘도 메모리를 절약하는 게 중요한가?
<ul>
<li>내 생각은 Yes 이다.</li>
<li>내 프로그래밍 철학은 Fast and Robust 이다.</li>
</ul>
</li>
</ul>
<h2 id="3-2-문자를-숫자로-표현하는-약속-아스키코드"><a class="header" href="#3-2-문자를-숫자로-표현하는-약속-아스키코드">3-2. 문자를 숫자로 표현하는 약속, 아스키코드</a></h2>
<ul>
<li>컴퓨터에 우리가 사용하는 데이터를 저장하려면 일단 문자를 숫자화시켜야 한다고 했는데</li>
<li>그러면 컴퓨터와 같은 기기들이 어떤 규칙으로 문자를 숫자로 변경하는지 알아보자.</li>
</ul>
<h3 id="아스키ascii코드란"><a class="header" href="#아스키ascii코드란">아스키(ASCII)코드란?</a></h3>
<ul>
<li>아스키는 컴퓨터에서 문자를 숫자로 표현하기 위한 약속이다.</li>
<li>ASCII, American Standard Code for Information Interchange</li>
<li>아스키는 1967년에 표준으로 제정되어 1986년에 마지막으로 개정되었다.</li>
<li>아스키는 초창기에 7비트 방식으로 인코딩(Encoding)되었기 때문에 출력 불가능한 제어문자 33개(0~32번)와 공백을 비롯한 출력 가능한 문자 95개로 이루어져 있다.</li>
<li>따라서 총 128개(8비트 중 7비트만 사용)의 코드로 구성된다.</li>
<li>인코딩이란 데이터를 약속한 형태의 숫자로 변경하는 것을 말한다.</li>
<li>7비트 방식으로 인코딩되었다는 것은 7비트 크기의 숫자로 변경되었다는 뜻이다.</li>
<li>하지만 컴퓨터가 발전하여 좀 더 다양한 표현이 필요해짐에 따라 8비트 인코딩을 사용하도록 확장되었다.</li>
<li>0~255 범위를 가지며 이 범위는 부호를 고려하지 않는 1바이트 메모리에 저장할 수 있다.</li>
<li>따라서 컴퓨터에서 문자가 아스키로 표현되었다면 1바이트 메모리에 저장하는 것이 가장 효율적이다.</li>
</ul>
<h2 id="3-3-자료형의-종류"><a class="header" href="#3-3-자료형의-종류">3-3. 자료형의 종류</a></h2>
<h3 id="자료형은-왜-필요할까"><a class="header" href="#자료형은-왜-필요할까">자료형은 왜 필요할까?</a></h3>
<ul>
<li>컴퓨터 메모리가 1바이트(Byte) 단위로 주소가 부여되어 있다고 해서 데이터를 저장하거나 읽을 때 1바이트 단위로만 사용해야 하는 것은 아니다.</li>
<li>자신이 사용할 데이터의 크기에 맞게 메모리(저장 공간)을 할당해서 사용하면 된다.</li>
<li>그래서 메모리를 사용할 때 몇 바이트의 메모리를 사용할 것인지를 명시해야 하는데, 이것을 데이터 타입(Data Type) 또는 자료형이라고 한다.</li>
<li>메모리 공간에서 프로그래머가 원하는 만큼의 크기(1byte, 2bytes, ⋯)를 배정해 주는 것을 '메모리를 할당한다'라고 한다.</li>
<li>C 언어는 사용 빈도가 높은 자료형을 예약어로 제공(Built-in Data Type)하고, 나머지는 사용자가 만드러서 사용할 수 있는 문법(User-defined Data Type)을 제공한다.</li>
<li>데이터를 메모리에 저장하는 작업은 정해 놓은 단위로만 가능하다.</li>
</ul>
<h3 id="정수를-표현하는-자료형"><a class="header" href="#정수를-표현하는-자료형">정수를 표현하는 자료형</a></h3>
<ul>
<li>C 언어는 정수 값을 저장하는 데 세 가지 자료형,</li>
<li>즉 1바이트, 2바이트, 4바이트 크기의 자료형을 제공한다.</li>
</ul>
<h4 id="signed-char-부호가-있는-1바이트-저장-공간"><a class="header" href="#signed-char-부호가-있는-1바이트-저장-공간">signed char: 부호가 있는 1바이트 저장 공간</a></h4>
<ul>
<li><code>signed char</code>는 1바이트(8비트) 크기의 자료형이다.</li>
<li>하지만 부호 있는 데이터를 처리하기 때문에 첫 1비트는 부호 비트로 사용하고 나머지 7비트에만 숫자를 저장한다.</li>
<li>부호 비트가 0이면 양수를 의미하고 총 128개의 숫자(0~127) 중 하나를 저장할 수 있다.</li>
<li>부호 비트가 1이면 음수를 의미하고 128개의 숫자(-128~-1) 중 하나를 저장할 수 있다.</li>
<li>따라서 <code>signed char</code>자료형은 -128~127의 숫자 중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">signed char temperature;
temperature = -2;  // 영하 2℃를 temperature 변수에 저장함
</code></pre>
<ul>
<li>temperature 변수는 자료형이 <code>signed char</code>이므로 1바이트의 메모리 공간을 사용한다.</li>
</ul>
<h4 id="unsigned-char-부호가-없는-1바이트-저장-공간"><a class="header" href="#unsigned-char-부호가-없는-1바이트-저장-공간">unsigned char: 부호가 없는 1바이트 저장 공간</a></h4>
<ul>
<li><code>unsigned char</code>는 부호 비트 없이 1바이트(8비트) 전체를 숫자 저장 공간으로 사용하기 때문에 256개의 숫자(0~255) 중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">unsigned char age;
age = 52;  // 나이 52살을 age 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>unsigned char</code>를 사용했으므로 age 변수에는 255살까지 저장할 수 있다.</li>
</ul>
<h4 id="signed-short-int-부호가-있는-2바이트-저장-공간"><a class="header" href="#signed-short-int-부호가-있는-2바이트-저장-공간">signed short int: 부호가 있는 2바이트 저장 공간</a></h4>
<ul>
<li><code>signed short int</code>는 2바이트(16비트) 크기의 자료형이다.</li>
<li>하지만 부호 있는 데이터를 처리하기 때문에 첫 1비트는 부호 비트로 사용하고 나머지 15비트에만 숫자를 저장한다.</li>
<li>따라서 부호 비트가 0이면 양수를 의미하고 2<sup>15</sup>인 32,768개의 숫자(0~32,767)중 하나를 저장할 수 있다. </li>
<li>부호 비트가 1이면 음수를 이미하고 32,768개의 숫자(-32,768~-1)중 하나를 저장할 수 있다.</li>
<li>즉 -32,768~32,767이 숫자 중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">signed short int dday;
dday = -20;  // D-Day가 20일 남았다고 dday라는 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>signed short int</code>를 사용했으므로 변수 dday에는 -32,768~32,767의 정수 값을 지정할 수 있다.</li>
</ul>
<h4 id="unsigned-short-int-부호가-없는-2바이트-저장-공간"><a class="header" href="#unsigned-short-int-부호가-없는-2바이트-저장-공간">unsigned short int: 부호가 없는 2바이트 저장 공간</a></h4>
<ul>
<li><code>unsigned short int</code>는 2바이트(16비트) 전체를 숫자 저장 공간으로 사용하기 때문에 65,536개의 숫자(0~65,535)중 하나를 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">unsigned short int seconds;
seconds = 35000;  // 3만 5000초를 seconds 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>unsigned short int</code>를 사용했으므로 seconds 변수에는 0~65,525의 정수 값을 저장할 수 있다.</li>
</ul>
<h4 id="signed-long-int-부호가-있는-4바이트-저장-공간"><a class="header" href="#signed-long-int-부호가-있는-4바이트-저장-공간">signed long int: 부호가 있는 4바이트 저장 공간</a></h4>
<ul>
<li><code>signed long int</code>는 4바이트(32비트) 크기이지만 부호 있는 데이터를 처리하기 때문에 첫 1비트만 부호 비트로 사용하고 나머지 31비트에는 숫자를 저장한다.</li>
<li>부호 비트가 0이면 양수인 2<sup>31</sup>개의 숫자(0~2<sup>31</sup>-1)중 하나를 저장할 수 있고,</li>
<li>부호 비트가 1이면 음수인 2<sup>31</sup>개의 숫자(-2<sup>31</sup>~-1)중 하나를 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">signed long int money;
money = 7000000;  // 700만 원을 money 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>signed long int</code>를 사용했으므로 money 변수에는 -2,147,483,648~2,147,483,647의 정수 값을 저장할 수 있다.</li>
</ul>
<h4 id="unsigned-long-int-부호가-없는-4바이트-저장-공간"><a class="header" href="#unsigned-long-int-부호가-없는-4바이트-저장-공간">unsigned long int: 부호가 없는 4바이트 저장 공간</a></h4>
<ul>
<li><code>unsigned long int</code>는 4바이트(32비트) 전체를 숫자 저장 공간으로 사용하기 때문에 2<sup>32</sup>인 4,294,967,296개의 숫자(0~4,294,967,295)중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">unsigned long int time_seconds;
// 1970년 1월 1일부터 현재까지 흐른 시간을 초 단위로 환산한 값을 time_seconds 변수에 저장함
time_seconds = 1453100624;
</code></pre>
<ul>
<li>
<p>자료형으로 <code>unsigned long int</code>를 사용했으므로 time_seconds 변수에는 0~4,294,967,295의 정수 값을 저장할 수 있다.</p>
</li>
<li>
<p>정수 형식의 자료형을 정리해 보면, <code>char</code>자료형과 <code>int</code>자료형이 있다.</p>
</li>
<li>
<p>이것을 부호의 존재 여부에 따라 나눌 수 있고(<code>signed</code>/<code>unsigned</code>),</p>
</li>
<li>
<p><code>int</code>의 경우에는 조금 더 작은 메모리라는 뜻의 <code>short</code>키워드 또는 조금 더 큰 메모리라는 뜻의 <code>long</code>키워드를 붙여서 다양하게 표현할 수 있다.</p>
</li>
</ul>
<h3 id="정수-자료형은-주로-생략한-형태를-쓴다"><a class="header" href="#정수-자료형은-주로-생략한-형태를-쓴다">정수 자료형은 주로 생략한 형태를 쓴다</a></h3>
<ul>
<li>실제 프로그래밍을 할 때는 위에서 배운 자료형대로 <code>signed char</code>, <code>unsigned long int</code>처럼 전체 예약어를 다 적지 않고 생략된 예약어를 사용한다.</li>
<li>보통 <code>signed</code>, <code>long</code>을 생략한다.</li>
</ul>
<h3 id="실수를-표현하는-자료형"><a class="header" href="#실수를-표현하는-자료형">실수를 표현하는 자료형</a></h3>
<ul>
<li>실수를 표현하는 부동소수점 방식에는 <code>float</code>와 <code>double</code>이 있다.</li>
</ul>
<h4 id="컴퓨터에서-실수를-표현하는-방식-부동소수점"><a class="header" href="#컴퓨터에서-실수를-표현하는-방식-부동소수점">컴퓨터에서 실수를 표현하는 방식, 부동소수점</a></h4>
<ul>
<li>부동소수점(Floating-point) 표현 방식이란 실수를 표현할 때 소수점의 위치를 고정하지 않고 소수점의 위치를 나타내는 수를 따로 적는 방식이다.</li>
<li>부동소수점 표현 방식에 따라 실수 값을 메모리에 저장하면 CPU가 하드웨어적으로 연산해 주기 때문에 프로그래머가 신경 쓸 필요 없다.</li>
<li>실수 형식은 복잡한 연산 과정을 거치기 때문에 정수에 비해 처리 속도가 많이 떨어진다.</li>
<li>실수 312.567을 3.12567x10<sup>2</sup>이라고 표현하면 저장해야 할 정보가 정확하게 둘로 나뉘어져 편리하다.</li>
<li>3.12567 부분을 가수부,</li>
<li>10<sup>2</sup>에서 2를 지수부라고 한다.</li>
<li>C 언어에서는 이 표현을 3.12567E2라고 적는다.</li>
<li>프로그래밍 언어에서 사용하는 실수는 IEEE 754 규약에 정의된 부동소수점 표현이다.</li>
<li>C 언어에서는 32비트(4바이트) 크기의 부동소수점 표현(Single Precision)을 사용하는 <code>float</code>자료형과 64비트(8바이트) 크기의 부동소수점 표현(Double Precision)을 사용하는 <code>double</code>자료형을 제공한다.</li>
</ul>
<h4 id="32비트-부동소수점-표현-float"><a class="header" href="#32비트-부동소수점-표현-float">32비트 부동소수점 표현: float</a></h4>
<ul>
<li>이 자료형은 메모리 공간을 가수부와 지수부로 나누어 실수 형태의 값을 저장하며 그 형식은 다음과 같다.</li>
</ul>
<p><img src="./images/float_diagram.png" alt="IEEE 754 규약에 정의된 float형의 부동소수점 표현" /></p>
<ul>
<li>저장할 수 있는 값의 범위는 1.2E-38~3.4E38이다.</li>
<li>1.2E-38은 2<sup>-126</sup>값을 반올림한 값이고,</li>
<li>3.4E38은 2<sup>128</sup>값을 반올림한 값이다.</li>
<li>지수부의 범위는 왜 2<sup>-126</sup>부터 시작할까?</li>
<li>32비트를 기준으로 할 때, 모든 지수 비트가 0인 -127은 2<sup>-127</sup>값이 그대로 사용되지 않는다.</li>
<li>2<sup>-127</sup>은 오류나 특정한 상황을 표시하는 값으로만 사용된다.</li>
<li>반면에 모든 지수 비트가 1인 128의 경우에는 특정한 상황을 표시하기도 하지만 2<sup>128</sup>값 그대로를 의미하기도 한다.</li>
<li>따라서 <code>float</code>형의 범위가 1.2E-38~3.4E38이 되는 것이다.</li>
</ul>
<blockquote>
<h4 id="bias가-무엇인가"><a class="header" href="#bias가-무엇인가">Bias가 무엇인가?</a></h4>
<ul>
<li>일반 정수는 최상위 비트 값이 0이면 양수이고, 1이면 음수라고 정해 놓고 부호를 구별한다.</li>
<li>하지만 실수 표현에서 지수 부분의 값은 음수나 양수 표현을 최상위 비트 값을 기준으로 하지 않고 정해진 BIAS(편향 지수) 값을 기준으로 하고 있다.</li>
<li>따라서 BIAS 값이 127이라면 127이 0이라는 뜻이다.</li>
</ul>
</blockquote>
<pre><code class="language-c">float pi;
pi = 3.14;
</code></pre>
<ul>
<li>32비트 기반인 <code>float</code>는 저장 범위는 <code>int</code>와 같지만 정수부와 소수부를 모두 저장해야 하기 때문에 소수점 이하 숫자가 6자리밖에 안 된다.</li>
</ul>
<pre><code class="language-c">float pi;
pi = 3.14159264;
</code></pre>
<ul>
<li>이렇게 소수점 이하에 6개보다 많은 숫자를 쓰고 pi 변수에 저장한 후 출력해 보면, 6자리를 넘는 숫자부터는 잘못된 값을 출력한다.</li>
</ul>
<pre><code class="language-text">출력값: 3.141592741
</code></pre>
<ul>
<li>따라서 소수점 이하 숫자를 6자리 이상 사용하려면 64비트 기반의 <code>double</code>자료형을 사용해야 한다.</li>
</ul>
<h4 id="64비트-부동소수점-표현-double"><a class="header" href="#64비트-부동소수점-표현-double">64비트 부동소수점 표현: double</a></h4>
<ul>
<li>이 자료형도 메모리 공간을 가수부와 지수부로 나누어 실수 형태의 값을 저장하며 그 형식은 다음과 같다.</li>
</ul>
<p><img src="./images/double_diagram.png" alt="IEEE 754 규약에 정의된 double형 부동소수점 표현" /></p>
<ul>
<li>값의 저장 범위는 2.2E-308~1.8E308이다.</li>
<li>이 자료형은 64비트를 기반으로 하기 때문에 소수점 이하 14자리까지 안전하게 저장할 수 있다.</li>
</ul>
<blockquote>
<h4 id="실수는-어떻게-메모리에-저장될까"><a class="header" href="#실수는-어떻게-메모리에-저장될까">실수는 어떻게 메모리에 저장될까?</a></h4>
<p>IEEE 754 에 대한 자세한 내용은 아래의 링크를 참조하자.</p>
<p><a href="http://tipssoft.com/bulletin/board.php?bo_table=FAQ&amp;wr_id=177">http://tipssoft.com/bulletin/board.php?bo_table=FAQ&amp;wr_id=177</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-상수와-변수"><a class="header" href="#4-상수와-변수">4. 상수와 변수</a></h1>
<h2 id="4-1-항상-같은-수-상수"><a class="header" href="#4-1-항상-같은-수-상수">4-1. 항상 같은 수, 상수</a></h2>
<ul>
<li>상수(Constant)는 프로그램을 실행할 때 한 번 값이 결정되면 프로그램이 끝날 때까지 다른 값으로 바뀌지 않는 정보를 말한다.</li>
<li>보통 상수는 숫자형, 문자형, 문자열형으로 구분할 수 있다.</li>
</ul>
<h3 id="숫자형-상수"><a class="header" href="#숫자형-상수">숫자형 상수</a></h3>
<ul>
<li>숫자형 상수(Numeric Constant)는 프로그램에서 가장 기본적인 형태의 상수이며 정수형 상수(Integer Constant)와 실수형 상수(Floating-point constant)로 나뉜다.</li>
<li>C 언어 프로그램에서 숫자형 상수는 다음과 같이 쓰인다.</li>
</ul>
<pre><code class="language-c">unsigned int num = 4500;  // 정수형 상수 4500을 부호가 없는 int 자료형 num 변수에 저장함
float a = 0.17;  // 실수형 상수 0.17을 float 자료형 a 변수에 저장함
</code></pre>
<h3 id="정수형-상수의-다양한-진법-표현"><a class="header" href="#정수형-상수의-다양한-진법-표현">정수형 상수의 다양한 진법 표현</a></h3>
<ul>
<li>C 언어에서는 10진수 형식뿐만 아니라 8진수나 16진수 형식으로도 표현할 수 있다.</li>
</ul>
<h4 id="8진수"><a class="header" href="#8진수">8진수</a></h4>
<ul>
<li>8진수 형식의 숫자를 적을 때는 숫자 앞에 0을 붙여서 적는다.</li>
</ul>
<pre><code class="language-text">012, 050, 075
</code></pre>
<h4 id="16진수"><a class="header" href="#16진수">16진수</a></h4>
<ul>
<li>16진수 형식으로 표현할 때는 숫자 앞에 0x 또는 0X를 붙여서 적는다.</li>
</ul>
<pre><code class="language-text">0x25, 0x51, 0xFC, 0XD5, 0xaf, 0xa1
</code></pre>
<ul>
<li>16진수는 각 자리마다 0~9, A~F로 이루어진 총 16개의 숫자와 문자를 사용한다.</li>
</ul>
<h3 id="문자형-상수"><a class="header" href="#문자형-상수">문자형 상수</a></h3>
<ul>
<li>프로그램에서 문자를 표시할 때 사용하는 문자형 상수(Character Constant)는 작은 따옴표(')를 사용하여 표현하며 영문자(Alphabet), 숫자형 문자(Digit), 특수 문자(Special Character)로 구분된다.</li>
</ul>
<pre><code class="language-c">char key = 'A';  // A의 아스키 값 65를 변수 key에 저장함
char next = 'A' + 1;  // A의 아스키 값에 1을 더한 66(B의 아스키 값)을 변수 next에 저장함
</code></pre>
<ul>
<li>컴퓨터 내부에서는 모든 데이터를 숫자로 저장한다.</li>
<li>우리가 사용하는 문자들도 약속된 숫자로 번역해서 사용해야 하는데 이 약속이 아스키코드 표에 정의되어 있다.</li>
<li>C 언어에서는 프로그래머가 ASCII표를 외우지 않고도 좀 더 보기 편하게 문자 값을 사용할 수 있도록 문자형 상수를 제공한다.</li>
</ul>
<blockquote>
<h4 id="문자-3을-03으로-적으면-어떻게-될까"><a class="header" href="#문자-3을-03으로-적으면-어떻게-될까">문자 '3'을 '03'으로 적으면 어떻게 될까?</a></h4>
<ul>
<li>정상적인 경우라면 문자형 상수는 문자 하나를 ''(작은따옴표)로 둘러싸 표시하지만, 실수 또는 고의로 '03'과 같이 적더라도 기계어로 번역할 때 오류가 발생하지 않고 두 개의 문자형 상수 값이 연속으로 반영된다.</li>
<li>즉 '0'의 아스키 값은 48이고 '3'의 아스키 값은 51이기 때문에 문자형 상수 값을 저장하는 메모리의 크기가 1바이트라면 앞쪽 값을 버리고 뒤쪽 값 '3'에 해당하는 51이 저장된다.</li>
<li>메모리가 2바이트라면 '0'의 아스키 값 48이 첫 번째 바이트에 저장되고 '3'의 아스키 값 51이 두 번째 바이트에 저장된다.</li>
</ul>
</blockquote>
<h3 id="문자열형-상수"><a class="header" href="#문자열형-상수">문자열형 상수</a></h3>
<ul>
<li>문자열형 상수(Character-string Constant)는 프로그램에서 문자열(한 개 이상의 문자)을 표시할 때 사용하며 &quot;&quot;(큰따옴표)로 묶어서 표현한다.</li>
<li>문자열은 문자들로 이루어진 집합체이며 문자형 상수에서 사용하는 문자들을 모두 사용할 수 있다.</li>
<li>일반적으로 문자 하나는 1바이트를 차지하기 때문에 &quot;Hello!&quot;라고 적으면 문자 6개이므로 6바이트를 차지할 것이라고 생각하기 쉽다.</li>
<li>하지만 실제로는 7바이트를 차지하게 된다.</li>
<li>왜냐하면 문자열은 자신의 끝을 표시하기 위해 마지막 자리에 '비어있다'를 의미하는 0값이 추가되기 때문이다.</li>
<li>여기에서 0은 숫자 0을 의미하는 것이 아니라 특별한 뜻을 담고 있다.</li>
</ul>
<h2 id="4-2-데이터-저장-공간-변수"><a class="header" href="#4-2-데이터-저장-공간-변수">4-2. 데이터 저장 공간, 변수</a></h2>
<ul>
<li>변수(Variable)는 변하는 값이며, 프로그래밍에서는 두 가지 의미를 가진다.</li>
<li>첫 번째는 프로그램이 실행되는 동안 지속적으로 값이 바뀌는 정보를 말한다.</li>
<li>두 번째는 사용자로부터 데이터를 받거나 처리하려면 저장할 공간이 필요한데, 이러한 저장 공간을 뜻한다.</li>
</ul>
<h3 id="변수-이름"><a class="header" href="#변수-이름">변수 이름</a></h3>
<ul>
<li>메모리는 1바이트 단위로 부여된 주소(Address)로 구분되기 때문에 자신에게 할당된 메모리 공간을 사용하려면 해당 메모리의 시작 주소를 기억해야 한다.</li>
<li>하지만 프로그래머가 숫자로 구성된 이 주소를 일일이 기억하면서 프로그래밍을 하기는 어렵다.</li>
<li>따라서 해당 주소에 이름을 붙여 사용하는데 이 이름이 바로 변수 이름이다.</li>
</ul>
<pre><code class="language-c">int n;  // 4바이트 메모리 공간을 주소 대신 n이라는 변수 이름으로 사용함
</code></pre>
<ul>
<li>프로그램 소스에 사용한 변수 이름은 컴파일러가 소스 코드를 기계어로 번역하는 과정에서 실제 메모리상의 주소로 변경된다.</li>
<li>따라서 프로그램에서 변수 이름을 사용하는 것은 실제로 그 변수 값이 저장될 메모리 주소를 사용하는 것과 같은 의미이다.</li>
</ul>
<h3 id="변수-이름을-정할-때-기억해야-할-것"><a class="header" href="#변수-이름을-정할-때-기억해야-할-것">변수 이름을 정할 때 기억해야 할 것</a></h3>
<ul>
<li>변수 이름은 영문자 a~z, A~Z, 숫자 0~9 그리고 _(밑줄)을 조합하여 구성할 수 있다.</li>
<li>모두 숫자로 구성하거나 숫자로 시작하는 문자열은 변수 이름으로 사용할 수 없다.</li>
<li>변수 이름은 공백을 포함할 수 없다.</li>
<li>변수 이름은 대·소문자를 구별한다.</li>
<li>C 언어의 예약어는 변수 이름으로 사용할 수 없다.</li>
</ul>
<blockquote>
<h4 id="표기법은-이름을-지을-때-사용하는-규칙이다"><a class="header" href="#표기법은-이름을-지을-때-사용하는-규칙이다">표기법은 이름을 지을 때 사용하는 규칙이다</a></h4>
<ul>
<li>표기법(Notation)은 프로그램에서 변수 또는 함수의 이름을 정할 때 사용하는 일정한 규칙이다.</li>
<li>잘 알려진 표기법에는 '카멜 표기법'과 '헝가리언 표기법'이 있다.</li>
</ul>
<pre><code class="language-text">my_name, myName
</code></pre>
</blockquote>
<h3 id="변수-선언하기"><a class="header" href="#변수-선언하기">변수 선언하기</a></h3>
<ul>
<li>프로그램에서 정보를 저장하기 위해 메모리 공간을 확보하는 과정을 '변수를 선언한다'라고 한다.</li>
<li>변수의 크기가 항상 1바이트일 수는 없기 때문에 자신이 사용할 메모리 크기에 적합한 자료형을 지정하여 선언한다.</li>
</ul>
<pre><code class="language-c">signed int num;
</code></pre>
<ul>
<li><code>signed int</code>는 자료형이고 '부호를 고려하는 4바이트'를 의미하기 때문에 이 명령문으로 할당되는 메모리 공간은 4바이트가 된다.</li>
<li>이렇게 할당된 메모리 공간은 num이라는 변수 이름으로 지정했기 때문에, 해당 메모리 공간에 정보를 저장하거나 저장된 정보를 읽을 때는 num이라는 변수 이름을 사용하면 된다.</li>
</ul>
<h3 id="변수-초기화하기"><a class="header" href="#변수-초기화하기">변수 초기화하기</a></h3>
<ul>
<li>변수를 사용하기 전 초기값을 저장해서 깨끗하게 만드는 것을 '초기화'라고 한다.</li>
<li>컴퓨터 메모리는 각종 프로그램에 의해 공유되는 자원이다.</li>
<li>따라서 특정 프로그램이 특정 메모리를 지정해서 사용하는 것이 아니라, 프로그램이 실행될 때 운영체제에 의해 사용할 수 있는 적당한 공간에 할당되는 방식이다.</li>
<li>따라서 자신이 사용한 메모리는 이전에 어떤 프로그램이 사용했는지 알 수 없고 그 메모리에 어떤 값이 들어 있는지도 알 수 없다.</li>
<li>이것은 이전에 이 메모리를 사용한 프로그램이 사용 후에 메모리를 깨끗하게 청소하지 않고 끝내 버리기 때문이다.</li>
<li>이렇게 정리되지 않은 메모리에 들어 있는 값을 쓰레기 값이라고 부르고, 이 값 대신에 자신이 사용하고 싶은 값을 메모리에 저장하는 행위를 '초기화'라고 한다.</li>
</ul>
<pre><code class="language-c">int value;  // 4바이트 크기의 value 변수에 어떤 값이 저장되어 있는지 알 수 없음
</code></pre>
<pre><code class="language-c">int value = 0;  // 4바이트 크기의 value 변수에 정수형 상수 값 0을 넣어 초기화함
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int money;  // int형 변수 money를 선언함
    money = 3000;  // 변수 money에 값 3000을 저장함
    printf(&quot;money에 저장된 값은 %d&quot;, money);
}
</code></pre>
<pre><code class="language-text">money에 저장된 값은 3000
</code></pre>
<h2 id="4-3-2진수를-16진수로-변환하는-방법"><a class="header" href="#4-3-2진수를-16진수로-변환하는-방법">4-3. 2진수를 16진수로 변환하는 방법</a></h2>
<h3 id="비트-단위-연산에-유용한-16진수"><a class="header" href="#비트-단위-연산에-유용한-16진수">비트 단위 연산에 유용한 16진수</a></h3>
<ul>
<li>메모리가 1비트 증가할 때마다 저장할 수 있는 수의 크기는 2배 늘어난다.</li>
<li>16진수 한 자릿수에는 16개의 숫자(0~9, A~F)중 하나를 저장할 수 있다.</li>
<li>따라서 16진수를 저장할 때 각 자릿수마다 4비트씩 늘어난다고 보면 된다.</li>
<li>16진수 한 자릿수는 4비트를 의미하기 때문에 13의 1과 3이 각각 4비트씩 총 8비트로 표현한다.</li>
<li>마찬가지로 BC는 B와 C가 각각 4비트씩 총 8비트로 표현된다.</li>
<li>4비트 패턴과 16진수를 연결한 표를 보면 알 수 있듯이 4비트로 표현한 값이 2진수 형태이기 때문에 16개 값만 기억한다면 16진수를 2진수로 변환하거나 2진수를 16진수로 변환하는 것이 매우 쉬워진다.</li>
<li>다음 표를 외우자!</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>10진수</th><th>16진수</th><th>2진수</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0000</td></tr>
<tr><td>1</td><td>1</td><td>0001</td></tr>
<tr><td>2</td><td>2</td><td>0010</td></tr>
<tr><td>3</td><td>3</td><td>0011</td></tr>
<tr><td>4</td><td>4</td><td>0100</td></tr>
<tr><td>5</td><td>5</td><td>0101</td></tr>
<tr><td>6</td><td>6</td><td>0110</td></tr>
<tr><td>7</td><td>7</td><td>0111</td></tr>
<tr><td>8</td><td>8</td><td>1000</td></tr>
<tr><td>9</td><td>9</td><td>1001</td></tr>
<tr><td>10</td><td>A</td><td>1010</td></tr>
<tr><td>11</td><td>B</td><td>1011</td></tr>
<tr><td>12</td><td>C</td><td>1100</td></tr>
<tr><td>13</td><td>D</td><td>1101</td></tr>
<tr><td>14</td><td>E</td><td>1110</td></tr>
<tr><td>15</td><td>F</td><td>1111</td></tr>
</tbody></table>
</div>
<ul>
<li>C 언어에서 16진수를 사용할 때는 반드시 앞에 0x를 붙여야 한다.</li>
<li>C 언어는 8진법, 10진법 그리고 16진법은 사용할 수 있어도 2진법 표현은 제공하지 않아서 비트별로 값을 표현하는 형식을 사용할 수가 없다.</li>
<li>하지만 컴퓨터 메모리에 저장된 메모리 패턴은 2진수 표현과 같다.</li>
<li>또한 비트 단위로 값을 사용할 수 있는 기술을 제공하기 때문에 2진법으로 숫자를 변경해야 하는 경우가 많으니 진법 변환을 잘 연습해두자.</li>
</ul>
<h3 id="16진수-표기에-따른-메모리-계산"><a class="header" href="#16진수-표기에-따른-메모리-계산">16진수 표기에 따른 메모리 계산</a></h3>
<ul>
<li>결국 C 언어에서 0x2E라고 표기된 16진수 값을 메모리에 저장하기 위해서는 최소한 1바이트(0010 1110)가 필요하다.</li>
<li>16진수를 0xA처럼 한 자릿수만 적더라도 대입 연산자(=)는 최소 1바이트 단위로 값을 읽고 쓰기 때문에, 표기된 숫자는 4비트만 사용하지 못하고 0x0A값(0000 1010)으로 저장된다.</li>
<li>마찬가지로 다음 코드처럼 0xA를 2바이트 변수인 data에 저장하려면 0x000A 값(0000 0000 0000 1010)으로 저장된다.</li>
</ul>
<pre><code class="language-c">short int data = 0xA;  // short int가 2바이트 메모리를 차지하기 때문에 0x000A라고 적은 것과 같음
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-함수"><a class="header" href="#5-함수">5. 함수</a></h1>
<h2 id="5-1-c-언어와-함수"><a class="header" href="#5-1-c-언어와-함수">5-1. C 언어와 함수</a></h2>
<h3 id="작업-단위로-명령을-표현하는-방법"><a class="header" href="#작업-단위로-명령을-표현하는-방법">작업 단위로 명령을 표현하는 방법</a></h3>
<ul>
<li>컴퓨터의 CPU는 단순화된 명령을 한 번에 하나씩 처리하도록 설계되어 있다.</li>
<li>프로그래밍 언어도 복잡한 표현법보다는 간단한 표현법을 나열하여 상황을 표현한다.</li>
<li>연속적인 행위들을 하나의 작업 단위로 묶어서 정의해 놓는다면 효율적이다.</li>
</ul>
<h3 id="함수란"><a class="header" href="#함수란">함수란?</a></h3>
<ul>
<li>C 언어 프로그램도 특별한 단위나 구분 없이 명령문들을 주욱 나열해서 작성하는 것보다 어떤 작업을 수행하는 일련의 명령문들을 한데 묶어서 그룹으로 만들어 두는 게 좋다.</li>
<li>작업별 그룹으로 나누어 작성한 소스 코드는 관리하기도 편할뿐더러 다른 프로그래머가 보거나 나중에라도 코드의 내용을 쉽게 이해할 수 있다.</li>
<li>C 언어는 소스 코드를 그룹화할 수 있도록 함수(Function)라는 문법을 제공한다.</li>
<li>C 언어는 소스 코드를 함수 단위로 나누어서 작성하는 것을 권장하기 때문에, 잘 작성한 C 언어 프로그램은 수많은 함수들로 이루어진 함수의 집합체라고 할 수 있다.</li>
</ul>
<h4 id="특별한-기능을-가진-main-함수"><a class="header" href="#특별한-기능을-가진-main-함수">특별한 기능을 가진 main 함수</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<ul>
<li>소스 코드를 번역하는 컴파일러 입장에서는 어떤 함수가 최초로 시작되는 함수인지를 알아야 제대로 된 번역을 할 수 있다.</li>
<li>C 언어는 <code>main</code>이라는 이름의 함수를 '프로그램 시작 함수'로 정해 놓았다.</li>
<li>즉 <code>main</code>함수는 '컴파일러에게 프로그램이 시작한다'고 알려주는 특별한 함수라고 생각하면 된다.</li>
</ul>
<h3 id="c-언어-프로그램은-함수의-집합체이다"><a class="header" href="#c-언어-프로그램은-함수의-집합체이다">C 언어 프로그램은 함수의 집합체이다</a></h3>
<ul>
<li>C 언어의 소스 파일에는 꼭 하나 이상의 함수가 있다.</li>
<li>C 언어로 작성한 프로그램은 함수들의 집합체이고 그 함수들끼리 서로 불러서 사용하는 형태로 진행된다.</li>
</ul>
<h2 id="5-2-함수-정의하고-호출하기"><a class="header" href="#5-2-함수-정의하고-호출하기">5-2. 함수 정의하고 호출하기</a></h2>
<h3 id="함수-정의하기"><a class="header" href="#함수-정의하기">함수 정의하기</a></h3>
<pre><code class="language-c">int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}
</code></pre>
<ul>
<li>함수의 이름은 Sum이며 int형 정수 값 두 개를 입력 받아서 int형 결과 값을 반환하는 함수이다.</li>
<li>함수 이름, 변수 이름은 모두 프로그래머가 임의로 지은 이름이고 나머지는 예약어이다.</li>
<li>이렇게 코드를 써서 함수를 실제로 구현하는 행위를 '함수를 정의한다'라고 한다.</li>
</ul>
<ol>
<li>함수 이름: 함수가 하는 일을 짐작하기 쉽게 짓는 것이 좋다.</li>
<li>매개변수: 함수가 작업을 수행할 때 필요한 데이터가 있다면 변수 단위로 명시한다.</li>
<li>작업 내용: 함수가 작업할 내용을 중괄호 {} 안에 명령문으로 나열한다.</li>
<li>반환값: 함수가 작업한 결과 값을 반환해야 할 때 사용한다(선택 사항).</li>
</ol>
<h3 id="함수-호출하기"><a class="header" href="#함수-호출하기">함수 호출하기</a></h3>
<ul>
<li>함수가 다른 함수를 사용하는 것을 '함수를 호출한다'고 한다.</li>
<li>즉 C 언어 프로그램은 함수가 다른 함수를 호출하면서 프로그램이 진행된다.</li>
<li>함수를 호출하는 함수를 호출자(Caller)라고 부르고 호출되는 함수를 피호출자(Callee)라고 한다.</li>
</ul>
<pre><code class="language-c">int Sum(int value1, int value2) {
    int result = value1 + value2;
    return value1 + value2;
}

void main() {
    int a = 2, b = 3, value;
    value = Sum(2, 3);
}
</code></pre>
<h4 id="함수-호출-과정-살펴보기"><a class="header" href="#함수-호출-과정-살펴보기">함수 호출 과정 살펴보기</a></h4>
<ol>
<li><code>main</code>함수가 <code>Sum</code>함수를 호출하면서 a와 b 값을 <code>Sum</code>함수에 전달한다.</li>
<li><code>Sum</code>함수의 매개변수에 <code>main</code>함수에서 전달 받은 값이 복사된다.</li>
<li>입력된 값으로 더하기 작업을 수행한다.</li>
<li><code>main</code>함수로 결과 값을 반환한다.</li>
</ol>
<h3 id="함수의-매개변수-자세히-살펴보기"><a class="header" href="#함수의-매개변수-자세히-살펴보기">함수의 매개변수 자세히 살펴보기</a></h3>
<ul>
<li>프로그램에서 사용하는 데이터는 필요할 때만 존재해야 효율적이므로 함수에서 필요할 때 만들었다가 함수가 끝날 때 함께 사라지도록 만드는 게 보통이다.</li>
<li>그래서 어떤 함수가 가지고 있던 데이터를 다른 함수에 전달하려면 다소 복잡한 표현법을 사용해야 한다.</li>
<li><code>main</code>함수는 <code>a</code>, <code>b</code>에 저장된 값을 더하기 위해 <code>Sum</code>함수를 호출하도록 구성했다.</li>
<li>그런데 함수 안에서 선언한 변수들은 해당 함수에서만 사용할 수 있기 때문에 <code>Sum</code>함수 내부에 선언된 <code>value1</code>, <code>value2</code>, <code>result</code>변수는 <code>Sum</code>함수에서만 사용할 수 있고, <code>main</code>함수 내부에 선언된 <code>a</code>, <code>b</code>변수는 <code>main</code>함수에서만 사용할 수 있다.</li>
<li>즉 <code>Sum</code>함수가 <code>a</code>, <code>b</code>를 직접 사용할 수 없기 때문에 <code>main</code>함수의 <code>a</code>, <code>b</code>변수 값을 <code>Sum</code>함수가 사용하기 위해 매개변수(Parameter)가 필요한 것이다.</li>
<li>매개변수는 호출자(<code>main</code>)에서 전달하는 값을 피호출자(<code>Sum</code>)에서 전달 받는 역할을 하는 변수를 의미하며 <code>Sum</code>함수의 <code>value1</code>과 <code>value2</code>가 여기에 해당한다.</li>
<li>이때 <code>main</code>에서 전달한 순서대로 <code>Sum</code>함수의 매개변수가 값을 전달 받기 때문에 순서와 개수를 잘 맞추어야 한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}

void main() {
    int s;
    s = Sum(2, 3);
    printf(&quot;더하기 작업의 결과는 %d \n&quot;, s);
}
</code></pre>
<ul>
<li><code>Sum</code>함수는 프로그램의 시작인 <code>main</code>함수보다 먼저 작성해야 한다.</li>
<li><code>main</code>함수 뒤에 작성하면 오류가 발생하는데, 이에 대한 자세한 내용은 [5-4]를 보자.</li>
<li><code>%d</code>는 정수를 출력할 때 사용하는 키워드이다.</li>
<li>이와 같이 출력을 위해 사용하는 여러 키워드들은 [6장]에서 배우자.</li>
<li>모든 함수가 매개변수를 가지는 것은 아니다.</li>
<li>특별히 호출자로부터 넘겨받을 정보가 없다면()안을 비워두거나 ()안에 <code>void</code>라고 적어 인자가 없음을 명시하면 된다.</li>
</ul>
<h3 id="함수의-반환값-자세히-살펴보기"><a class="header" href="#함수의-반환값-자세히-살펴보기">함수의 반환값 자세히 살펴보기</a></h3>
<h4 id="반환값이란"><a class="header" href="#반환값이란">반환값이란?</a></h4>
<ul>
<li><code>Sum</code>함수가 수행한 결과 값을 호출자로 넘겨주면 <code>Sum</code>함수의 역할은 끝이 난다.</li>
<li>함수에서 <code>return</code>이라는 예약어를 사용하면 함수는 그 위치에서 종결되며, <code>return</code>뒤에 명시된 <code>result</code>변수 값이 <code>Sum</code>함수의 반환값(Return Value)이 된다.</li>
<li>함수가 값을 반환한다는 뜻은 호출자의 어떤 변수에 값을 대입한다는 뜻이기도 하다.</li>
<li>따라서 변수를 선언할 때처럼 함수 이름 앞에 함수의 반환값에 대한 자료형을 명시해야 한다.</li>
</ul>
<blockquote>
<h4 id="함수의-반환값이-없는-경우도-있을까"><a class="header" href="#함수의-반환값이-없는-경우도-있을까">함수의 반환값이 없는 경우도 있을까?</a></h4>
<ul>
<li>모든 함수가 반환값을 가지는 것은 아니다.</li>
<li>[12장]이후에 배울 포인터나 배열 문법은 문법 자체에 값을 반환하는 기능을 가지고 있다.</li>
<li>따라서 <code>return</code>을 사용하여 결과 값을 반환할 필요가 없다.</li>
<li>반환할 값이 없으면 함수 이름 앞에 <code>void</code>를 적고 <code>return</code>을 사용하지 않으면 된다.</li>
</ul>
<pre><code class="language-c">void ZeroData(int *p) {
    *p = 0;  // 전달된 주소에 가서 0을 대입한다(의미적으로 0이 반환된 것).
}
</code></pre>
<ul>
<li><code>void</code>형식으로 정의한 함수의 <code>return</code>뒤에 반환값을 적으면 오류로 처리된다.</li>
</ul>
<pre><code class="language-c">void Test(int value1, int value2) {
    int result = value1 + value2;
    return result;  // 오류 발생
}
</code></pre>
</blockquote>
<h4 id="return의-또-다른-역할"><a class="header" href="#return의-또-다른-역할">return의 또 다른 역할</a></h4>
<ul>
<li><code>return</code>문은 값을 반환하는 기능 외에도 함수를 종료하는 기능도 가지고 있다.</li>
<li>따라서 단순히 함수를 종결할 목적으로 <code>return</code>을 사용할 때는 <code>return</code>뒤에 반환 값을 적지 않아도 오류가 발생하지 않는다.</li>
</ul>
<pre><code class="language-c">void Test(int value1, int value2) {
    int a = 5;
    return;  // Test 함수가 정상적으로 종료됨
    a = a + 1; // 오류는 아니지만 함수가 이미 종료되었기 때문에 실행되지 않음
}
</code></pre>
<ul>
<li><code>return</code>문을 두 번 적으면 오류가 발생하지는 않지만 두 번째 <code>return</code>문은 실행되지 않는다.</li>
</ul>
<h3 id="함수-이름을-짓는-방법"><a class="header" href="#함수-이름을-짓는-방법">함수 이름을 짓는 방법</a></h3>
<ul>
<li>C 언어로 작성한 소스 코드는 '함수의 집합체'이다.</li>
<li>따라서 이 함수들은 서로를 구별하고 사용할 수 있는 기준이 필요한데 그것이 함수 이름(Function Name)이다.</li>
<li>함수 이름을 짓는 법은 변수 이름 짓는 법과 똑같다.</li>
<li>영문자(a~z, A~Z), 숫자(0~9) 그리고 밑줄(_)을 조합하여 구성할 수 있다.</li>
<li>하지만 이름 전체를 숫자로 구성하거나 숫자로 시작하는 이름은 오류가 발생하기 때문에 함수 이름으로 사용할 수 없다.</li>
<li>공백을 포함할 수 없다.</li>
<li>대·소문자를 구별한다.</li>
<li>C 언어의 예약어는 함수 이름으로 사용할 수 없다.</li>
<li>한 프로그램에서 이름이 같은 함수가 두 개 이상 존재하는 경우에도 오류로 처리된다.</li>
</ul>
<blockquote>
<h4 id="프로그래밍에서-버그란-무엇일까"><a class="header" href="#프로그래밍에서-버그란-무엇일까">프로그래밍에서 버그란 무엇일까?</a></h4>
<ul>
<li>프로그래밍을 하다 보면 종종 오류가 발생한다.</li>
<li>이때 겪는 오류는 크게 두 가지인데 구문 오류(Syntax Error)와 의미상 오류(Semantic Error)가 있다.</li>
<li>구문 오류는 프로그래밍 언어가 제공하는 규칙을 제대로 지키지 않았을 때 발생한다.</li>
<li>이런 경우는 컴파일하기 전에 편집기에서 표시해 주거나, 컴파일할 때 컴파일러가 체크해 알려주기 때문에 찾기 쉽다.</li>
<li>반면에 의미상 오류는 '깡통이 맛있다'와 같은 문장처럼 문법적으로는 맞지만 의미적으로 틀릴 때 발생한다.</li>
<li>이런 오류는 정말 찾기 어렵다.</li>
<li>기계어로 번역할 때는 오류 없이 잘 번역되지만 프로그램을 실행하면 오류가 나서 중단되어 버리기 때문이다.</li>
<li>이러한 상황을 프로그래밍에서 '버그가 발생했다'고 한다.</li>
<li>프로그램에 버그가 발생하면 문법적으로는 문제가 없기 때문에 컴파일러가 오류 사항을 체크해주지 않는다.</li>
<li>따라서 프로그래머가 일일이 소스를 보면서 왜 잘못된 결과가 나오는지 체크해야 하는데, 이렇게 버그를 해결하기 위해 작업하는 행위를 디버깅(Debugging)이라고 한다.</li>
</ul>
</blockquote>
<h2 id="5-3-main-함수-정리하기"><a class="header" href="#5-3-main-함수-정리하기">5-3. main 함수 정리하기</a></h2>
<ul>
<li>한 개의 프로그램에서 <code>main</code>함수는 반드시 한 개만 있어야 한다.</li>
<li><code>main</code>함수가 없거나 두 개 이상 존재하면 컴파일할 때 오류가 발생한다.</li>
<li><code>main</code>함수는 반환형이나 매개변수를 사용자가 별도로 정할 수 없다.</li>
<li>그 대신 몇 가지 정해진 형식을 사용할 수 있도록 되어 있다.</li>
</ul>
<h3 id="main-함수의-반환값"><a class="header" href="#main-함수의-반환값">main 함수의 반환값</a></h3>
<ul>
<li>사용자가 직접 프로그램을 실행시키는 경우도 있지만 특정 프로그램이 다른 프로그램을 실행시키는 경우도 있다.</li>
<li>만약 A라는 프로그램이 B라는 프로그램을 실행시켰다고 생각해보자.</li>
<li>A프로그램 입장에서는 자신이 실행시킨 B프로그램이 정상적으로 작업을 완료했는지, 어떤 상태로 종료했는지 등을 확인해야 할 때가 있다.</li>
<li>이때 B프로그램이 A프로그램에게 자신의 상태 값을 알려주는 방법이 여러 가지 있는데, 그 중 하나가 <code>main</code>함수의 반환값이다.</li>
</ul>
<h4 id="int형으로-반환하기"><a class="header" href="#int형으로-반환하기">int형으로 반환하기</a></h4>
<ul>
<li>프로그램의 상태를 알려주기 위해 <code>main</code>함수의 반환값으로 <code>int</code>형을 사용한다.</li>
</ul>
<pre><code class="language-c">int main() {
    return 1;  // 값 1을 반환함
}
</code></pre>
<ul>
<li>예시에서 <code>return 1;</code>라고 한 것은 1이 참을 의미하므로 프로그램이 성공적으로 실행되었다는 것을 보여주기 위함이다.</li>
<li><code>main</code>함수의 반환값은 0, 1뿐만 아니라 어떤 값을 사용해도 상관없다.</li>
</ul>
<h4 id="void형으로-반환하기"><a class="header" href="#void형으로-반환하기">void형으로 반환하기</a></h4>
<ul>
<li>프로그램에 특별히 반환할 내용이 없다면 <code>void</code>를 사용하면 된다.</li>
</ul>
<pre><code class="language-c">void main() {
    // 반환값 없음
}
</code></pre>
<h3 id="main함수의-매개변수"><a class="header" href="#main함수의-매개변수">main함수의 매개변수</a></h3>
<ul>
<li>명령 프롬프트로 프로그램을 실행할 때, 실행 인자(Argument)를 적을 수 있다.</li>
<li>실행 인자는 공백으로 구분한다.</li>
<li>실행 인자는 프로그램이 시작할 때 넘겨 받는 정보를 말한다.</li>
<li>실행 인자 또한 프로그램 입장에서는 변수로 받기 때문에 <code>main</code>함수의 매개변수가 받는다.</li>
</ul>
<pre><code class="language-c">void main(int argc, char *argv[]) {
    // argc에는 실행 인자의 개수, argv에는 실행 인자값이 들어감
}
</code></pre>
<ul>
<li><code>*argv[]</code>는 포인터형 배열인데, 이것은 뒤에서 포인터와 배열을 배워야 이해할 수 있다.</li>
<li>포인터가 n개 있다는 것을 의미하는 문법이다.</li>
<li>사용자가 실행 인자를 사용하든 사용하지 않든 프로그램에서 실행 인자를 받을 필요가 없다면 매개변수 없이 <code>main()</code>이라고 명시하거나, <code>void</code>를 사용하여 <code>main(void)</code>와 같이 매개변수가 없음을 확실히 명시하면 된다.</li>
</ul>
<h2 id="5-4-함수-원형-선언하기"><a class="header" href="#5-4-함수-원형-선언하기">5-4. 함수 원형 선언하기</a></h2>
<h3 id="함수를-호출할-때-기억해야-할-것"><a class="header" href="#함수를-호출할-때-기억해야-할-것">함수를 호출할 때 기억해야 할 것</a></h3>
<ul>
<li>컴파일러는 C 언어 소스 코드를 기계어로 번역할 때, 코드의 위쪽에서 아래쪽으로 내용을 읽으며 번역한다.</li>
<li>따라서 피호출자가 호출자의 위쪽에 있는 경우에는 번역에 문제가 생기지 않는다.</li>
<li>왜냐하면 컴파일러가 호출자에서 피호출자를 호출하는 명령을 기계어로 번역할 때 피호출자가 어떤 형태의 매개변수를 원하는지, 작업 후에 결과 값을 어떻게 반환하는지를 이미 읽어서 알고 있기 때문이다.</li>
<li>하지만 호출자가 피호출자보다 위에 놓이는 경우에는 피호출자를 호출하는 명령을 번역하는 시점에 아직 컴파일러는 피호출자를 본 적이 없어서 호출 작업과 관련된 코드를 구성할 수 없기 때문이다.</li>
</ul>
<h3 id="함수-원형이란"><a class="header" href="#함수-원형이란">함수 원형이란?</a></h3>
<ul>
<li>프로그래밍을 하다 보면 두 함수가 서로를 호출하는 경우도 생긴다.</li>
<li>따라서 피호출자가 항상 호출자의 위쪽에 놓일 수는 없다.</li>
<li>이런 경우에 함수 원형(Function Prototype)을 사용해서 해결한다.</li>
<li>함수의 원형은 함수가 호출될 때 필요한 정보인 함수 이름, 매개변수, 반환 자료형을 포함하는 표현식이다.</li>
</ul>
<pre><code class="language-c">int Sum(int value1, int value2);  // 함수 원형 선언

void main() {
    int s;
    s = Sum(2, 3);
}

int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}
</code></pre>
<ul>
<li>함수 원형을 미리 선언해 두면 이 프로그램의 소스 파일 어딘가에 해당 형식을 가진 함수가 존재한다는 것을 컴파일러가 인지하게 된다.</li>
<li>따라서 컴파일러는 함수의 원형을 참조하여 <code>main</code>함수에서 <code>Sum</code>함수를 호출하는 구조를 만들 수 있다.</li>
</ul>
<blockquote>
<h4 id="함수-원형을-선언할-때-매개변수-이름을-생략할-수-있다"><a class="header" href="#함수-원형을-선언할-때-매개변수-이름을-생략할-수-있다">함수 원형을 선언할 때 매개변수 이름을 생략할 수 있다.</a></h4>
<ul>
<li>함수의 호출 구조를 만들 때 매개변수 정보는 개수나 자료형만 사용하기 때문에 함수 원형을 적을 때 매개변수 이름을 생략해도 된다.</li>
<li>하지만 오류가 발생하지 않는다고 해도 코드의 가독성을 위해 매개변수 이름은 생략하지 않는 것이 좋다.</li>
</ul>
</blockquote>
<ul>
<li>함수를 '정의'하는 것과 '선언'하는 것을 헷갈리지 말자.</li>
<li>함수를 정의한다는 것은 실제로 함수를 만드는, 함수를 구현하는 행위를 의미한다.</li>
<li>함수를 선언한다는 뜻은 좀 더 명확히 이야기하면 '함수의 원형을 선언한다'는 뜻과 같다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-표준-출력-함수"><a class="header" href="#6-표준-출력-함수">6. 표준 출력 함수</a></h1>
<h2 id="6-1-라이브러리"><a class="header" href="#6-1-라이브러리">6-1. 라이브러리</a></h2>
<h3 id="라이브러리란-무엇일까"><a class="header" href="#라이브러리란-무엇일까">라이브러리란 무엇일까?</a></h3>
<ul>
<li>C 언어 프로그램은 함수 단위로 구성되는데, 이렇게 만들어진 함수들 중에는 내용이 거의 변경되지 않는 함수들도 있다.</li>
<li>C 언어에서는 좀 더 효과적으로 함수를 관리할 수 있도록 라이브러리(Library) 기술을 제공한다.</li>
<li>지속적으로 업데이트가 필요한 함수들만 소스 파일에 유지하고 나머지 함수들은 라이브러리 파일에 넣어서 관리할 수 있도록 만든 것이다.</li>
</ul>
<h3 id="라이브러리-파일lib이-등장한-이유"><a class="header" href="#라이브러리-파일lib이-등장한-이유">라이브러리 파일(*.lib)이 등장한 이유</a></h3>
<ul>
<li>목적 파일(Object File)은 소스 파일을 컴파일해서 만들어지고, 소스 코드가 변경되지 않았다면 컴파일 과정 없이 전에 만들어 놓은 목적 파일을 그대로 사용해서 실행 파일이 만들어진다.</li>
<li>하지만 프로그래밍을 하다 보면 '소스 전체 저장' 또는 '소스 전체 컴파일' 기능을 사용하는 경우가 있다.</li>
<li>이 경우에 프로그래머가 소스 코드를 변경하지 않았어도 소스 파일 전체가 다시 컴파일 될 것이다.</li>
<li>자신이 작업하는 소스 파일 목록 중에서 변경 가능성이 없는 파일들을 다른 곳에 보관해 두고, 소스 파일 대신 목적 파일을 소스 목록에 포함시켜 작업하면 효율성을 높일 수 있다.</li>
<li>그런데 목적 파일에는 치명적인 단점이 있다.</li>
<li>목적 파일에 포함되어 있는 함수의 내용이 실제 사용 여부와 상관없이 모두 실행 파일에 포함된다는 점이다.</li>
<li>그래서 C 언어는 이를 개선하기 위해 '라이브러리' 개념을 제공한다.</li>
</ul>
<h4 id="라이브러리-파일은-실제-사용하는-내용만-실행-파일에-포함한다"><a class="header" href="#라이브러리-파일은-실제-사용하는-내용만-실행-파일에-포함한다">라이브러리 파일은 '실제 사용하는 내용'만 실행 파일에 포함한다</a></h4>
<ul>
<li>라이브러리 파일(*.lib)은 자신이 가지고 있는 함수들 중에서 실제로 다른 소스 파일에서 사용한 함수의 기계어만 분리할 수 있도록 목적 파일을 재구성한 것이다.</li>
<li>그래서 보통 라이브러리 파일은 목적 파일을 변환해서 만들어진다.</li>
<li>이렇게 만들어진 라이브러리 파일을 프로그래머가 목적 파일 대신에 소스 목록에 넣어 두면 링크할 때 실제로 사용되는 함수들만 실행 파일에 포함시킨다.</li>
<li>즉 라이브러리 파일에 10개의 함수 코드가 있어도 프로그램에서 그중 1개만 사용한다면 해당 함수의 코드만 실행 파일에 포함된다.</li>
</ul>
<h3 id="소스-파일-목적-파일-라이브러리-파일"><a class="header" href="#소스-파일-목적-파일-라이브러리-파일">소스 파일? 목적 파일? 라이브러리 파일?</a></h3>
<ul>
<li>프로그램을 만들 때 프로젝트에서 소스 파일을 사용할지, 목적 파일을 사용할지, 라이브러리 파일을 사용할지는 전적으로 프로그래머가 선택할 사항이다.</li>
<li>목적 파일과 라이브러리 파일은 이미 컴파일된 파일이기 때문에 기계어로 변환된 상태라 소스 코드를 볼 수 없다.</li>
<li>따라서 자신이 만든 소스 코드를 다른 사람에게 공개하지 않고 함수들을 사용할 수 있게 하는 좋은 기술이기도 하다.</li>
</ul>
<h3 id="라이브러리-파일은-어디에-사용할까"><a class="header" href="#라이브러리-파일은-어디에-사용할까">라이브러리 파일은 어디에 사용할까?</a></h3>
<ul>
<li>C 언어는 상황에 따라 자신에게 영향을 줄 수 있는 요소들을 분리해서 교체할 수 있도록 함수라는 개념을 제공하고 있다.</li>
<li>프로그램에서 사용할 함수는 라이브러리 형태로 제공 받을 수 있으므로 C 언어 문법 자체를 변경하지 않고도 라이브러리를 교체하여 기능을 확장하거나 변경할 수 있다.</li>
</ul>
<h2 id="6-2-라이브러리-사용-설명서-헤더-파일"><a class="header" href="#6-2-라이브러리-사용-설명서-헤더-파일">6-2. 라이브러리 사용 설명서, 헤더 파일</a></h2>
<h3 id="헤더-파일은-왜-필요할까"><a class="header" href="#헤더-파일은-왜-필요할까">헤더 파일은 왜 필요할까?</a></h3>
<ul>
<li>함수들을 만들고 이것을 라이브러리 파일로 만들어 동료들에게 주었을때, 동료들은 해당 파일에 포함된 함수를 사용할 수 없다.</li>
<li>호출할 때 오류가 발생하기 때문이다.</li>
<li>그 이유는 서로 다른 소스(목적 파일, 라이브러리 파일)파일에 있는 함수를 참조하려면 함수 원형을 알아야 컴파일할 수 있기 때문이다.</li>
<li>따라서 이러한 함수들을 사용하기 위해서는 사용하기 전에 각각의 함수 원형을 먼저 선언해주어야 한다.</li>
<li><code>main.c</code>에서 라이브러리 파일에 있는 함수를 사용하려면, 사용할 함수의 원형을 일일이 선언해야 하는 불편함이 있다.</li>
<li>그래서 함수 원형들을 특정 파일에 미리 선언해 두고 사용하는데, 이것을 헤더 파일(Header File, *.h)이라고 한다.</li>
</ul>
<h3 id="헤더-파일의-형태"><a class="header" href="#헤더-파일의-형태">헤더 파일의 형태</a></h3>
<ul>
<li>라이브러리 파일에 있는 함수를 사용할 수 있도록 각 함수 원형을 헤더 파일에 선언한다.</li>
<li><code>main.c</code>소스 파일에서 각 함수를 사용하기 전에 컴파일러에 헤더 파일을 먼저 읽도록 지시해야 한다.</li>
<li>어떻게 해야 <code>main</code>함수에서 헤더 파일을 참조할 수 있을까?</li>
<li>헤더 파일을 컴파일러에서 읽도록 지시하는 방법은 전처리기 부분을 공부하자.</li>
<li>참고로, 헤더 파일에 함수 원형만 선언되는 것은 아니다.</li>
<li>그 외 여러 가지 문법도 헤더 파일에 들어 있다.</li>
</ul>
<h2 id="6-3-전처리기"><a class="header" href="#6-3-전처리기">6-3. 전처리기</a></h2>
<ul>
<li>프로그래머가 원하는 사항을 컴파일러에 직접 지시하는 문법을 전처리기(Preprocessor)라고 한다.</li>
<li>전처리기 문법은 # 기호로 시작하며 기계어로 번역되는 명령문이 아니기 때문에 문법 끝에 ;(세미콜론)을 사용하지 않는다.</li>
<li>컴파일러에 지시할 수 있는 사항은 굉장히 다양하기 때문에 전처리기 역시 종류가 다양하고 기능도 세분화되어 있다.</li>
</ul>
<h3 id="include-전처리기"><a class="header" href="#include-전처리기">#include 전처리기</a></h3>
<ul>
<li><code>#include</code> 전처리기는 컴파일러에 자신이 명시한 파일을 읽도록 지시한다.</li>
<li>대부분 헤더 파일(*.h)을 읽을 때 사용하며 <code>#include &quot;읽을 파일 이름&quot;</code>으로 표기한다.</li>
<li>파일 이름을 &quot;&quot;로 명시하면 컴파일러는 작업 경로(소스 파일이 있는 폴더의 경로)에서 해당 파일을 찾는다.</li>
<li>따라서 읽고자 하는 헤더 파일은 소스 파일과 같은 작업 경로에 함께 있어야 한다.</li>
<li>만약 헤더 파일이 작업 경로에 없다면 해당 경로를 직접 명시해주어야 한다.</li>
</ul>
<h4 id="include를-사용하는-두-가지-방식"><a class="header" href="#include를-사용하는-두-가지-방식">#include를 사용하는 두 가지 방식</a></h4>
<ul>
<li>컴파일러를 만드는 회사에서 프로그래머들의 편의를 위해 다양한 함수들을 라이브러리 파일과 헤더 파일 형태로 제공하고 있다.</li>
<li>일반적으로 제공되는 헤더 파일과 라이브러리의 경로는 컴파일러가 이미 알고 있다.</li>
<li>따라서 <code>stdio.h</code>같은 헤더 파일은 현재 작업 경로에 없더라도 다음과 같이 사용할 수 있다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<ul>
<li>이렇게 컴파일러가 경로를 알고 있는 경우는 특별한 사용법이기 때문에 &quot;&quot;(큰따옴표) 대신에 &lt;&gt;(꺾쇠괄호)를 사용한다.</li>
<li>물론 헤더 파일의 전체 경로를 사용해도 되고, 전체 경로가 아닌 <code>&quot;stdio.h&quot;</code>만 사용해도 정상적으로 컴파일된다.</li>
<li>이것은 컴파일러가 먼저 현재 자신이 작업하는 경로에서 해당 파일을 찾고, 만약 파일이 현재 작업 경로에 없으면 이미 설치된 헤더 파일 경로에서 파일을 찾기 때문이다.</li>
<li>하지만 프로그래머들은 관습적으로 &quot;&quot;는 사용자가 만든 헤더 파일이라고 생각하고, &lt;&gt;는 기본적으로 제공되는 헤더 파일이라고 생각하기 때문에 가능하면 &lt;&gt;를 사용하는 것이 좋다.</li>
</ul>
<h3 id="define-전처리기"><a class="header" href="#define-전처리기">#define 전처리기</a></h3>
<ul>
<li><code>#define</code> 전처리기는 상수나 명령문을 치환하는 문법이다.</li>
</ul>
<h4 id="define-문법으로-상수-치환하기"><a class="header" href="#define-문법으로-상수-치환하기">#define 문법으로 상수 치환하기</a></h4>
<ul>
<li>다음 예시에서 <code>#define</code>문법을 적용하면 컴파일러는 소스 파일에서 <code>MAX_COUNT</code>라는 단어가 나올 때마다 모두 3으로 바꾸어서 번역한다.</li>
</ul>
<pre><code class="language-c">#define MAX_COUNT 3
</code></pre>
<ul>
<li><code>#define</code>으로 치환하는 이름은 변수와 구별하기 위해서 모두 대문자로 적는 것이 좋다.</li>
<li>다음과 같이 선언하고 코드를 작성하면 <code>data</code>변수에는 3이 대입된다.</li>
</ul>
<pre><code class="language-c">#define MAX_COUNT 3  // 3이라는 상수를 MAX_COUNT로 치환
int data = MAX_COUNT;
</code></pre>
<ul>
<li>만일 소스 코드에 3이라는 상수를 그냥 적는다면 이 3이라는 숫자가 무엇을 의미하는지 알기 어려울 것이다.</li>
<li>그러나 3 대신에 <code>MAX_COUNT</code>라고 적으면, 이 숫자가 최대값을 의미한다는 것을 어느 정도 예상할 수 있다.</li>
<li>따라서 의미 전달이 훨씬 잘 되고, 소스 코드를 이해하는데 더 좋다.</li>
<li>프로그램의 소스 코드 관리를 좀 더 편하게 하려면 의미 있는 상수들을 <code>#define</code>을 사용하여 최대한 치환해 주는 것이 좋다.</li>
</ul>
<h4 id="define-문법으로-명령-치환하기"><a class="header" href="#define-문법으로-명령-치환하기">#define 문법으로 명령 치환하기</a></h4>
<ul>
<li><code>#define</code>은 상수뿐만 아니라 명령도 치환할 수 있다.</li>
<li>다음 코드에서 <code>#define</code>은 명령 치환 형식으로 사용되었으며 <code>POW_VALUE</code>에 3이 들어가면 3*3으로 치환되어 <code>data</code>변수에는 9가 대입된다.</li>
</ul>
<pre><code class="language-c">#define POW_VALUE(a) (a * a)
int data = POW_VALUE(3);  // int data = (3 * 3)으로 번역됨
</code></pre>
<ul>
<li>이렇게 명령을 치환해서 사용하는 것이 함수를 호출하는 것과 유사하기 때문에 <code>POW_VALUE</code>를 매크로 함수라고 이야기한다.</li>
<li>매크로라는 용어는 '자주 사용하는 명령을 묶어서 하나의 명령으로 사용한다'는 뜻이다.</li>
</ul>
<h2 id="6-4-c-표준-라이브러리와-표준-출력-함수"><a class="header" href="#6-4-c-표준-라이브러리와-표준-출력-함수">6-4. C 표준 라이브러리와 표준 출력 함수</a></h2>
<ul>
<li>C 언어는 상황에 따른 변화에 대처할 수 있도록 C 표준 라이브러리(C Standard Library)를 제공한다.</li>
<li>표준 라이브러리를 이용하면 서로 다른 환경의 운영체제에서 문법을 변화시키지 않고도 잘 동작하는 프로그램을 만들 수 있다.</li>
</ul>
<h3 id="표준-라이브러리는-왜-필요할까"><a class="header" href="#표준-라이브러리는-왜-필요할까">표준 라이브러리는 왜 필요할까?</a></h3>
<ul>
<li>운영체제의 종류는 매우 다양하며, 운영체제는 기술적 기반이 비슷한 것도 있지만 완전히 다른 것도 많다.</li>
<li>기술적 기반이 다르다는 것은 컴퓨터 하드웨어를 관리하고 제어하는 방식이 다르다는 뜻이기 때문에 똑같은 기능을 구현하더라도 기계어 코드가 다를 수 밖에 없다.</li>
<li>예를 들어 윈도우 운영체제와 리눅스(LINUX) 운영체제는 기술적 기반이 많이 다르기 때문에 화면에 문자 A를 출력하는 과정과 방법이 다를 수 밖에 없다.</li>
<li>C 언어는 문자를 출력하는 것과 같이 시스템에 영향을 받는 요소들은 고정된 문법으로 제공하지 않는다.</li>
<li>C 언어 컴파일러를 만든 회사들은 프로그래머들을 위해 운영체제별로 다양한 기능을 구현한 함수를 만들어서 제공하는데, 이들을 C 언어 표준 함수(C Standard Function)라고 한다.</li>
<li>이렇게 운영체제에 영향을 받는 기능들을 표준 라이브러리를 이용해서 프로그래밍했다면 운영체제가 바뀌어도 소스 코드를 변경할 필요 없이 해당 운영체제에서 컴파일만 다시 한 후 실행할 수 있다.</li>
</ul>
<h3 id="표준-출력-함수-살펴-보기"><a class="header" href="#표준-출력-함수-살펴-보기">표준 출력 함수 살펴 보기</a></h3>
<ul>
<li>표준 출력이란 해당 시스템이 가장 기본으로 사용하는 출력 방식을 말한다.</li>
<li>이 표준 출력 함수들은 stdio.h(Standard Input Output Header)파일에 정의되어 있다.</li>
</ul>
<h4 id="단일-문자-출력-함수-putchar-putc"><a class="header" href="#단일-문자-출력-함수-putchar-putc">단일 문자 출력 함수 putchar, putc</a></h4>
<ul>
<li>단일 문자를 출력하는 함수로 '놓다'라는 의미의 'put'과 문자를 의미하는 character의 'char'를 합친 <code>putchar</code>가 있다.</li>
<li>이 함수는 하나의 매개변수를 가지는데 이 매개변수에 출력할 문자의 아스키(ASCII)값을 명시하면 된다.</li>
</ul>
<pre><code class="language-c">putchar(65);  // 아스키 값 65에 해당하는 문자 A가 출력됨
</code></pre>
<ul>
<li>하지만 프로그래머가 아스키 값을 모두 외우는 것은 불가능하다.</li>
<li>그래서 출력하고 싶은 문자를 <code>putchar</code>함수에 ''(작은따옴표)를 사용해 문자 상수로 지정하면, 컴파일러가 번역할 때 알아서 해당 문자의 아스키 값으로 변환해 준다.</li>
</ul>
<pre><code class="language-c">putchar('A');  // 문자 A가 출력됨
</code></pre>
<ul>
<li><code>putchar</code>함수가 성공적으로 문자를 출력하면 출력된 문자의 아스키 값을 반환하고, 오류가 발생하여 출력에 실패하면 EOF(End Of File, -1)값을 반환한다.</li>
</ul>
<blockquote>
<h4 id="stdioh-헤더-파일에서-putchar-함수를-보면"><a class="header" href="#stdioh-헤더-파일에서-putchar-함수를-보면">stdio.h 헤더 파일에서 putchar 함수를 보면...</a></h4>
<ul>
<li>다음과 같은 <code>#define</code> 전처리기 문장이 있다.</li>
</ul>
<pre><code class="language-c">#define putchar(c) putc((c), stdout)
</code></pre>
<ul>
<li><code>#define</code> 전처리기는 치환하는 문법이기 때문에 <code>putchar('A');</code>는 다음처럼 번역된다.</li>
</ul>
<pre><code class="language-c">putc('A', stdout);
</code></pre>
<ul>
<li>결국 <code>putchar</code>함수는 <code>putc</code>함수를 호출하도록 작성된 매크로(Macro)함수이다.</li>
<li><code>putc</code>는 여러 가지 형식을 출력할 수 있는 함수인데, 표준 출력용으로 사용할 때는 두 번째 매개변수에 표준 출력을 의미하는 <code>stdout</code>값을 함께 사용해야 한다.</li>
<li>매번 <code>stdout</code>을 사용하려면 번거롭기 때문에, 좀 더 편하게 사용할 수 있도록 매크로 함수인 <code>putchar</code>를 만들어 놓은 것이다.</li>
</ul>
</blockquote>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    putchar('H');
    putchar('i');
    putchar('~');
}
</code></pre>
<h4 id="문자열-출력-함수-puts"><a class="header" href="#문자열-출력-함수-puts">문자열 출력 함수 puts</a></h4>
<ul>
<li><code>putc</code>함수처럼 '놓다'라는 의미의 'put'과 문자열을 의미하는 <code>string</code>의 's'를 합친 <code>puts</code>함수가 있다.</li>
<li><code>puts</code>함수의 매개변수는 큰따옴표를 사용해 출력할 대상을 전달한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    puts(&quot;Hi~&quot;);
}
</code></pre>
<ul>
<li>이 함수는 한 개의 매개변수를 가지는데, 이 매개변수에 출력하려는 '문자열 상수'또는 '문자열이 저장되어 있는 메모리의 시작 주소'를 명시하면 된다.</li>
<li>그리고 이 함수는 줄 바꿈 기능을 포함하고 있기 때문에 매개변수에 명시한 문자열을 출력하고 나면 자동으로 캐럿(Caret)이 다음 줄로 이동한다.</li>
</ul>
<h2 id="6-5-문자열-출력-함수-printf"><a class="header" href="#6-5-문자열-출력-함수-printf">6-5. 문자열 출력 함수 printf</a></h2>
<ul>
<li>이 함수의 이름은 '출력하다'라는 의미의 print와 형식을 의미하는 'format'의 첫 자 f를 합쳐서 만들어졌다.</li>
<li>표준 출력 함수 중에서 <code>printf</code>함수를 가장 많이 사용하는 이유는 형식화된 문자열을 출력할 수 있기 때문이다.</li>
<li>즉 변수가 가지고 있는 값을 사용자가 지정한 형태로 출력하는 것이 가능하다.</li>
</ul>
<h3 id="printf-함수를-사용하는-방법"><a class="header" href="#printf-함수를-사용하는-방법">printf 함수를 사용하는 방법</a></h3>
<ul>
<li><code>printf</code>함수에서 문자열을 명시할 때 <code>%</code>서식 지정 키워드를 사용한다.</li>
<li>그 뒤에 자신이 출력할 변수 값을 어떤 형식으로 출력할 것인지를 명시하면 되는데, 자주 사용하는 키워드의 종류는 다음과 같다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>키워드</th><th>%d</th><th>%f</th><th>%c</th><th>%s</th></tr></thead><tbody>
<tr><td>출력 형식</td><td>정수(10진수)</td><td>실수</td><td>문자</td><td>문자열</td></tr>
</tbody></table>
</div>
<pre><code class="language-c">int data = 5;
printf(&quot;%d&quot;, data);  // 출력하려는 형식과 일치하는 키워드(%d)
</code></pre>
<pre><code class="language-c">int data1 = 3;
int data2 = 5;
printf(&quot;%d %d&quot;, data1, data2);
</code></pre>
<pre><code class="language-c">int step = 5;
int value = 3 * step;
// 첫 번째 %d는 step과 짝이 되고 두 번째 %d는 value와 짝을 이룸
printf(&quot;3 * %d = %d&quot;, step, value);
</code></pre>
<ul>
<li>자신이 출력하고 싶은 변수는 <code>printf</code>함수의 두 번째 매개변수부터 원하는 개수만큼 ,(쉼표)로 구분하여 사용하고, 출력하고 싶은 변수의 개수만큼 <code>%</code>키워드를 사용하여 출력 형태를 짝지어주면 된다.</li>
</ul>
<h3 id="-키워드-중심의-출력-특성-확인하기"><a class="header" href="#-키워드-중심의-출력-특성-확인하기">% 키워드 중심의 출력 특성 확인하기</a></h3>
<h4 id="c는-변수가-가지고-있는-값을-아스키-표에-대응하는-문자로-출력한다"><a class="header" href="#c는-변수가-가지고-있는-값을-아스키-표에-대응하는-문자로-출력한다">%c는 변수가 가지고 있는 값을 아스키 표에 대응하는 문자로 출력한다</a></h4>
<ul>
<li><code>%c</code>키워드는 <code>%d</code>키워드 다음으로 많이 쓰인다.</li>
<li><code>%c</code>를 사용하면 뒤에 짝을 이루는 값을 아스키 코드 값으로 대치하여 해당 문자를 출력한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;65이 ASCII 값은 %c입니다.&quot;, 65);
}
</code></pre>
<ul>
<li><code>%</code>와 함께 사용하는 키워드는 변수의 자료형과 일치하지 않아도 된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char data = 65;
    // 첫 번째 data는 %c와 짝이 되고 두 번째 data는 %d와 짝을 이룸
    printf(&quot;%c의 ASCII 값은 %d입니다.&quot;, data, data);
}
</code></pre>
<ul>
<li><code>data</code>변수가 가지고 있는 65라는 값은 <code>%c</code>로 출력하라고 지시하면 컴파일러는 65를 아스키값으로 간줗여 아스키 표에서 65에 대응하는 문자 'A'를 화면에 출력한다.</li>
<li><code>%d</code>로 출력하라고 지시하면 65를 10진 정수로 간주하여 숫자 '65'를 화면에 출력한다.</li>
</ul>
<h4 id="실수와-정수는-숫자를-표현하는-방식이-다르다"><a class="header" href="#실수와-정수는-숫자를-표현하는-방식이-다르다">실수와 정수는 숫자를 표현하는 방식이 다르다</a></h4>
<ul>
<li><code>%f</code>키워드는 다음과 같이 변수 값을 실수 형식으로 출력할 때 사용한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    float value = 2.1f;
    printf(&quot;%f&quot;, value);
}
</code></pre>
<blockquote>
<h4 id="21f에서-f는-무엇인가"><a class="header" href="#21f에서-f는-무엇인가">2.1f에서 f는 무엇인가?</a></h4>
<ul>
<li>C 언어는 실수형인 상수를 적으면 기본적으로 <code>double</code> 자료형으로 처리한다.</li>
<li>따라서 다음과 같이 <code>float</code>자료형으로 변수를 선언하고 실수 형식의 상수를 적으면 8바이트 크기의 <code>double</code>값이 4바이트 크기의 <code>float</code>공간에 저장되기 때문에 데이터가 손실될 수 있다는 경고가
발생한다.</li>
</ul>
<pre><code class="language-c">float value = 2.1;  // 2.1은 double 형식으로 처리되기 때문에 경고 발생함
</code></pre>
<ul>
<li>그래서 C 언어에서 <code>float</code>형식의 실수 상수를 사용하고 싶다면 끝에 f를 함께 적어주어야 한다.</li>
</ul>
<pre><code class="language-c">float value = 2.1f;  // 2.1f는 float 형식으로 정상적으로 처리됨
</code></pre>
</blockquote>
<ul>
<li>실수와 정수가 숫자를 표현하는 방식이 다르기 때문에, 키워드를 선택할 때 항상 주의해야 한다.</li>
<li>실수 값은 부동소수점 표현 방식으로 비트 값이 결정되기 때문에, 일반 정수의 비트 값과 차이가 있다.</li>
<li>따라서 실수 값을 <code>%d</code>또는 <code>%c</code>로 출력하거나 정수 값은 <code>%f</code>로 출력하면 정상적인 결과 값을 얻을 수 없다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    float value = 2.1f;
    // value 변수 값을 실수 형식과 정수 형식으로 출력함
    printf(&quot;%f, %d&quot;, value, value);
}
</code></pre>
<pre><code class="language-text">2.100000, -1073741824
</code></pre>
<ul>
<li>실수를 표현하는 키워드인 <code>%f</code>로 실수를 출력하면 기본적으로 소수점 6자리까지 값을 출력해 준다.</li>
<li>그래서 <code>2.1f</code> 값을 <code>%f</code>로 출력하면 2.100000이 출력된ㄷ.</li>
<li>그러나 만약 <code>2.1f</code> 값을 정수 값으로 출력하고 싶어서 정수를 표현하는 키워드인 <code>%d</code>로 출력하면 실수가 정수로 보정되지 않고 엉뚱한 숫자인 -1073741824가 출력된다.</li>
<li>여기서 -1073741824 값은 오류를 표시하는 0xC0000000 이며 <code>printf</code>함수가 실수형 변수를 <code>%d</code>로 출력하는 것을 잘못 사용했다는 뜻이다.</li>
<li>즉 <code>printf</code>함수로 값을 출력했는데 자신이 원하는 값이 아니라 -1073741824(%d), C0000000(%x), 3221225472(%u) 라고 출력된다면 출력 옵션을 잘못 지정해서 <code>printf</code>
함수가 오류 값을 출력한 것이라고 생각하면 된다.</li>
</ul>
<h4 id="u는-변수-값을-부호를-고려하지-않는-10진-정수-형태로-출력한다"><a class="header" href="#u는-변수-값을-부호를-고려하지-않는-10진-정수-형태로-출력한다">%u는 변수 값을 부호를 고려하지 않는 10진 정수 형태로 출력한다</a></h4>
<ul>
<li>C 언어 프로그램에서 다루는 자료형의 종류는 부호를 고려하는 것(signed)과 고려하지 않는 것(unsigned)으로 나뉘어 있다.</li>
<li>출력해서 확인하는 정수 값도 부호를 고려하는 10진 정수 <code>%d</code>와 부호를 고려하지 않는 10진 정수 <code>%u</code>로 나뉘어 있다.</li>
<li>이 키워드들은 자료형과는 무관하게 사용할 수 있다.</li>
<li>즉 자료형이 무엇이든 간에 그 변수가 가지고 있는 값을 출력할 때 부호를 고려해서 출력하고 싶으면 <code>%d</code>를 사용하고 부호를 고려하지 않겠다면 <code>%u</code>를 사용하면 된다.</li>
</ul>
<blockquote>
<h4 id="-1-값과-최대값은-같은-비트-패턴을-가진다"><a class="header" href="#-1-값과-최대값은-같은-비트-패턴을-가진다">-1 값과 최대값은 같은 비트 패턴을 가진다.</a></h4>
<ul>
<li>부호 있는 32비트 정수형에서 -1은 음수 최대값이다.</li>
<li>부호 비트가 1이고 음수 최대값이기 때문에 나머지 31개의 비트가 모두 1이 된다.</li>
<li>결과적으로 모든 비트가 1인 값이 -1이다.
<br><br></li>
<li>부호가 있는 4바이트(32비트) 정수형에서 음수 최대값 -1의 비트 패턴
<img src="./images/signed_int_max_bit_pattern.png" alt="부호가 있는 4바이트(32비트) 정수형에서 음수 최대값 -1의 비트 패턴" />
<br><br></li>
<li>부호가 없는 4바이트(32비트) 정수형에서 최대값 4,294,967,295의 비트 패턴
<img src="./images/unsigned_int_max_bit_pattern.png" alt="부호가 없는 4바이트(32비트) 정수형에서 최대값 4,294,967,295의 비트 패턴" />
<br><br></li>
<li>부호 없는 4바이트(32비트) 정수형에서 4,294,967,295 값은 최대값을 의미하기 때문에 32개의 비트가 모두 1인 값이다.</li>
<li>결론적으로 부호를 고려하는 -1값과 부호를 고려하지 않는 4,294,967,295값이 같은 비트 패턴이라는 뜻이다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data1 = -1;
    unsigned int data2 = 4294967295;
    printf(&quot;%d, %u, %d, %u&quot;, data1, data1, data2, data2);
}
</code></pre>
<pre><code class="language-text">-1, 4294967295, -1, 4294967295
</code></pre>
<ul>
<li>출력하려는 변수의 자료형과 상관없이 <code>%</code>키워드를 어떻게 사용하는가에 따라 값이 다르게 출력된다.</li>
</ul>
</blockquote>
<h4 id="d와-u는-변수-크기를-4바이트-값으로-변환해서-출력한다"><a class="header" href="#d와-u는-변수-크기를-4바이트-값으로-변환해서-출력한다">%d와 %u는 변수 크기를 4바이트 값으로 변환해서 출력한다</a></h4>
<ul>
<li><code>signed char</code>이 범위는 -128~127이고 <code>unsigned char</code>의 범위는 0~255이다.</li>
<li>-1과 255는 비트 패턴이 동일하다</li>
</ul>
<p><img src="./images/8bit_bit_patterns.png" alt="8비트 비트 패턴" /></p>
<ul>
<li>-1 값을 가진 <code>signed char</code>변수 값을 <code>%u</code>로 출력하면 255가 나올 것이라고 예상하지만, 아래의 코드를 작성해 보면 전혀 다른 값이 출력된다.</li>
<li>이것은 <code>%d</code>또는 <code>%u</code>가 4바이트(32비트) 크기의 정수를 기반으로 값을 출력하기 때문이다.</li>
<li>어떤 크기의 정수가 오든지 4바이트 크기의 값으로 변환해 놓고 출력하기 때문에, 1바이트 크기의 -1 값이 4바이트 크기의 -1로 변경되고 255가 아닌 4,294,967,295값이 출력된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char data = -1;
    printf(&quot;%d, %u&quot;, data, data);
}
</code></pre>
<pre><code class="language-text">-1, 4294967295
</code></pre>
<h4 id="o는-8진수-x는-16진수-형태로-정수를-출력한다"><a class="header" href="#o는-8진수-x는-16진수-형태로-정수를-출력한다">%o는 8진수 %x는 16진수 형태로 정수를 출력한다</a></h4>
<ul>
<li><code>printf</code>함수는 정수를 10진수 외에도 8진수와 16진수로 출력할 수 있다.</li>
<li>8진수는 octal(8진법)의 o를 의미하는 <code>%o</code>로, 16진수는 hexadecimal(16진법)의 x를 의미하는 <code>%x</code>로 출력한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data1 = 10;    // 10진수 -&gt; 10진수로 10
    int data2 = 010;   // 8진수 -&gt; 10진수로 8
    int data3 = 0x10;  // 16진수 -&gt; 10진수로 16
    // data1은 16진수, data2는 10진수, data3은 8진수로 출력함
    printf(&quot;%x, %d, %o&quot;, data1, data2, data3);
}
</code></pre>
<pre><code class="language-text">a, 8, 20
</code></pre>
<h4 id="e는-실수를-지수-형태로-출력한다"><a class="header" href="#e는-실수를-지수-형태로-출력한다">%e는 실수를 지수 형태로 출력한다</a></h4>
<ul>
<li>실수도 소수점으로 표현하는 것 외에 exponential(지수)의 e를 의미하는 <code>%e</code>를 사용해서 지수 형태로 출력할 수 있다.</li>
<li>지수 표현에서도 e라는 문자를 사용하기 때문에 <code>%E</code>를 사용하면 해당 문자가 대문자 E로 출력된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    float data = 12.34f;
    printf(&quot;%f, %e, %E&quot;, data, data, data);
}
</code></pre>
<pre><code class="language-text">12.340000, 1.234000e+01, 1.234000E+01
</code></pre>
<h3 id="출력-문자열-정렬하기"><a class="header" href="#출력-문자열-정렬하기">출력 문자열 정렬하기</a></h3>
<ul>
<li>문자열을 출력할 때는 사용자가 해당 문자열을 잘 이해할 수 있도록 일정한 형식을 갖춰서 출력해야 한다.</li>
<li>예를 들어 어떤 변수가 0~99,999 범위의 값을 가질 때 [50], [1992], [7]처럼 값을 그대로 출력할 수도 있지만, 숫자와 빈칸을 함께 사용해서 [___50], [_1992], [____7]이라고
출력하면 전체 범위에서 해당 값이 어느 정도의 범위를 차지하는 건지 한 눈에 알아볼 수 있다.</li>
</ul>
<h4 id="출력-칸-수-조절하기"><a class="header" href="#출력-칸-수-조절하기">출력 칸 수 조절하기</a></h4>
<ul>
<li>출력할 문자의 개수보다 칸을 더 사용하는 경우도 있다.</li>
<li><code>printf</code>함수를 사용하면 다음 예제처럼 <code>%</code>와 키워드 사이에 숫자를 사용하여 출력 칸을 조절할 수 있다.</li>
<li>숫자는 출력에 필요한 칸 수를 의미하며, 실제 출력되는 문자의 수보다 칸 수가 많으면 오른쪽 정렬로 문자가 출력된다.</li>
<li><code>%출력 칸의 수d</code></li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data = 7;
    // 자리수 확인을 위해 []문자를 사용함
    printf(&quot;[%d] [%5d]&quot;, data, data);
}
</code></pre>
<pre><code class="language-text">[7] [    7]
</code></pre>
<h4 id="오른쪽-정렬과-왼쪽-정렬"><a class="header" href="#오른쪽-정렬과-왼쪽-정렬">오른쪽 정렬과 왼쪽 정렬</a></h4>
<ul>
<li><code>printf</code>함수는 출력 칸 안에 있는 숫자를 <code>+</code>키워드를 사용하여 오른쪽으로 정렬하거나 <code>-</code>키워드를 사용하여 왼쪽으로 정렬할 수 있다.</li>
<li>위의 예제에서 <code>%5d</code>라고 적었을 때 오른쪽 정렬이 된 이유는 <code>%+5d</code>에서 <code>+</code>가 생략되었기 때문이다.</li>
<li>오른쪽 정렬에서는 빈칸에 공백 문자(Space)가 채워지는데, 공백 문자 대신에 0으로 채우고 싶다면 칸 수를 명시할 때 0을 하나 더 적어주면 된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data = 7;
    // 자리수 확인을 위해 []문자를 사용함
    printf(&quot;[%5d] [%05d] [%-5d]&quot;, data, data, data);
}
</code></pre>
<pre><code class="language-text">[    7] [00007] [7    ]
</code></pre>
<h3 id="실수의-소수점-자릿수-지정하기"><a class="header" href="#실수의-소수점-자릿수-지정하기">실수의 소수점 자릿수 지정하기</a></h3>
<ul>
<li>실수는 출력할 칸을 지정하는 것 외에도 .(마침표)를 사용하여 소수점 이하 자리수를 몇 자리까지 출력할 것인지 명시할 수 있다.</li>
<li>예를 들어 <code>%f</code>로 실수를 출력하면 소수점 여섯째 자리까지 출력되는데, 소수점 셋째 자리까지 출력하고 싶다면 <code>%.3f</code>라고 사용하면 된다.</li>
</ul>
<blockquote>
<p>% + 전체 칸 수 + . + 소수점 자릿수 + f</p>
</blockquote>
<ul>
<li>단, 출력할 때 .(마침표)도 출력 칸 수에 포함되기 때문에 전체 자릿수를 명시할 때 칸 수를 잘 계산해야 한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    double data = 3.141592;
    // 자릿수를 확인하기 위해 []문자를 사용함
    printf(&quot;[%f] [%.4f] [%8.4f] [%-8.4f]&quot;, data, data, data, data);
}
</code></pre>
<pre><code class="language-text">[3.141592] [3.1416] [  3.1416] [3.1416  ]
</code></pre>
<ul>
<li><code>%.4f</code>를 사용해서 출력한 값이 3.1415가 아니라 3.1416이 된 것을 보면 알 수 있듯이 .1415 다음의 숫자가 9이기 때문에 반올림하여 .1416이 출력된 것이다.</li>
<li>소수점 자릿수를 변경할 때는 반올림이 적용된다는 점에 주의하자.</li>
<li>그리고 .(마침표)도 전체 출력 칸 수에 포함되기 때문에 <code>%8.4f</code>로 출력될 때 앞쪽에 공백이 2개만 들어간다.</li>
<li>마지막으로 <code>printf</code>함수에서 <code>%</code>자체를 출력하고 싶은 경우에는 <code>%</code>를 두 번 연속 사용하면 된다.</li>
<li><code>95%</code>라고 출력하고 싶다면 다음과 같이 적어 준다.</li>
</ul>
<pre><code class="language-c">printf(&quot;95%%&quot;);
</code></pre>
<h3 id="제어-코드-사용하기"><a class="header" href="#제어-코드-사용하기">제어 코드 사용하기</a></h3>
<ul>
<li>아스키 표를 살펴보면 알파벳, 숫자 그리고 기호에 대한 코드 값 뿐만 아니라 소리를 내거나 콘솔의 출력과 입력의 현재 위치를 알려 주는 캐럿(Caret, _문자로 깜빡임) 위치를 변경할 수 있는 제어 코드도
있다.</li>
<li>표준 출력에 사용하는 문자열에는 캐럿 위치를 조절하기 위해 제어 문자를 포함시키는 경우가 많다.</li>
<li>그런데 제어 코드는 키보드에 있는 문자가 아니라서 제어 코드를 직접 입력할 수 있는 방법이 없다.</li>
<li>그래서 C 언어는 (백슬래시)와 키워드로 제어 코드를 사용할 수 있는 문법을 제공한다.
<br><br></li>
<li>제어 코드 종류와 기능</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>제어 코드</th><th>기능</th></tr></thead><tbody>
<tr><td>\n</td><td>캐럿을 다음 줄로 이동(Line Feed)</td></tr>
<tr><td>\r</td><td>캐럿을 해당 줄의 처음으로 이동(Carriage Return)</td></tr>
<tr><td>\t</td><td>캐럿을 한 탭만큼 이동</td></tr>
<tr><td>\b</td><td>캐럿을 바로 앞 칸으로 이동</td></tr>
<tr><td>\a</td><td>시스템 스피커로 경고음 발생</td></tr>
<tr><td>\&quot;</td><td>큰따옴표 출력</td></tr>
<tr><td>\'</td><td>작은따옴표 출력</td></tr>
</tbody></table>
</div>
<ul>
<li>제어 코드는 모든 표준 출력 함수에서 사용 가능하다.</li>
<li>예를 들어 <code>putc</code>함수와 <code>puts</code>함수에서도 제어 코드를 사용할 수 있다.</li>
</ul>
<h4 id="n-제어-코드-캐럿을-다음-줄로-이동"><a class="header" href="#n-제어-코드-캐럿을-다음-줄로-이동">\n 제어 코드: 캐럿을 다음 줄로 이동</a></h4>
<ul>
<li><code>\n</code>을 사용하면 현재 출력된 문자열이 있는 다음 줄로 캐럿이 이동한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;Hello~ jerok-kim.github.io\n&quot;);
}
</code></pre>
<h4 id="r-제어-코드-캐럿을-해당-줄의-처음으로-이동"><a class="header" href="#r-제어-코드-캐럿을-해당-줄의-처음으로-이동">\r 제어 코드: 캐럿을 해당 줄의 처음으로 이동</a></h4>
<ul>
<li><code>\r</code>를 사용하면 현재 출력된 문자열이 있는 줄의 처음 위치에 캐럿을 놓는다.</li>
<li>만약 <code>\r</code>를 사용한 이후에 문자를 출력한다면 해당 위치에 출력된 문자를 덮어쓰게 된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;Hello~ jerok-kim.github.io\n&quot;);
    printf(&quot;Hello~ jerok-kim.github.io\rHi!!!!&quot;);
}
</code></pre>
<pre><code class="language-text">Hello~ jerok-kim.github.io
Hi!!!! jerok-kim.github.io
</code></pre>
<h4 id="t-제어-코드-캐럿을-한-탭만큼-이동"><a class="header" href="#t-제어-코드-캐럿을-한-탭만큼-이동">\t 제어 코드: 캐럿을 한 탭만큼 이동</a></h4>
<ul>
<li><code>\t</code>를 사용하면 키보드에서 [Tab]키를 입력한 것처럼 캐럿이 이동한다.</li>
<li>보통 4칸 또는 8칸 이동하는데 특별한 설정을 하지 않은 콘솔이라면 캐럿이 8칸씩 이동된다.</li>
<li>하지만 8칸을 이동한다는 것은 캐럿이 있던 위치에서 무조건 8칸을 이동한다는 것이 아니라 핻ㅇ 줄에서 8의 배수에 해당하는 가장 가까운 위치로 이동한다는 뜻이다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    // 탭의 위치 이동을 확인하기 위해서 8의 배수로 출력함
    printf(&quot;12345678123456781234567812345678\n&quot;);
    printf(&quot;a\tbc\tdef\tg&quot;);
}
</code></pre>
<pre><code class="language-text">12345678123456781234567812345678
a       bc      def     g
</code></pre>
<h4 id="b-제어-코드-캐럿을-바로-앞-칸으로-이동"><a class="header" href="#b-제어-코드-캐럿을-바로-앞-칸으로-이동">\b 제어 코드: 캐럿을 바로 앞 칸으로 이동</a></h4>
<ul>
<li><code>\b</code>제어 코드의 b는 'back'을 의미한다.</li>
<li><code>\b</code>를 사용하면 캐럿은 한 칸 앞으로 이동한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;1234567\b&quot;);
}
</code></pre>
<ul>
<li>그 외에도 <code>\a</code>가 있다.</li>
<li>Alert의 약자로 이 제어 문자를 사용하면 스피커로 짧은 경고음이 발생한다.</li>
</ul>
<h3 id="그-밖의-제어-코드"><a class="header" href="#그-밖의-제어-코드">그 밖의 제어 코드</a></h3>
<ul>
<li>(백슬래시)는 키워드의 원래 의미를 없애는 용도로도 사용한다.</li>
<li>화면에 큰따옴표(&quot;)도 같이 출력하고 싶을때 <code>\&quot;</code>와 같이 \를 사용하여 단순 문자로 의미를 변경한다.</li>
<li>작은따옴표(')를 출력하고 싶을 때에도 <code>\'</code>와 같이 사용한다.</li>
<li><code>\</code>도 키워드로 사용되기 때문에 \를 출력하고 싶을 때는 <code>\\</code>와 같이 두 개를 연속해서 사용한다.</li>
<li>이와 마찬가지 방법으로 %를 출력하고 싶을 때도 <code>%%</code>라고 두 개를 연속해서 사용하면 된다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-연산자"><a class="header" href="#7-연산자">7. 연산자</a></h1>
<h2 id="7-1-기본-연산자"><a class="header" href="#7-1-기본-연산자">7-1. 기본 연산자</a></h2>
<h3 id="대입-연산자"><a class="header" href="#대입-연산자">대입 연산자</a></h3>
<ul>
<li>C 언어에서 대입 연산자는 <code>=</code> 기호로 나타내며 변수에 상수 값 또는 다른 변수 값을 대입할 떄 사용한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data1, data2;
    data1 = 5;      // data1 변수에 상수 5를 대입함
    data2 = data1;  // data2 변수에 data1 변수 값 5를 대입함
    printf(&quot;data1 = %d, data2 = %d\n&quot;, data1, data2);
}
</code></pre>
<pre><code class="language-text">data1 = 5, data2 = 5
</code></pre>
<h3 id="산술-연산자"><a class="header" href="#산술-연산자">산술 연산자</a></h3>
<ul>
<li>+, -, *, /, %는 산술 연산자로 각각 더하기, 빼기, 곱하기, 나누기, 나머지 연산을 뜻한다.</li>
<li>나눗셈의 경우에는 결과 값이 몫과 나머지로 나오기 때문에 몫은 <code>/</code>연산자를 이용하여 구하고 나머지는 <code>%</code>연산자를 사용하여 구한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data1 = 5, data2 = 3;     // 두 변수의 초기값을 5와 3으로 설정함

    int result1 = data1 + data2;  // 덧셈
    int result2 = data1 * data2;  // 곱셈
    int result3 = data1 / data2;  // 나눗셈(몫)
    int result4 = data1 % data2;  // 나눗셈(나머지)

    printf(&quot;result : %d, %d, %d, %d\n&quot;, result1, result2, result3, result4);
}
</code></pre>
<pre><code class="language-text">result : 8, 15, 1, 2
</code></pre>
<h3 id="증감-연산자"><a class="header" href="#증감-연산자">증감 연산자</a></h3>
<ul>
<li>컴퓨터에서는 값이 순차적으로 증가하거나 감소하는 경우가 많다.</li>
<li>C 언어에서는 변수가 가지고 있는 값을 1 증가시키는 <code>++</code>증가 연산자와 1 감소시킬 수 있는 <code>--</code>감소 연산자를 제공한다.</li>
<li>덧셈 연산자(이항 연산자)</li>
</ul>
<pre><code class="language-c">int i = 5;
i = i + 1;  // i값에 1을 더하고 다시 i에 대입됨
</code></pre>
<ul>
<li>증가 연산자(단항 연산자)</li>
</ul>
<pre><code class="language-c">int i = 5;
i++;  // i값을 1 증가시킴. i에 6이 대입됨
</code></pre>
<ul>
<li>결과적으로 두 방법 모두 i 값이 6이 되는 것은 같다.</li>
<li>하지만 덧셈 연산자는 2개의 항을 갖는 이항 연산자이므로 두 개의 메모리가 연산에 사용되고, 증가 연산자는 단항 연산자이기 때문에 한 개의 메모리만 연산에 사용된다.</li>
<li>결과적으로 한 개의 메모리만 사용하는 단항 연산자의 연산 속도가 더 빠르다.</li>
<li>그리고 코드 구성도 간단해지기 때문에 단순히 1을 증가시키거나 1을 감소시킬 목적이라면 증감 연산자를 사용하는 것이 더 좋다.</li>
</ul>
<h4 id="증감-연산자의-전위형과-후위형"><a class="header" href="#증감-연산자의-전위형과-후위형">증감 연산자의 전위형과 후위형</a></h4>
<ul>
<li>증감 연산자는 다른 연산자들과 달리 변수 앞뒤에 사용할 수도 있다.</li>
<li>예를 들어 <code>i++</code>(후위형, Postfix)도 가능하지만 <code>++i</code>(전위형, Prefix)도 가능하다는 뜻이다.</li>
<li>이는 <code>--</code>도 마찬가지이다.</li>
<li>전위형과 후위형 모두 자기 자신이 1 증가 또는 1 감소하는 것은 같지만, 추가로 함께 연산을 하는 다른 연산자가 있는 경우에는 결과 값이 달라질 수도 있다.</li>
<li>전위형</li>
</ul>
<pre><code class="language-c">int i = 5, sum;
sum = ++i;
// 자신의 값을 먼저 증가시켜 6을 만든 뒤 sum에 6을 대입함. i와 sum 모두 6이 됨
</code></pre>
<ul>
<li>후위형</li>
</ul>
<pre><code class="language-c">int i = 5, sum;
sum = i++;
// i의 값 5를 sum에 먼저 대입하고 i를 증가시킴. i는 6이고 sum은 5가 됨
</code></pre>
<ul>
<li>즉 전위형의 경우 값을 먼저 증감한 후에 연산을 하고 후위형은 연산을 하고 난 후에 값을 증감하는 것을 알 수 있다.</li>
</ul>
<h3 id="관계-연산자"><a class="header" href="#관계-연산자">관계 연산자</a></h3>
<ul>
<li>산술 연산(Arithmetic Operation)이 결과 값은 숫자로 나오지만, 관계 연산(Relational Operation)이나 논리 연산(Logical Operation)이 결과 값은 진리값(참, 거짓)
으로 나온다.</li>
<li>예를 들어 '1과 2는 같다'라는 문장은 관계 연산이 사용된 것이고 실제로 1과 2는 같지 않기 때문에 이 문장에 대한 결과 값은 거짓이 된다.</li>
<li>그런데 컴퓨터가 연산의 결과 값을 '참', '거짓'과 같은 문자열로 저장한다면 연산 속도가 떨어질 것이다.</li>
<li>따라서 관계 연산의 결과 값은 참이면 1, 거짓이면 0으로 처리된다.</li>
<li>관계 연산자를 사용하면 두 수치 값을 비교하여 그 결과 값을 참(1) 또는 거짓(0)으로 얻을 수 있으며 종류는 다음과 같다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>관계 연산자</th><th>연산 특성</th></tr></thead><tbody>
<tr><td>A &lt; B</td><td>A가 B보다 작으면 참</td></tr>
<tr><td>A &gt; B</td><td>A가 B보다 크면 참</td></tr>
<tr><td>A &lt;= B</td><td>A가 B보다 작거나 같으면 참</td></tr>
<tr><td>A &gt;= B</td><td>A가 B보다 크거나 같으면 참</td></tr>
<tr><td>A == B</td><td>A와 B가 같으면 참</td></tr>
<tr><td>A != B</td><td>A와 B가 같지 않으면 참</td></tr>
</tbody></table>
</div>
<ul>
<li>C 문버에서 '같다'라는 관계 연산자는 =를 두 개 사용하여 <code>==</code>라고 적는다.</li>
<li>또한 '같지 않다'는 관계를 나타내는 연산자는 <code>!=</code>이다.</li>
<li><code>!</code>(논리 연산자)는 부정(Not)을 의미하기 때문에 =앞에 적어 '같지 않다'라는 관계 연산자를 만든다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data1 = 5, data2 = 3;      // 두 변수에 초기값을 5와 3으로 설정함

    // 관계 연산 테스트
    int result1 = data1 &gt; 7;       // 5는 7보다 작으므로 거짓
    int result2 = data2 &lt;= data1;  // 3은 5보다 작으므로 참
    int result3 = data2 == 7;      // 3은 7과 같지 않으므로 거짓
    int result4 = data2 != data1;  // 3은 5와 다르므로 참

    // 관계 연산의 결과 값은 0 또는 1임
    printf(&quot;result : %d, %d, %d, %d\n&quot;, result1, result2, result3, result4);
}
</code></pre>
<pre><code class="language-text">result : 0, 1, 0, 1
</code></pre>
<h3 id="논리-연산자"><a class="header" href="#논리-연산자">논리 연산자</a></h3>
<ul>
<li>A와 B의 상황을 일정한 규칙(AND, OR, NOT)으로 연결해주는 연산자가 '논리 연산자'이고 A와 B는 진리값(참, 거짓)을 사용한다.</li>
<li>논리 연산자도 관계 연산자처럼 연산의 결과 값은 참(1) 또는 거짓(0)으로 나온다.</li>
<li>하지만 연산할 때 사용하는 숫자가 0, 1만 존재하는 것은 아니기 때문에, 0만 거짓으로 간주하고 0이 아닌 모든 값을 '참'으로 판단한다.</li>
<li>C 언어에서 논리 연산자 AND는 <code>&amp;&amp;</code>키워드를, OR는 <code>||</code>키워드를, NOT은 <code>!</code>키워드를 사용한다.</li>
<li>AND 연산자와 OR 연산자는 이항 연산자이고 NOT 연산자는 단항 연산자이다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>A</th><th>B</th><th>A AND B 연산</th><th>A OR B 연산</th><th>NOT A 연산</th></tr></thead><tbody>
<tr><td>거짓(0)</td><td>거짓(0)</td><td>거짓(0)</td><td>거짓(0)</td><td>참(1)</td></tr>
<tr><td>거짓(0)</td><td>참(1)</td><td>거짓(0)</td><td>참(1)</td><td>참(1)</td></tr>
<tr><td>참(1)</td><td>거짓(0)</td><td>거짓(0)</td><td>참(1)</td><td>거짓(1)</td></tr>
<tr><td>참(1)</td><td>참(1)</td><td>참(1)</td><td>참(1)</td><td>거짓(1)</td></tr>
</tbody></table>
</div>
<ul>
<li>연산 규칙을 정리해 보면 다음과 같다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>논리 연산자</th><th>연산 특정</th></tr></thead><tbody>
<tr><td>AND</td><td>A와 B가 모두 참이어야 결과 값이 참(1), 하나라도 거짓이면 결과 값은 거짓(0)</td></tr>
<tr><td>OR</td><td>A 또는 B가 참이면 결과 값이 참(1), 둘 다 거짓일 때만 결과 값이 거짓(0)</td></tr>
<tr><td>NOT</td><td>A가 거짓이면 결과 값이 참(1), A가 참이면 결과 값이 거짓(0)</td></tr>
</tbody></table>
</div>
<ul>
<li>AND 연산의 특징은 연산에 참여하는 A, B 진리값이 둘 다 참(1)이어야 결과 값이 참(1)이 나오고,</li>
<li>OR 연산의 특징은 A, B 진리값이 둘 다 거짓(0)인 경우에만 결과 값이 거짓(0)이 나온다.</li>
<li>NOT 연산은 현재 가지고 있는 진리값이 반전(거짓(0)이면 참(1), 참(1)이면 거짓(0))된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data1 = 5, data2 = 3;  // 두 변수에 초기값을 5와 3으로 설정

    // OR 연산자
    int result1 = 0 || 1;

    // AND 연산자. 3 &amp;&amp; -1 은 1 &amp;&amp; 1과 같기 때문에 결과 값은 참
    int result2 = 3 &amp;&amp; -1;

    // OR 연산자. data1 == 3은 거짓, data2 == 3은 참
    int result3 = data1 == 3 || data2 == 3;

    // AND 연산자. data1 == 3은 거짓, data2 == 3은 참
    int result4 = data1 == 3 &amp;&amp; data2 == 3;

    // data1은 0이 아니라서 참. 참에 NOT 연산을 하면 거짓
    int result5 = !data1;

    // 관계 연산의 결과 값은 0 또는 1
    printf(&quot;result : %d, %d, %d, %d, %d\n&quot;, result1, result2, result3, result4, result5);
}
</code></pre>
<pre><code class="language-text">result : 1, 1, 1, 0, 0
</code></pre>
<blockquote>
<h4 id="논리-연산자의-특성을-이용해-조건-수식-구성하기"><a class="header" href="#논리-연산자의-특성을-이용해-조건-수식-구성하기">논리 연산자의 특성을 이용해 조건 수식 구성하기</a></h4>
<ul>
<li>논리 연산자는 A, B 진리값을 사용하여 AND 와 OR 연산을 수행할 때 A만으로도 연산 결과를 판단할 수 있는 경우에는 B를 수행하지 않는다.</li>
<li>예를 들어 <code>A &amp;&amp; B</code>연산에서 A가 거짓(0)이면 B의 진리값을 보지 않고도 결과 값이 거짓임을 알 수 있고, <code>A || B</code>연산에서 A가 참(1)이면 B의 진리값을 몰라도 결과 값이 참 임을 알 수
있다.</li>
</ul>
<pre><code class="language-c">data &gt; 3 &amp;&amp; data++;
</code></pre>
<ul>
<li><code>data</code>값이 3보다 큰 경우
&gt;</li>
</ul>
</blockquote>
<ul>
<li>이 수식은 <code>data</code>가 3보다 큰 값을 가지면 A 연산(<code>data &gt; 3</code>)이 참이 된다.</li>
</ul>
<blockquote>
<ul>
<li>따라서 B 연산(<code>data++</code>)이 참인지 거짓인지에 따라 논리 연산자의 결과 값이 달라지기 때문에 <code>data++</code>연산이 무조건 수행된다.
<ul>
<li>즉 <code>data</code>가 5일 때 위 명령문을 수행하고 나면 <code>data</code>는 6이 된다.</li>
</ul>
</li>
<li><code>data</code>값이 3보다 작거나 같은 경우
&gt;</li>
</ul>
</blockquote>
<ul>
<li>반대로 <code>data</code>가 3보다 작거나 같다면 A 연산이 거짓이 되어 B 연산을 확인해보지 않아도 결과 값은 거짓이 된다.</li>
</ul>
<blockquote>
<ul>
<li>따라서 <code>data++</code>는 수행되지 않는다.
<ul>
<li>즉 <code>data</code>가 2일 때 위 명령문을 수행하고 나면 <code>data</code>는 여전히 2이다.</li>
</ul>
</li>
</ul>
<pre><code class="language-c">data &gt; 3 || data++;
</code></pre>
<ul>
<li><code>data</code>값이 3보다 큰 경우
&gt;</li>
</ul>
</blockquote>
<ul>
<li>이 수식은 <code>data</code>가 3보다 큰 값을 가지면 A 연산(<code>data &gt; 3</code>)이 참이 되어 B 연산(<code>data++</code>)을 확인해보지 않아도 결과 값이 참이 된다.</li>
</ul>
<blockquote>
<ul>
<li>따라서 <code>data++</code>는 수행되지 않는다.
<ul>
<li>즉 <code>data</code>가 5일 때 위 명령문을 수행하고 나면 <code>data</code>는 여전히 5이다.</li>
</ul>
</li>
<li><code>data</code>값이 3보다 작거나 같은 경우
&gt;</li>
</ul>
</blockquote>
<ul>
<li>반대로 <code>data</code>가 3보다 작거나 같다면 A 연산이 거짓이 되어 B 연산이 참인지 거짓인지에 따라 논리 연산자의 결과 값이 달라지기 때문에 <code>data++</code>연산이 수행된다.</li>
</ul>
<blockquote>
<ul>
<li>즉 <code>data</code>가 2일 때 위 명령문을 수행하고 나면 <code>data</code>는 3이 된다.</li>
</ul>
</blockquote>
<h2 id="7-2-연산자-우선순위와-연산-방향"><a class="header" href="#7-2-연산자-우선순위와-연산-방향">7-2. 연산자 우선순위와 연산 방향</a></h2>
<h3 id="연산자-우선순위란"><a class="header" href="#연산자-우선순위란">연산자 우선순위란?</a></h3>
<ul>
<li>연산자 우선순위는 하나의 수식에서 연산자를 여러 개 사용했을 때, 어떤 연산자를 먼저 연산할 것인지 정해 놓은 것이다.</li>
<li>다음은 C 언어 연산자들의 우선순위를 정리한 표이다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>순위</th><th>종류</th><th>연산자</th><th>연산방향</th></tr></thead><tbody>
<tr><td>1</td><td>괄호, 배열, 구조체</td><td>()(후위 증가) . [](후위 감소) -&gt;</td><td>→</td></tr>
<tr><td>2</td><td>단항 연산자</td><td>(자료형) *(간접) &amp;(주소) ! ~(비트 NOT) ++ -- +(부호) -(부호) sizeof</td><td>←</td></tr>
<tr><td>3</td><td>승제 연산자</td><td>* / %</td><td>→</td></tr>
<tr><td>4</td><td>가감 연산자</td><td>+ -</td><td>→</td></tr>
<tr><td>5</td><td>시프트(Shift) 연산자</td><td>&lt;&lt; &gt;&gt;</td><td>→</td></tr>
<tr><td>6</td><td>비교 연산자</td><td>&lt; &lt;= &gt; &gt;=</td><td>→</td></tr>
<tr><td>7</td><td>등가 연산자</td><td>== !=</td><td>→</td></tr>
<tr><td>8</td><td>비트 연산자 AND</td><td>&amp;</td><td>→</td></tr>
<tr><td>9</td><td>비트 연산자 XOR</td><td>^</td><td>→</td></tr>
<tr><td>10</td><td>비트 연산자 OR</td><td>¦</td><td>→</td></tr>
<tr><td>11</td><td>논리 연산자 AND</td><td>&amp;&amp;</td><td>→</td></tr>
<tr><td>12</td><td>논리 연산자 OR</td><td>¦¦</td><td>→</td></tr>
<tr><td>13</td><td>조건 연산자</td><td>? :</td><td>←</td></tr>
<tr><td>14</td><td>대입 연산자</td><td>= *= /= += -= %= &lt;&lt;= &gt;&gt;= &amp;= ^= ¦=</td><td>←</td></tr>
<tr><td>15</td><td>나열 연산자</td><td>,</td><td>→</td></tr>
</tbody></table>
</div>
<h3 id="우선순위가-같은-연산자라면-연산-방향을-확인하자"><a class="header" href="#우선순위가-같은-연산자라면-연산-방향을-확인하자">우선순위가 같은 연산자라면? 연산 방향을 확인하자!</a></h3>
<ul>
<li>연산자 우선순위가 같은 연산자들에 대해서도 어떤 연산자를 먼저 연산할 것인지를 정해 놓았는데, 이것이 '연산 방향'이다.</li>
<li>연산 수식을 구성할 때 연산자의 개별적인 우선순위 외에 연산 방향도 잘 고려해야 한다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-조건문"><a class="header" href="#8-조건문">8. 조건문</a></h1>
<h2 id="8-1-제어문"><a class="header" href="#8-1-제어문">8-1. 제어문</a></h2>
<h3 id="제어문이란"><a class="header" href="#제어문이란">제어문이란?</a></h3>
<ul>
<li>조건에 따라 실행 흐름을 변경할 수 있도록 제어문(Control Statement)이라는 문법을 제공한다.</li>
<li>프로그램은 나열된 명령문을 순차적으로 실행한다.</li>
<li>특정 작업을 반복해서 수행해야 하거나 예외를 처리해야 한다면 명령문을 나열식으로 표현하는 것은 비효율적이고 어려운 작업이 될 것이다.</li>
<li>C 언어에서는 다음과 같은 두 가지 형태의 제어문을 제공한다.</li>
</ul>
<h4 id="조건문-예외-사항에-대처하기-위한-문법"><a class="header" href="#조건문-예외-사항에-대처하기-위한-문법">조건문: 예외 사항에 대처하기 위한 문법</a></h4>
<ul>
<li>조건문은 특정 조건을 부여하고 해당 조건을 만족하면 지정한 문장을 수행하는 문법이다.</li>
<li>일반적으로 조건은 수식으로 표현하며 이 수식의 진리값이 참(1)이면 지정한 문장르 수행하게 된다.</li>
<li>C 언어에서는 <code>if</code>, <code>switch</code>와 같은 문법이 조건문에 해당한다.</li>
</ul>
<h4 id="반복문-반복-행위를-효과적으로-표현하기-위한-문법"><a class="header" href="#반복문-반복-행위를-효과적으로-표현하기-위한-문법">반복문: 반복 행위를 효과적으로 표현하기 위한 문법</a></h4>
<ul>
<li>일정한 형태의 작업을 반복해서 수행해야 할 때 반복 조건을 부여하고, 해당 조건이 거짓이 될 때까지 지정한 문장을 계속 수행하는 문법이다.</li>
<li>C 언어에서는 <code>for</code>, <code>while</code>, <code>do ~ while</code>과 같은 문법이 반복문에 해당한다.</li>
</ul>
<h2 id="8-2-if-조건문"><a class="header" href="#8-2-if-조건문">8-2. if 조건문</a></h2>
<h3 id="if-조건문의-구조"><a class="header" href="#if-조건문의-구조">if 조건문의 구조</a></h3>
<ul>
<li><code>if</code> 조건문은 문법 구성이 간단하고 직관적인 표현을 사용하기 때문에 다른 조건문에 비해 많이 사용한다.</li>
</ul>
<pre><code class="language-c">if(조건 수식) 명령문;
</code></pre>
<ul>
<li><code>if</code> 조건문은 <code>if ~ else</code> 조건문에서 <code>else</code>가 생략된 형태이다.</li>
<li>()괄호 안에 있는 조건 수식의 결과 값이 참으로 나오면 그 뒤에 명시한 명령문 1개를 수행하는 문법이다.</li>
<li>여기에서 참은 0이 아닌 모든 값을 의미한다.</li>
<li>C 언어에서는 명령문이 단일 명령문과 복합 명령문으로 나뉘어 있기 때문에 <code>if</code>문은 단일 문장을 수행하는 <code>if</code>문과 복합 문장을 수행하는 <code>if</code>문의 형태로 사용하게 된다.</li>
</ul>
<h3 id="단일-문장을-수행하는-if-조건문"><a class="header" href="#단일-문장을-수행하는-if-조건문">단일 문장을 수행하는 if 조건문</a></h3>
<ul>
<li>조건 수식의 결과 값이 참일 때 하나의 단일 명령문만 수행한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data = 5;  // 명령문 1
    if (data &gt; 3) printf(&quot;data는 3보다 큰 수 입니다.\n&quot;);  // 명령문 2
    printf(&quot;작업 종료\n&quot;);  // 명령문 3
}
</code></pre>
<pre><code class="language-text">data는 3보다 큰 수 입니다.
작업 종료
</code></pre>
<h3 id="복합-문장을-수행하는-if-조건문"><a class="header" href="#복합-문장을-수행하는-if-조건문">복합 문장을 수행하는 if 조건문</a></h3>
<ul>
<li>조건 수식의 결과 값이 참일 때 {}로 모아 놓은 명령문들을 모두 수행한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int score = 92;  // 명령문 1-1
    char grade;  // 명령문 1-2

    // score &gt;= 90 비교 연산의 결과 값은 참이기 때문에 {}에 포함된 명령문들을 모두 수행함
    if (score &gt;= 90) {
        grade = 'A'; // 명령문 2
        printf(&quot;점수는 %d이고 등급은 %c입니다.\n&quot;, score, grade);  // 명령문 3
    }
    
    printf(&quot;작업 종료\n&quot;);  // 명령문 4
}
</code></pre>
<pre><code class="language-text">점수는 92이고 등급은 A입니다.
작업 종료
</code></pre>
<h3 id="if-조건문을-사용할-때-주의-사항"><a class="header" href="#if-조건문을-사용할-때-주의-사항">if 조건문을 사용할 때 주의 사항</a></h3>
<ul>
<li><code>if</code>조건문을 사용할 때 대입 연산자와 관계 연산자를 혼동하거나 세미콜론으로 인한 오류에 주의해야 한다.</li>
</ul>
<h4 id="대입-연산자와-관계-연산자의-혼동"><a class="header" href="#대입-연산자와-관계-연산자의-혼동">대입 연산자와 관계 연산자의 혼동</a></h4>
<ul>
<li>대입 연산자를 잘못 사용한 예</li>
</ul>
<pre><code class="language-c">int data = 5;
if(data = 3) {
    // data는 3에서 4가 됨
    data++;
}
// 최종 data 값은 4
</code></pre>
<blockquote>
<h4 id="오류를-줄이는-프로그래밍-습관"><a class="header" href="#오류를-줄이는-프로그래밍-습관">오류를 줄이는 프로그래밍 습관!</a></h4>
<ul>
<li>버그가 발생하지 않도록 습관 자체를 바꾸는 것이 좋다.</li>
<li>예를 들어 비교 연산 버그는 다음과 같이 상수를 먼저 사용하는 습관을 들이면 해결할 수 있다.</li>
</ul>
<pre><code class="language-c">if(3 == data) // 관계 연산자 == 앞에 상수 3을 먼저 입력함
</code></pre>
<ul>
<li>이렇게 하면 다음처럼 실수를 하더라도 '상수에 값을 대입할 수 없다'는 문법 오류가 발생하여 잘못된 부분을 바로 찾아서 수정할 수 있다.</li>
</ul>
<pre><code class="language-c">if(3 = data) // 문법 오류 발생: 3은 상수이기 때문에 값을 대입할 수 없음
</code></pre>
<ul>
<li>그리고 상수를 먼저 사용하는 습관은 수치 연산을 할 때도 좋다.</li>
<li>예를 들어 <code>data + 4 + 7</code>이라고 하는 것과 <code>4 + 7 + data</code>라고 하는 것은 얼핏 같아 보이지만 기계어로는 다르게 번역된다.</li>
<li><code>data + 4 + 7</code>은 <code>((data + 4) + 7)</code>을 의미하기 때문에 두 개의 덧셈 연산으로 번역되지만, <code>4 + 7 + data</code>는 컴파일러가 <code>11 + data</code>로 바꾸고 번역하기 때문에 한
개의 덧셈 연산으로 번역되어 더 효율적이다.</li>
</ul>
</blockquote>
<h4 id="세미콜론으로-인한-오류"><a class="header" href="#세미콜론으로-인한-오류">세미콜론으로 인한 오류</a></h4>
<ul>
<li>단일 문장에서 잘못 사용</li>
</ul>
<pre><code class="language-c">int data = 3;
if(data &gt; 3);
    data++;  // data가 3이어야 하는데 4가 됨
</code></pre>
<ul>
<li>복합 문장에서 잘못 사용</li>
</ul>
<pre><code class="language-c">int data = 3;
int result = 0;
if(data &gt; 3);
{
    data++;
    result = data;  // data가 3이어야 하는데 4가 됨
}
</code></pre>
<ul>
<li>{ 괄호를 조건 수식 뒤에 바로 적는 습관을 들이는 것이 좋다.</li>
<li>이렇게 하면 ;(세미콜론)을 잘못 찍을 수 없기 때문에 버그가 나올 확률이 줄어들게 된다.</li>
</ul>
<h2 id="8-3-if--else--조건문"><a class="header" href="#8-3-if--else--조건문">8-3. if ~ else ~ 조건문</a></h2>
<ul>
<li>조건문을 사용하다 보면 상황이 서로 반대되는 조건을 나열해야 할 때가 있다.</li>
</ul>
<pre><code class="language-c">if(data == 10) data = 0;  // data == 10이 참이면 data에 0을 저장함
if(data != 10) data++;  // data != 10이 참이면 data값을 1 증가시킴
</code></pre>
<ul>
<li>위와 같이 진리값이 서로 반대되는 경우에 <code>if</code>조건문을 반복해서 쓰는 것은 불필요한 작업이 될 수 있다.</li>
<li>위 소스 코드는 다음과 같이 반대 조건을 한 번에 표현하는 <code>if ~ else ~</code>형식으로 변경할 수 있다.</li>
</ul>
<pre><code class="language-c">if(data == 10) data = 0;
else data++;  // data가 10이 아닌 경우에 수행됨
</code></pre>
<ul>
<li>이렇게 <code>if ~ else ~</code>문을 사용하면 조건 수식은 한 번만 수행된다.</li>
</ul>
<h3 id="단일-if--else--문"><a class="header" href="#단일-if--else--문">단일 if ~ else ~ 문</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int data = 5;  // 명령문 1
    if (3 &lt; data) printf(&quot;data는 3보다 큰 수입니다.\n&quot;);  // 명령문 2
    else printf(&quot;data는 3보다 작거나 같은 수입니다.\n&quot;);  // 명령문 3
    printf(&quot;작업 종료\n&quot;);  // 명령문 4
}
</code></pre>
<pre><code class="language-text">data는 3보다 큰 수입니다.
작업 종료
</code></pre>
<h3 id="복합-if--else--문"><a class="header" href="#복합-if--else--문">복합 if ~ else ~ 문</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int score = 92;  // 명령문 1-1
    char grade;  // 명령문 1-2

    if (90 &lt;= score) {
        grade = 'A';  // 명령문 2
        printf(&quot;점수는 %d이고 등급은 %c입니다.\n&quot;, score, grade);  // 명령문 3
    } else {
        grade = 'B';  // 명령문 4
        printf(&quot;점수는 %d이고 등급은 %c입니다.\n&quot;, score, grade);  // 명령문 5
    }

    printf(&quot;작업 종료\n&quot;);  // 명령문 6
}
</code></pre>
<pre><code class="language-text">점수는 92이고 등급은 A입니다.
작업 종료
</code></pre>
<blockquote>
<h4 id="혹시-직접-값을-입력해서-결과를-출력해보고-싶다"><a class="header" href="#혹시-직접-값을-입력해서-결과를-출력해보고-싶다">혹시 직접 값을 입력해서 결과를 출력해보고 싶다?</a></h4>
<ul>
<li>직접 입력을 받는 방법은 13장에서 배울 '포인터' 문법을 배워야 이해할 수 있다.</li>
<li>코드만 한번 보자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int score;
    char grade;

    printf(&quot;점수를 입력하세요: &quot;);
    scanf(&quot;%d&quot;, &amp;score);  // scanf 함수는 사용자에게 입력 받은 값을 score 변수에 저장한다
                          // scanf 함수는 &amp; 연산자를 반드시 사용해야 한다
    if(90 &lt;= score) {
        grade = 'A';
        printf(&quot;점수는 %d이고 등급은 %c입니다.\n&quot;, score, grade);
    } else {
        grade = 'B';
        printf(&quot;점수는 %d이고 등급은 %c입니다.\n&quot;, score, grade);
    }

    printf(&quot;작업 종료\n&quot;);
}
</code></pre>
</blockquote>
<h3 id="if--else--조건문과-비슷한-조건-수식-연산자"><a class="header" href="#if--else--조건문과-비슷한-조건-수식-연산자">if ~ else ~ 조건문과 비슷한 조건 수식 연산자</a></h3>
<ul>
<li>조건 수식 연산자(Conditional-expression Operator)는 <code>if ~ else ~</code>조건문과 비슷한 형태를 가지는 연산 수식이다.</li>
<li>하지만 조건문과 달리 조건 수식 연산자는 연산자이기 때문에 명령을 처리하고 나면 결과 값을 반환하는 형태로 되어 있다.</li>
<li>즉 조건 수식의 결과 값이 참이면 수식1의 결과 값을 사용하고 거짓이면 수식2의 결과 값을 사용한다.</li>
</ul>
<pre><code class="language-text">결과 값 = (조건 수식) ? 수식1 : 수식2 ;
</code></pre>
<ul>
<li>조건 수식 연산자와 <code>if ~ else ~</code> 조건문과 다른 점은 조건 수식이 결과 값이 참이 되면 '결과 값 = 수식1'이 되고 거짓이 되면 '결과 값 = 수식2'가 된다는 점이다.</li>
<li>단순히 수식만 연산하는 것이 아니라 그 연산의 결과 값을 최종 반환하는 형태로 되어 있다.</li>
<li>value 값이 10000이상이면 value값에 0.1을 곱해서 point에 저장하고 value값이 10000보다 작으면 value값에 0.05를 곱해서 point에 저장하는 코드</li>
</ul>
<pre><code class="language-c">if(10000 &lt;= value) point = value * 0.1;
else point = value * 0.05;
</code></pre>
<pre><code class="language-c">// 반환된 연산 결과 값을 point에 저장함
point = (10000 &lt;= value) ? value * 0.1 : value * 0.05;
</code></pre>
<ul>
<li>data가 5보다 크면 1을 반환하고 data가 5보다 작거나 같으면 0을 반환하는 코드</li>
</ul>
<pre><code class="language-c">if(5 &lt; data) return 1;  // data가 5보다 크면 1을 반환함
else return 0;  // data가 5보다 작거나 같으면 0을 반환함
</code></pre>
<pre><code class="language-c">return (5 &lt; data) ? 1 : 0;
</code></pre>
<ul>
<li>간결해 보이는 조건 수식 연산자에도 단점은 있다.</li>
<li>'수식1'과 '수식2'가 값을 반환하는 구조로 되어 있으므로 수식을 단일 문장으로만 표현해야 하고 중괄호 {}를 사용하는 복합 문장은 사용할 수 없다.</li>
</ul>
<h2 id="8-4-중첩된-if-조건문"><a class="header" href="#8-4-중첩된-if-조건문">8-4. 중첩된 if 조건문</a></h2>
<ul>
<li><code>if</code>조건문을 사용하다 보면 조건 수식이 만족되어 실행하는 명령문안에 또 조건문이 포함되는 경우가 있는데, 이런 상황을 조건문이 중첩되었다고 한다.</li>
<li>중첩의 개수 제한은 없지만, 너무 많이 중첩되면 프로그램의 수행 능력이 떨어지고 이해하기도 어려워지기 때문에 알고리즘을 잘 만들어서 작업해야 한다.</li>
</ul>
<h3 id="중첩된-if-문"><a class="header" href="#중첩된-if-문">중첩된 if 문</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    // 2022년 12월 31일을 3개의 정수 변수에 나누어서 대입함
    int year = 2022, month = 12, day = 31;

    // 일을 하루 증가시키면 day가 31에서 32가 됨
    day++;

    // 일이 31일을 초과하면 1일로 바꾸고 월을 증가시킴
    if (31 &lt; day) {
        month++;  // 월을 증가시키면 month가 12에서 13이 됨
        day = 1;  // 월이 증가되었으니 해당 월의 처음인 1일로 변경함

        // 월이 12월을 초과하면 1월로 바꾸고 연도를 증가시킴
        if (12 &lt; month) {
            year++;  // 연도를 1년 증가시키면 year가 2022에서 2023이 됨
            month = 1;  // 연도가 증가되었으니 12월에서 1월로 변경함
        }
    }
    
    printf(&quot;Date : %d년 %d월 %d일\n&quot;, year, month, day);
}
</code></pre>
<pre><code class="language-text">Date : 2023년 1월 1일
</code></pre>
<h3 id="중첩된-if--else--문"><a class="header" href="#중첩된-if--else--문">중첩된 if ~ else ~ 문</a></h3>
<ul>
<li>성적에 따라 A, B, C, D, F 등급으로 나누는 예제</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    // 점수를 86점으로 설정함
    int score = 86;

    // 점수에 따른 등급을 저장할 변수를 선언함
    char grade;

    if (90 &lt;= score) {                 // 90점 이상인 경우
        grade = 'A';
    } else {                           // 90점 보다 작은 경우
        if (80 &lt;= score) {             // 80점 이상이고 90점보다 작은 경우
            grade = 'B';
        } else {                       // 80점보다 작은 경우
            if (70 &lt;= score) {         // 70점 이상이고 80점보다 작은 경우
                grade = 'C';
            } else {                   // 70점보다 작은 경우
                if (60 &lt;= score) {     // 60점 이상이고 70점보다 작은 경우
                    grade = 'D';
                } else {               // 60점보다 작은 경우
                    grade = 'F';
                }
            }
        }
    }

    // 자신의 점수와 등급을 출력함
    printf(&quot;당신의 점수는 %d점이고 등급은 %c입니다.\n&quot;, score, grade);
}
</code></pre>
<pre><code class="language-text">당신의 점수는 86점이고 등급은 B입니다.
</code></pre>
<h3 id="if--else-if--else-조건문"><a class="header" href="#if--else-if--else-조건문">if ~ else if ~ else 조건문</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int score = 86;
    char grade;

    if (90 &lt;= score) grade = 'A';               // 90점 이상
    else {
        if (80 &lt;= score) grade = 'B';           // 80 &lt;= score &lt; 90
        else {
            if (70 &lt;= score) grade = 'C';       // 70 &lt;= score &lt; 80
            else {
                if (60 &lt;= score) grade = 'D';   // 60 &lt;= score &lt; 70
                else grade = 'F';               // 60점보다 작은 경우
            }
        }
    }

    printf(&quot;당신의 점수는 %d점이고 등급은 %c입니다.\n&quot;, score, grade);
}
</code></pre>
<pre><code class="language-text">당신의 점수는 86점이고 등급은 B입니다.
</code></pre>
<ul>
<li>단일 문장으로 변경한 후 소스 코드를 파익하기 좀 더 편해졌고, 소스도 줄어들었다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int score = 86;
    char grade;

    if (90 &lt;= score) grade = 'A';          // 90점 이상
    else if (80 &lt;= score) grade = 'B';     // 80 &lt;= score &lt; 90
    else if (70 &lt;= score) grade = 'C';     // 70 &lt;= score &lt; 80
    else if (60 &lt;= score) grade = 'D';     // 60 &lt;= score &lt; 70
    else grade = 'F';                      // 60점보다 작은 경우
    printf(&quot;당신의 점수는 %d점이고 등급은 %c입니다.\n&quot;, score, grade);
}
</code></pre>
<pre><code class="language-text">당신의 점수는 86점이고 등급은 B입니다.
</code></pre>
<ul>
<li>위와 같이 <code>if ~ else ~</code>문을 중첩해서 사용하면 첫 <code>if</code>에서 마지막 <code>else</code>사이에 있는 조건문들이 서로 배타적인 조건이 되어서 이 조건들 중에서 한 개만 선택되는 특성이 있다.</li>
<li>조건문 중 가장 위에 있는 <code>90 &lt;= score</code>이라는 조건 수식이 먼저 처리되고 이 조건 수식의 결과 값이 참이면 나머지 연결된 조건 수식은 처리되지 않고 바로 <code>printf</code>문으로 이동한다.</li>
<li>위쪽에서 아래쪽으로 수식의 참·거짓 여부를 판단하고 수행하기 때문에 사용 빈도가 높은(결과 값이 참일 가능성이 높은) 조건 수식을 위쪽에 사용하는 것이 좋다.</li>
</ul>
<h2 id="switch-조건문"><a class="header" href="#switch-조건문">switch 조건문</a></h2>
<h3 id="if문이-비효율적일-경우"><a class="header" href="#if문이-비효율적일-경우">if문이 비효율적일 경우</a></h3>
<ul>
<li>C 언어에서는 모든 조건문을 <code>if</code>문으로 표현할 수 있기 때문에 <code>if</code>문만 사용해도 문제는 없다.</li>
<li>하지만 특정상황에서는 비효율적일 수 있다.</li>
<li>만약 성적이 61점이었다면 조건 수식이 4개나 수행되는 경우가 된다.</li>
<li>이 조건문의 구성을 보면 <code>score</code>변수 값을 계속 특정 상수 값과 비교하여 조건을 판단하고 수행하는 과정에서 <code>score</code>값은 변하지 않는다는 것을 알 수 있다.</li>
<li>이와 같이 정해진 상수와 조건을 비교하는 경우 <code>switch</code>조건문이 더 효율적이다.</li>
</ul>
<h3 id="switch-조건문의-기본-구조"><a class="header" href="#switch-조건문의-기본-구조">switch 조건문의 기본 구조</a></h3>
<ul>
<li><code>switch</code>조건문은 정해진 상수들과 직접적인 비교를 할 수 있는 문법 구조로 되어 있다.</li>
<li><code>switch</code>조건문은 조건 수식을 포함한 모든 수식을 사용할 수 있으며 그 수식을 처리하여 얻은 결과 값을 각 <code>case</code>문에 있는 상수 값과 비교하여 명령문을 수행한다.</li>
</ul>
<h4 id="switch문을-빠져-나오는-break문"><a class="header" href="#switch문을-빠져-나오는-break문">switch문을 빠져 나오는 break문</a></h4>
<ul>
<li><code>case</code>문은 기본적으로 <code>break</code>문을 포함한다.</li>
<li><code>break</code>문은 현재 수행되는 <code>case</code>문의 작업을 중단하겠다는 뜻이다.</li>
<li>하지만 꼭 <code>break</code>문을 사용해야 하는 것은 아니다.</li>
<li>의도에 따라서 <code>break</code>문을 생략하는 경우도 있는데 이 경우 <code>break</code>문이 나올 때까지 계속 아래로 내려오면서 명령문을 수행한다.</li>
</ul>
<h4 id="조건-수식과-일치하는-case-상수가-없으면-수행하는-default문"><a class="header" href="#조건-수식과-일치하는-case-상수가-없으면-수행하는-default문">조건 수식과 일치하는 case 상수가 없으면 수행하는 default문</a></h4>
<ul>
<li><code>default</code>문은 수식의 결과 값이 <code>case</code>문을 사용해 열거한 상수들과 일치하는 값이 없는 경우에 수행할 명령을 적는 곳이다.</li>
<li><code>default</code>문은 반드시 사용해야 하는 것이 아니기 때문에 사용할 필요가 없으면 생략할 수 있다.</li>
<li><code>default</code>문을 사용하는 위치도 항상 마지막일 필요는 없고, <code>case</code>문과 <code>case</code>문 사이에 둘 수도 있다.</li>
</ul>
<h3 id="switch-조건문과-if--else-if--else문-비교"><a class="header" href="#switch-조건문과-if--else-if--else문-비교">switch 조건문과 if ~ else if ~ else문 비교</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int score = 86;
    char grade;

    // 등급을 결정하는 점수가 10단위로 달라지기 때문에 10으로 나눈 몫을 이용하면 특정 숫자와 비교하도록 변경할 수 있다.
    switch (score / 10) {
        case 10:
        case 9:
            grade = 'A';
            break;
        case 8:
            grade = 'B';
            break;
        case 7:
            grade = 'C';
            break;
        case 6:
            grade = 'D';
            break;
        default:
            grade = 'F';
            break;
    }

    printf(&quot;당신의 점수는 %d점이고 등급은 %c입니다.\n&quot;, score, grade);
}
</code></pre>
<ul>
<li>지금 같은 경우에는 <code>switch</code>문이 연산이 더 적고 간결한 형식으로 나열되어 기계어로 번역하면 더 좋은 기계어 코드가 나온다.</li>
<li><code>switch</code>문은 수식의 결과 값 또는 변수의 값을 여러 개의 상수 값과 비교하는 데 장점이 있다.</li>
<li>하지만 <code>case</code>문에 상수가 아닌 변수를 적을 수 없기 때문에 비교 대상이 상수가 아닌 경우에는 <code>switch</code>문을 사용할 수 없다는 단점이 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-반복문"><a class="header" href="#9-반복문">9. 반복문</a></h1>
<h2 id="9-1-반복문의-기본-구조와-for-반복문"><a class="header" href="#9-1-반복문의-기본-구조와-for-반복문">9-1. 반복문의 기본 구조와 for 반복문</a></h2>
<h3 id="반복-작업에-필요한-세-가지-요소"><a class="header" href="#반복-작업에-필요한-세-가지-요소">반복 작업에 필요한 세 가지 요소</a></h3>
<ul>
<li>반복문(Repetitive Statement)이란 지정한 작업을 반복하여 수행하는 문법이다.</li>
<li>반복을 시작하기 위한 '시작 조건', 반복을 계속 진행할 것인지를 판단하는 '종결 조건', 반복의 조건을 바꾸기 위해 '조건 변화 수식'이 있어야 반복 작업을 제대로 수행할 수 있다.</li>
<li>반복문은 위 세 요소를 어떻게 배치하느냐에 따라서 종류가 나뉜다.</li>
<li>반복의 3요소를 정규화된 형식으로 표현하는 <code>for</code> 반복문, '종결 조건'만 형식으로 갖고 나머지 요소는 자유롭게 배치하는 <code>while</code>반복문 등이 있다.</li>
</ul>
<h3 id="for-반복문의-기본-구조"><a class="header" href="#for-반복문의-기본-구조">for 반복문의 기본 구조</a></h3>
<ul>
<li><code>for</code>반복문은 반복의 3요소(시작 조건, 종결 조건, 조건 변화 수식)를 제일 단순하고 정확하게 표현한 반복문이다.</li>
<li>명확한 구성 때문에 반복문 중에서 제일 많이 사용되고, 특히 시작과 끝이 명확한 반복 작업에 많이 사용된다.</li>
</ul>
<pre><code class="language-c">for(시작 조건; 종결 조건; 조건 변화 수식) 명령문;
</code></pre>
<ul>
<li><code>for</code>반복문은 '시작 조건'에서 시작하며 명령문을 실행하기 전에 항상 '종결 조건'을 체크해서 종결 조건이 참이면 명령문을 수행하고 거짓이면 반복을 끝낸다.</li>
<li>명령문을 수행하고 나면 '조건 변화 수식'을 실행하여 반복 조건을 변경한 후 다시 종결 조건을 체크하는 순서로 반복이 진행된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    // 합한 값을 저장할 sum과 합산에 사용할 숫자를 저장할 num을 선언함
    int sum = 0, num;

    // 1에서 5까지 1씩 증가하면서 반복함
    for (num = 1; num &lt;= 5; num++) {
        // 합산하기 전 sum값을 사용하여 'num + sum = '이라고 출력함
        printf(&quot;num(%d) + sum(%d) = &quot;, num, sum);
        // sum에 num을 더함
        sum = sum + num;
        // 더한 후 sum 값을 출력하고 줄을 바꿈
        printf(&quot;%d\n&quot;, sum);
    }

    // 반복이 끝나면 줄을 바꾼 후 num 변수 값과 sum 변수 값을 출력함
    printf(&quot;\nResult : num = %d  sum = %d\n&quot;, num, sum);
}
</code></pre>
<pre><code class="language-text">num(1) + sum(0) = 1
num(2) + sum(1) = 3
num(3) + sum(3) = 6
num(4) + sum(6) = 10
num(5) + sum(10) = 15

Result : num = 6  sum = 15
</code></pre>
<h3 id="for-반복문의-변형과-이해"><a class="header" href="#for-반복문의-변형과-이해">for 반복문의 변형과 이해</a></h3>
<ul>
<li><code>for</code>반복문이 반복의 3요소(시작 조건, 종결 조건, 조건 변화 수식)를 사용할 수 있도록 기본적인 형식을 제공하지만 그 형식을 꼭 지켜야 하는 것은 아니다.</li>
<li>3요소를 모두 사용할 필요가 없는 경우에는 해당 부분을 비워두어도 된다.</li>
<li>반대로 시작 조건에 ,(쉼표)를 이용하여 여러 개의 변수를 초기화할 수도 있다.</li>
</ul>
<pre><code class="language-c">// 더한 값을 저장할 sum과 합산에 사용할 숫자를 저장할 num을 선언함
int sum = 0, num;
for(num = 1; num &lt;= 5; num++) { ... }
</code></pre>
<pre><code class="language-c">int sum = 0, num = 1;  // 변수 선언 시점에 num = 1;을 넣어 초기화함
for( ; num &lt;= 5; num++) { ... }
</code></pre>
<pre><code class="language-c">int sum, num;  // 변수 선언 시점에 sum, num을 초기화하지 않음
// 반복문 시작 조건에 두 변수에 각각 값을 대입함
for(sum = 0, num = 1; num &lt;= 5; num++) { ... }
</code></pre>
<h3 id="for-반복문으로-무한-루프-만들기"><a class="header" href="#for-반복문으로-무한-루프-만들기">for 반복문으로 무한 루프 만들기</a></h3>
<ul>
<li>무한 반복문(무한 루프, Infinite Loop)은 말 그대로 무한히 반복하는 형태의 반복문을 의미한다.</li>
<li>'무한히 반복한다'는 뜻은 종결 조건이 없거나 항상 참(1)인 경우를 의미한다.</li>
<li>이러한 무한 루프는 종결 조건이 분명하지 않거나 종결 조건이 여러 가지인 경우에 사용하기도 한다.</li>
<li><code>for</code>반복문에 <code>for( ; ; )</code>와 같이 반복의 3요소를 모두 안 적는 경우도 있는데 이렇게 사용하면 무한 루프가 된다.</li>
<li><code>for</code>문 안의 조건식이 비워지면 무조건 참으로 인식되어 무한 루프를 만들게 된다.</li>
<li><code>for</code>반복문 안에서 <code>break</code>문을 사용하면 반복문을 빠져나올 수 있다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int sum = 0;
    int num = 1;  // 시작 조건
    for (;;) {  // 무한 루프를 만드는 for 반복문
        // 합산하기 전 sum 값을 사용하여 &quot;num + sum = &quot;이라고 출력함
        printf(&quot;num(%d) + sum(%d) = &quot;, num, sum);
        // sum에 num을 합산함
        sum = sum + num;
        // 합산 후 sum 값을 출력하고 줄을 바꿈
        printf(&quot;%d\n&quot;, sum);
        num++;  // 조건 변화 수식
        if (num &gt; 5) break;  // 종결 조건 num &gt; 5가 참이면 반복문 종료
    }
    printf(&quot;\nResult : num = %d  sum = %d\n&quot;, num, sum);
}
</code></pre>
<pre><code class="language-text">num(1) + sum(0) = 1
num(2) + sum(1) = 3
num(3) + sum(3) = 6
num(4) + sum(6) = 10
num(5) + sum(10) = 15

Result : num = 6  sum = 15
</code></pre>
<ul>
<li>반복의 3요소를 적절하게 사용한다면, <code>for</code>반복문의 형식을 지키지 않아도 반복 작업이 잘 이루어진다.</li>
<li>하지만 보통 무한 루프는 시작과 종결을 수치로 결정할 수 없는 상황에 사용한다.</li>
<li>예를 들어 사용자가 키보드를 이용하여 특정 키를 누르면 반복을 종료하게 한다거나 파일이나 외부 장치에서 들어오는 값을 체크하여 반복을 중단할 때 등의 상황에 사용한다.</li>
</ul>
<h2 id="9-2-while-반복문"><a class="header" href="#9-2-while-반복문">9-2. while 반복문</a></h2>
<h3 id="while-반복문의-기본-구조"><a class="header" href="#while-반복문의-기본-구조">while 반복문의 기본 구조</a></h3>
<ul>
<li>반복문의 또 다른 종류로는 <code>while</code>반복문이 있다.</li>
<li><code>for</code>반복문이 정규화된 형식을 가지고 있다면 <code>while</code>반복문은 '종결 조건'만 형식으로 가지고 나머지는 프로그래머가 적절하게 사용할 수 있는 문법이다.</li>
</ul>
<pre><code class="language-c">while(종결 조건) 명령문;
</code></pre>
<pre><code class="language-c">while(종결 조건) {
    명령문1;
    명령문2;
}
</code></pre>
<ul>
<li><code>while</code>문의 형식을 보면 '종결 조건'만 보인다.</li>
<li>이것은 '시작 조건'과 '조건 변화 수식'을 전혀 사용할 수 없다는 뜻이 아니라, 사용하고 싶은 위치나 작업 순서에 맞게 적절하게 배치하라는 뜻이다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int sum = 0;
    int num = 1;

    // 1에서 5까지 1씩 증가시키면서 반복함
    while (num &lt;= 5) {
        // 합산하기 전 sum 값을 사용하여 &quot;num + sum = &quot;이라고 출력함
        printf(&quot;num(%d) + sum(%d) = &quot;, num, sum);
        // sum에 num을 합산함
        sum = sum + num;
        // 합산 후 sum 값을 출력하고 줄 바꿈을 함
        printf(&quot;%d\n&quot;, sum);
        // 다음 숫자를 더하기 위해서 숫자를 증가시킴
        num++;
    }
    
    printf(&quot;\nResult : num = %d  sum = %d\n&quot;, num, sum);
}
</code></pre>
<pre><code class="language-text">num(1) + sum(0) = 1
num(2) + sum(1) = 3
num(3) + sum(3) = 6
num(4) + sum(6) = 10
num(5) + sum(10) = 15

Result : num = 6  sum = 15
</code></pre>
<ul>
<li>결국 반복의 3요소가 분명하게 정해져 있다면 <code>for</code>반복문을 사용하는 것이 좀 더 편하다.</li>
<li>그러나 시작 조건이나 조건 변화 수식이 다양하거나 수치로 정할 수 없는 상황이라면 <code>while</code>문을 사용하는 것이 표현하는 데 더 편리할 수 있다.</li>
</ul>
<blockquote>
<h4 id="for문-while문-중-어떤-반복문이-좋나"><a class="header" href="#for문-while문-중-어떤-반복문이-좋나">for문, while문 중 어떤 반복문이 좋나?</a></h4>
<ul>
<li>차이 없다!</li>
</ul>
</blockquote>
<h3 id="while-반복문으로-무한-루프-만들기"><a class="header" href="#while-반복문으로-무한-루프-만들기">while 반복문으로 무한 루프 만들기</a></h3>
<ul>
<li><code>while</code>반복문에서는 '종결 조건'을 생략할 수 없기 때문에 괄호 안에 어떤 상수 값이나 수식을 반드시 적어야 한다.</li>
<li>따라서 <code>while</code>문으로 무한 루프 형식을 만들고 싶다면 괄호 안에 참을 의미하는 1을 적어서 사용한다.</li>
</ul>
<h3 id="do--while-반복문"><a class="header" href="#do--while-반복문">do ~ while 반복문</a></h3>
<ul>
<li><code>do ~ while</code>반복문은 <code>while</code>문과 비슷하지만 '종결 조건'을 명령문을 실행하기 전이 아니라 후에 체크한다는 점이 다르다.</li>
</ul>
<pre><code class="language-c">do 명령문; while(종결 조건);
</code></pre>
<pre><code class="language-c">do {
    명령문;
    명령문;
} while(종결 조건);
</code></pre>
<ul>
<li>이 문법의 장점은 '종결 조건'이 거짓인 상황에도 명령문을 한 번은 수행하고 종료할 수 있다는 점이다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int sum = 0;
    int num = 1;

    // 1에서 5까지 1씩 증가시키면서 반복함
    do {
        // 합산하기 전 sum 값을 사용하여 &quot;num + sum = &quot;이라고 출력함
        printf(&quot;num(%d) + sum(%d) = &quot;, num, sum);
        // sum에 num을 더함
        sum = sum + num;
        // 더한 후 sum 값을 출력하고 줄을 바꿈
        printf(&quot;%d\n&quot;, sum);
        // 다음 숫자를 더하기 위해서 숫자를 증가시킴
        num++;
    } while (num &lt;= 5);

    printf(&quot;\nResult : num = %d  sum = %d\n&quot;, num, sum);
}
</code></pre>
<pre><code class="language-text">num(1) + sum(0) = 1
num(2) + sum(1) = 3
num(3) + sum(3) = 6
num(4) + sum(6) = 10
num(5) + sum(10) = 15

Result : num = 6  sum = 15
</code></pre>
<ul>
<li>실제로 <code>do ~ while</code>문법을 사용하는 경우는 많지 않다.</li>
</ul>
<h2 id="9-3-반복문-구성-방법"><a class="header" href="#9-3-반복문-구성-방법">9-3. 반복문 구성 방법</a></h2>
<ul>
<li>구구단 프로그램을 만들어 보면서 반복문을 활용하는 방법을 알아보자.</li>
</ul>
<h3 id="for문을-사용해서-구구단-2단-출력-프로그램-만들기"><a class="header" href="#for문을-사용해서-구구단-2단-출력-프로그램-만들기">for문을 사용해서 구구단 2단 출력 프로그램 만들기</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int i;

    // i 변수가 1~9까지 1씩 증가하면서 총 9번 반복함
    for (i = 1; i &lt;= 9; i++) {
        // 2 * i 형식으로 출력함
        printf(&quot;2 * %d = %d\n&quot;, i, 2 * i);
    }
}
</code></pre>
<h3 id="for문과-함수를-사용해서-구구단-전체-출력-프로그램-만들기"><a class="header" href="#for문과-함수를-사용해서-구구단-전체-출력-프로그램-만들기">for문과 함수를 사용해서 구구단 전체 출력 프로그램 만들기</a></h3>
<ul>
<li>지정한 단위 작업을 수행하는 코드를 그룹으로 묶기 위해 함수를 사용하는 것이 좋다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void ShowMultiplication(int step) {
    int i;

    // i 변수가 1~9까지 1씩 증가하면서 총 9번 반복함
    for (i = 1; i &lt;= 9; i++) {
        // step * i 형식으로 출력함
        printf(&quot;%d * %d = %d\n&quot;, step, i, step * i);
    }
}

void main() {
    int m;

    // 2단에서 9단까지 출력하도록 반복함
    for (m = 2; m &lt;= 9; m++) {
        // 매개변수에 2~9 값을 전달하여 구구단을 출력함
        ShowMultiplication(m);
    }
}
</code></pre>
<ul>
<li><code>while</code>문으로도 작성해 보자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void ShowMultiplication(int step) {
    int i = 1;
    while (i &lt;= 9) {
        printf(&quot;%d * %d = %d\n&quot;, step, i, step * i);
        i++;
    }
}

void main() {
    int m = 2;
    while (m &lt;= 9) {
        ShowMultiplication(m);
        m++;
    }
}
</code></pre>
<h2 id="9-4-중첩-반복문"><a class="header" href="#9-4-중첩-반복문">9-4. 중첩 반복문</a></h2>
<h3 id="중첩-반복문의-구조"><a class="header" href="#중첩-반복문의-구조">중첩 반복문의 구조</a></h3>
<ul>
<li>앞에서는 함수를 사용하여 표현했지만 함수를 사용하지 않고 반복문을 중첩해서 만들 수도 있다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int m, n;
    for (m = 5; m &lt; 7; m++) {  // m은 5부터 6까지 총 2회 반복
        for (n = 0; n &lt; 3; n++) {  // n은 0부터 2까지 총 3회 반복
            printf(&quot;m(%d) - n(%d)\n&quot;, m, n);
        }
    }
}
</code></pre>
<pre><code class="language-text">m(5) - n(0)
m(5) - n(1)
m(5) - n(2)
m(6) - n(0)
m(6) - n(1)
m(6) - n(2)
</code></pre>
<ul>
<li>반복문이 중첩되면 두 반복문의 반복 횟수를 곱한 수 만큼 반복하며, 외부 반복문이 1회 반복될 때마다 내부 반복문은 자기 반복 횟수 만큼 반복한다.</li>
</ul>
<h3 id="중첩-반복문을-사용해서-구구단-만들기"><a class="header" href="#중첩-반복문을-사용해서-구구단-만들기">중첩 반복문을 사용해서 구구단 만들기</a></h3>
<ul>
<li>앞에서 사용한 구구단 예제를 <code>ShowMultiplication</code>함수를 사용하지 않고 중첩 반복문을 사용하여 구성해 보자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int step, i;

    // 2단에서 9단까지 출력되도록 반복함
    for (step = 2; step &lt;= 9; step++) {
        // i 변수가 1~9까지 1씩 증가하면서 총 9번 반복함
        for (i = 1; i &lt;= 9; i++) {
            // step * i 형식으로 출력함
            printf(&quot;%d * %d = %d\n&quot;, step, i, step * i);
        }
    }
}
</code></pre>
<h2 id="9-5-break와-continue-제어문"><a class="header" href="#9-5-break와-continue-제어문">9-5. break와 continue 제어문</a></h2>
<h3 id="break-제어문"><a class="header" href="#break-제어문">break 제어문</a></h3>
<ul>
<li>반복 작업이 항상 정해진 횟수만큼 이루어지는 것은 아니다.</li>
<li>반복 작업을 하다가도 예외 상황이 발생하면 중간에 중단할 수 있다.</li>
<li><code>break</code>문은 자신이 포함된 반복문을 종료시키는 기능을 가지고 있다.</li>
<li>그래서 반복 작업을 하다가 예외 상황이 발생하여 반복문을 종료시켜야 한다면 <code>break</code>문을 사용한다.</li>
<li>하지만 <code>break</code>문으로 반복문을 종료하는 효과는 하나의 반복문에만 미치기 때문에, 중첩된 반복문에서도 하나의 반복문에만 적용된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int m, n;
    for (m = 5; m &lt; 7; m++) {  // m은 5~6까지 2회 반복함
        for (n = 0; n &lt; 3; n++) {  // n은 0~2까지 3회 반복함
            // m값이 5이고 n값이 1일 때 break문을 수행함
            if (5 == m &amp;&amp; 1 == n) break;
            printf(&quot;m(%d) - n(%d)\n&quot;, m, n);
        }
    }
}
</code></pre>
<pre><code class="language-text">m(5) - n(0)
m(6) - n(0)
m(6) - n(1)
m(6) - n(2)
</code></pre>
<ul>
<li>특정 상황에서 반복문을 둘 다 종료시키고 싶다면 바깥쪽 반복문에도 조건문을 사용하여 <code>break</code>문을 적어주어야 한다.</li>
<li>다음과 같이 <code>break</code>문을 둘 다 적용하면, <code>n</code>을 사용하는 반복문에서 <code>break</code>문으로 빠져나와서 또다시 같은 조건문에 걸려 <code>break</code>문이 실행되고 <code>m</code>을 사용하는 반복문도 종료된다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int m, n;
    for (m = 5; m &lt; 7; m++) {  // m은 5~6까지 2회 반복함
        for (n = 0; n &lt; 3; n++) {  // n은 0~2까지 3회 반복함
            // m값이 5이고 n값이 1일 때 break문을 수행함
            if (5 == m &amp;&amp; 1 == n) break;
            printf(&quot;m(%d) - n(%d)\n&quot;, m, n);
        }

        if (5 == m &amp;&amp; 1 == n) break;
    }
}
</code></pre>
<pre><code class="language-text">m(5) - n(0)
</code></pre>
<h3 id="continue-제어문"><a class="header" href="#continue-제어문">continue 제어문</a></h3>
<ul>
<li><code>break</code>문은 반복문을 종료시키지만 <code>continue</code>문은 1회성 취소를 사용한다.</li>
<li>반복문이 명령을 실행하다가 <code>continue</code>문을 만나면 이후 명령들을 실행하지 않고 '조건 변화 수식'으로 돌아간다.</li>
<li>그러고 나서 '종결 조건'을 체크한 뒤 다시 정상적으로 반복을 진행한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int m;
    for (m = 5; m &lt; 8; m++) {  // m은 5~7까지 3회 반복함
        if (6 == m) continue;  // m값이 6일 때 continue문을 수행함
        printf(&quot;m(%d)\n&quot;, m);
    }
}
</code></pre>
<pre><code class="language-text">m(5)
m(7)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-시프트-연산자와-비트-연산자"><a class="header" href="#10-시프트-연산자와-비트-연산자">10. 시프트 연산자와 비트 연산자</a></h1>
<h2 id="10-1-비트-단위-연산과-비트-패턴"><a class="header" href="#10-1-비트-단위-연산과-비트-패턴">10-1. 비트 단위 연산과 비트 패턴</a></h2>
<h3 id="비트-단위-연산자가-필요한-이유"><a class="header" href="#비트-단위-연산자가-필요한-이유">비트 단위 연산자가 필요한 이유</a></h3>
<ul>
<li>비트는 0 또는 1을 저장할 수 있는 공간이다.</li>
<li>이 장에서 배울 것들은 이 '비트'를 다루는 데 필요한 연산자이다.</li>
<li>C 언어는 왜 비트 단위의 연산자를 제공하는 것일까?</li>
<li>프로그램이 다루는 데이터 중에 두 가지 상황 중 한 가지를 선택하거나 저장하는 경우가 많다.</li>
<li>예를 들어 '전등의 상태'를 프로그램에 저장해야 한다면, 이런 상태를 '꺼짐', '켜짐'이라고 문자 그대로 저장하면 프로그램의 처리 효율이 낮아질 수 밖에 없다.</li>
<li>따라서 문자가 아닌 숫자로 저장해 효율을 높이는 것이 좋다.</li>
<li>0이면 '꺼짐'을 의미하고 1이면 '켜짐'을 의미하도록 약속해서 사용하는 것이다.</li>
<li>이런 상황에서 우리는 '1비트'에 0 또는 1 중 한 가지 값을 저장할 필요를 느낀다.</li>
<li>하지만 C 언어에서 제공하는 자료형의 최소 단위는 1바이트(8비트)이다.</li>
<li>0, 1 중에 하나를 저장하더라도 무조건 1바이트 저장 공간을 사용하는 <code>char</code>형 변수를 선언하고 사양해야 하는 것이다.</li>
</ul>
<pre><code class="language-c">unsigned char lamp_state = 0;  // 기본값은 전등이 꺼져 있음
lamp_state = 1;                // 전등이 켜지면 1로 변경함
</code></pre>
<ul>
<li>0과 1로 자료를 저장할 수 있는 프로그램을 만들 때 비트 단위로 연산한다면 메모리를 많이 절약할 수 있다.</li>
<li>이렇게 비트 단위로 어떤 작업을 하고 싶다면 시프트 연산자와 비트 연산자를 반드시 알아야 한다.</li>
</ul>
<h3 id="비트-패턴과-16진법"><a class="header" href="#비트-패턴과-16진법">비트 패턴과 16진법</a></h3>
<ul>
<li>C 언어는 2진법 상수 표현을 제공하지 않아서 소스 코드에서는 2진법으로 변환하기 쉬운 16진법으로 사용하자.</li>
<li>다음 표는 꼭 외워라.</li>
<li>2진법 ↔ 16진법 변환표</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>0000 : 0</th><th>0001 : 1</th><th>0010 : 2</th><th>0011 : 3</th></tr></thead><tbody>
<tr><td>0100 : 4</td><td>0101 : 5</td><td>0110 : 6</td><td>0111 : 7</td></tr>
<tr><td>1000 : 8</td><td>1001 : 9</td><td>1010 : A(10)</td><td>1011 : B(11)</td></tr>
<tr><td>1100 : C(12)</td><td>1101 : D(13)</td><td>1110 : E(14)</td><td>1111 : F(15)</td></tr>
</tbody></table>
</div>
<ul>
<li>예를 들어 부호 없는 1바이트 <code>data</code>변수를 선언하고 그 변수에 16진수 값 5A로 초기화하는 코드를 다음과 같이 명시한다.</li>
</ul>
<pre><code class="language-c">unsigned char data = 0x5A;
</code></pre>
<ul>
<li>16진수 한 자리는 4비트를 의미하기 때문에 다음과 같이 1바이트(8비트) 크기의 <code>data</code>변수는 4자리씩 나뉜 2진법으로 표현한다.</li>
</ul>
<pre><code class="language-text">data : 0101 1010
</code></pre>
<ul>
<li>비트를 그림으로 그려서 설명할 때 비트 번호는 다음과 같이 명시한다.</li>
<li>오른쪽에서 왼쪽으로 갈수록 비트 번호가 커진다.</li>
</ul>
<p><img src="./images/0x5A_bit_pattern.png" alt="16진수 0x5A의 비트 패턴" /></p>
<h2 id="10-2-시프트-연산자"><a class="header" href="#10-2-시프트-연산자">10-2. 시프트 연산자</a></h2>
<h3 id="시프트-연산자의-기능"><a class="header" href="#시프트-연산자의-기능">시프트 연산자의 기능</a></h3>
<ul>
<li>시프트 연산자(&lt;&lt;, &gt;&gt;)는 변수의 값을 지정한 비트 수만큼 왼쪽 또는 오른쪽으로 비트를 이동 시키는 기능을 한다.</li>
</ul>
<pre><code class="language-c">오른쪽에서 왼쪽으로 이동
변수 &lt;&lt; 이동할 비트 수

unsigned char data = 0x1A;
// 이동 전: 0001 1010
data = data &lt;&lt; 2;
// 이동 후: 0110 1000
</code></pre>
<pre><code class="language-c">왼쪽에서 오른쪽으로 이동
변수 &gt;&gt; 이동할 비트 수

unsigned char data = 0x1A;
// 이동 전: 0001 1010
data = data &gt;&gt; 2;
// 이동 후: 0000 0110
</code></pre>
<ul>
<li><code>data = data &lt;&lt; 2</code>는 축약해서 <code>data &lt;&lt;= 2</code>로 표현할 수도 있다.</li>
<li>이동한 비트들이 변수를 위해 할당된 메모리 공간(자료형)의 크기를 벗어나면 해당 비트들은 사라지고, 비트가 이동한 빈자리에는 0이 채워진다.</li>
<li>비트가 왼쪽으로 이동해서 사라지는 것을 오버플로(Overflow)라 부르고, 오른쪽으로 이동해서 사라지는 것을 언더플로(Underflow)라고 부른다.</li>
</ul>
<p><img src="./images/shift_operator_1.png" alt="시프트 연산자 (&lt;&lt;)" /></p>
<h3 id="시프트-연산자의-특성-이용하기"><a class="header" href="#시프트-연산자의-특성-이용하기">시프트 연산자의 특성 이용하기</a></h3>
<ul>
<li>이렇게 비트를 이동시키면 어떤 효과가 있을까?</li>
<li>1이 왼쪽으로 1칸씩 이동할 때마다 2를 곱한 만큼 숫자가 커지고, 오른쪽으로 1칸씩 이동할 때마다 2를 나눈 만큼 숫자가 작아진다.</li>
<li>결국 <code>&lt;&lt;</code> 연산을 사용하여 n개의 비트를 오른쪽에서 왼쪽으로 이동하면 2<sup>n</sup>을 곱한 것과 같은 효과가 있다.</li>
<li><code>&gt;&gt;</code> 연산을 사용하여 n개의 비트를 왼쪽에서 오른쪽으로 이동하면 2<sup>n</sup>을 나눈 것과 동일한 효과가 있다.</li>
</ul>
<h4 id="시프트-연산자로-곱셈과-나눗셈-대체하기"><a class="header" href="#시프트-연산자로-곱셈과-나눗셈-대체하기">시프트 연산자로 곱셈과 나눗셈 대체하기</a></h4>
<ul>
<li>시프트 연산은 속도가 빠른 명령인데 반해 곱셈이나 나눗셈 연산자는 속도가 느린 명령이다.</li>
<li>따라서 2의 제곱(2, 4, 8, 16, ⋯)으로 곱하거나 나눌 때 시프트 연산으로 대체하는 것이 더 효율적이다.</li>
<li>물론 컴파일러가 번역할 때 최적화 옵션을 '수행 속도'로 설정해 주면 어느 정도 알아서 연산 방식을 변환해 주지만, 프로그래머가 직접 명시적으로 변환해 주는 것이 더 좋다.</li>
<li>하지만, 곱셈과 나눗셈을 모두 시프트 연산자로 대체할 수는 없다.</li>
<li>비트 패턴이 2진수로 되어 있기 때문에 비트 이동 효과가 2의 제곱만 적용되기 때문이다.</li>
</ul>
<h3 id="시프트-연산자를-사용할-때-주의할-점"><a class="header" href="#시프트-연산자를-사용할-때-주의할-점">시프트 연산자를 사용할 때 주의할 점</a></h3>
<h4 id="연산자-우선순위가-낮다"><a class="header" href="#연산자-우선순위가-낮다">연산자 우선순위가 낮다</a></h4>
<ul>
<li>시프트 연산자의 우선순위가 덧셈(+) 연산자보다 낮다.</li>
<li>그래서 곱셈(*)과 나눗셈(/), 덧셈(+) 연산자로 이루어진 수식을 그대로 시프트 연산자로 변환하는 경우에 잘못된 결과가 나올 수 있다.</li>
<li>이 문제를 해결하려면 괄호를 사용하자.</li>
</ul>
<h4 id="변수에-부호가-있는-경우"><a class="header" href="#변수에-부호가-있는-경우">변수에 부호가 있는 경우</a></h4>
<ul>
<li>부호가 있는 변수에 시프트 연산을 하면 연산 특성이 달라지기 때문에 주의해야 한다.</li>
<li><code>signed char</code>로 선언한 변수라면 최상위 비트가 부호 비트로 사용되기 때문에 음수 값을 시프트 연산할 때 <code>unsigned char</code>와 다른 방식으로 처리된다.</li>
</ul>
<pre><code class="language-c">char data = 0x85;  // 10진수 -123
data = data &gt;&gt; 3;
</code></pre>
<p><img src="./images/shift_operator_2.png" alt="시프트 연산자 (&gt;&gt;)" /></p>
<ul>
<li><code>unsigned</code>형식으로 선언된 변수들은 시프트 연산으로 비트가 이동해서 생긴 빈 공간에 무조건 0을 채우게 된다.</li>
<li><code>signed</code>변수들은 <code>&gt;&gt;</code>를 사용하여 '왼쪽에서 오른쪽으로 이동할 때' 자신의 부호를 유지하기 위해서 부호 비트가 1이면 비트가 이동한 빈 공간에 1을 채우고 부호 비트가 0이면 0으로 채운다.</li>
<li>하지만 여기에 더 큰 문제가 있다.</li>
<li>-123을 8로 나누면 -15가 나오는데, 시프트 연산자를 사용하여 나눗셈을 하려고 <code>&gt;&gt; 3</code>으로 연산하면 -16이 나온다는 것이다.</li>
<li><code>data</code>변수가 가지는 음수 값이 8의 배수인 경우에는 <code>&gt;&gt; 3</code>과 같은 결과가 나오지만 8의 배수가 아닌 경우에는 1만큼 더 적은 값이 나온다.</li>
<li>따라서 음수를 다루는 경우에는 나누어지는 숫자가 나누는 숫자의 배수인지를 체크해서 사용하거나, 나눗셈을 <code>&gt;&gt;</code>연산자로 대체하지 말고 그냥 사용하는 것이 좋다.</li>
</ul>
<h2 id="10-3-비트-연산자"><a class="header" href="#10-3-비트-연산자">10-3. 비트 연산자</a></h2>
<h3 id="비트-연산자란"><a class="header" href="#비트-연산자란">비트 연산자란?</a></h3>
<ul>
<li>비트 연산자는 비트 단위로 AND, OR, NOT, XOR(Exclusive OR, 배타적 논리합) 연산을 수행 한다.</li>
<li>논리 연산자와 구별하기 위해서 AND 연산은 &amp;, OR 연산은 |, NOT 연산은 ~, XOR 연산은 ^ 기호를 사용한다.</li>
<li>AND 연산은 연산에 참여하는 A, B값이 둘 다 1이어야 결과 값이 1이 나오고,</li>
<li>OR 연산은 A, B값이 둘 다 0인 경우에만 결과 값이 0이 나온다.</li>
<li>NOT 연산은 현재 비트 패턴이 반전(0이면 1, 1이면 0)되며,</li>
<li>XOR 연산은 A, B값이 같으면 0, 다르면 1이 된다.</li>
</ul>
<h4 id="and-연산"><a class="header" href="#and-연산">AND(&amp;) 연산</a></h4>
<ul>
<li>두 값을 비트 단위로 AND 연산을 수행하며, 연산하는 A 비트의 값이 0이면 B 비트의 값에 상관없이 0이 된다.</li>
<li>A 비트의 값이 1이면 B 비트의 값에 따라 0 또는 1이 되기 때문에, 두 비트가 모두 1일 때만 1이 된다.</li>
</ul>
<pre><code class="language-text">  0000 1111 (0x0F)
&amp; 0011 1100 (0x3C)
-------------------
  0000 1100 (0x0C)
</code></pre>
<h4 id="or-연산"><a class="header" href="#or-연산">OR(|) 연산</a></h4>
<ul>
<li>두 값을 비트 단위로 OR 연산을 수행하며, 연산하는 A 비트의 값이 1이면 B 비트의 값에 상관없이 1이 된다.</li>
<li>반대로 A 비트의 값이 0이면 B 비트의 값에 따라 0 또는 1이 되기 때문에, 두 비트 중 하나라도 1이면 1이 된다.</li>
</ul>
<pre><code class="language-text">  0000 1111 (0x0F)
| 0011 1100 (0x3C)
-------------------
  0011 1111 (0x3F)
</code></pre>
<h4 id="xor-연산"><a class="header" href="#xor-연산">XOR(^) 연산</a></h4>
<ul>
<li>두 값을 비트 단위로 XOR 연산을 수행하며, 연산하는 두 비트이 값이 같으면 0이 되고 다르면 1이 된다.</li>
<li>즉 두 비트가 서로 다른 값일 때 1이 된다.</li>
</ul>
<pre><code class="language-text">  0000 1111 (0x0F)
^ 0011 1100 (0x3C)
-------------------
  0011 0011 (0x33)
</code></pre>
<h4 id="not-연산"><a class="header" href="#not-연산">NOT(~) 연산</a></h4>
<ul>
<li>각 비트의 값을 반전시키는 작업을 수행한다.</li>
<li>따라서 비트가 0이면 1이 되고 1이면 0이 된다.</li>
</ul>
<pre><code class="language-text">~ 0000 1111 (0x0F)
-------------------
  1111 0000 (0xF0)
</code></pre>
<h4 id="비트-연산자-단축-표현"><a class="header" href="#비트-연산자-단축-표현">비트 연산자 단축 표현</a></h4>
<ul>
<li>연산자를 단축해서 사용하는 것은 단순히 표현만 단축하는 것이기 때문에 결과에 차이점은 없다.</li>
<li>하지만 단축 표현에 사용된 연산자들은 연산자 우선순위가 낮기 때문에 다른 연산자와 연산할 때 연산자 우선순위에 주의해야 한다.</li>
<li><code>A = A &amp; B;</code> : 단축 표현 <code>A &amp;= B;</code></li>
<li><code>A = A | B;</code> : 단축 표현 <code>A |= B;</code></li>
<li><code>A = A ^ B;</code> : 단축 표현 <code>A ^= B;</code></li>
</ul>
<h3 id="비트-단위로-데이터를-다루는-방법"><a class="header" href="#비트-단위로-데이터를-다루는-방법">비트 단위로 데이터를 다루는 방법</a></h3>
<ul>
<li>비트 연산자가 비트 단위의 연산을 제공하지만 한 개의 비트만 연산하는 것이 아니다.</li>
<li>비트 단위라고 해도 최소 1바이트(8비트) 단위로 연산이 이루어지기 때문에, 비트 연산자를 사용하면 자신이 변경하려는 비트를 포함하는 바이트는 모두 연산이 이루어진다.</li>
<li>하지만 프로그램을 만들다 보면 바이트 단위가 아닌 비트 단위로 데이터를 다뤄야 할 때도 있다.</li>
<li>만약 지정한 비트에만 0 또는 1을 설정하고 싶거나, 특정 비트가 가지고 있는 값을 가져오고 싶다면 그 기능은 비트 연산자의 연산 특징을 잘 응용하여 프로그래머가 직접 구현해서 사용해야 한다.</li>
</ul>
<h3 id="지정한-비트를-0으로-설정하기"><a class="header" href="#지정한-비트를-0으로-설정하기">지정한 비트를 0으로 설정하기</a></h3>
<ul>
<li>변수의 비트 패턴에서 지정한 비트만 0으로 설정하고 다른 비트는 자신의 값을 유지하려면 비트 AND 연산자 <code>&amp;</code>를 사용한다.</li>
</ul>
<h4 id="1단계-2번-비트를-0으로-설정하기"><a class="header" href="#1단계-2번-비트를-0으로-설정하기">1단계: 2번 비트를 0으로 설정하기</a></h4>
<ul>
<li>비트 AND 연산자는 연산하는 한쪽 비트가 0이면 다른 쪽 비트 값에 상관없이 결과 값이 0이 나오는 특징을 가지고 있다.</li>
<li>즉 기존 값을 유지해야 하는 비트는 1과 AND 연산하고, 0으로 설정해야 하는 비트는 0과 AND 연산을 하는 것이다.</li>
</ul>
<p><img src="./images/bit_data_1.png" alt="지정한 비트를 0으로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;        // lamp_state에 어떤 값이 있는지 알 수 없음
lamp_state = lamp_state &amp; 0xFB;  // lamp_state의 2번 비트만 0으로 변경함
</code></pre>
<h4 id="2단계-임의의-비트를-0으로-설정하기"><a class="header" href="#2단계-임의의-비트를-0으로-설정하기">2단계: 임의의 비트를 0으로 설정하기</a></h4>
<ul>
<li>2번 비트를 0으로 설정할 때 사용하는 <code>&amp; 0xFB</code>를 직접 명시하지 않고 2번이라는 정보만 가지고 만들어 보자.</li>
</ul>
<p><img src="./images/bit_data_2.png" alt="임의의 비트를 0으로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;                 // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_num = 2;                // 0으로 만들 비트의 번호
unsigned char mask = ~(0x01 &lt;&lt; bit_num);  // 0xFB
lamp_state = lamp_state &amp; mask;           // lamp_state의 2번 비트만 0으로 변경함
</code></pre>
<ul>
<li>이렇게 하면 <code>bit_num</code>변수에 비트 번호만 적어 주면 해당 비트를 0으로 만들 수 있다.</li>
</ul>
<h4 id="3단계-함수로-만들어-보기"><a class="header" href="#3단계-함수로-만들어-보기">3단계: 함수로 만들어 보기</a></h4>
<ul>
<li>변수의 특정 비트를 0으로 만드는 예제</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char ResetBit(unsigned char dest_data, unsigned char bit_num) {
    // 1바이트 변수라서 비트 이동은 0~7까지 가능함
    if (bit_num &lt; 8) dest_data = dest_data &amp; ~(0x01 &lt;&lt; bit_num);
    // 변경된 값을 반환함
    return dest_data;
}

void main() {
    unsigned char lamp_state = 0x7F;  // 16진수 0x7F는 2진수 0111 1111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 전 값을 출력함
    // lamp_state 변수의 3번 비트를 0으로 설정함
    lamp_state = ResetBit(lamp_state, 3);  // 16진수 0x77은 2진수 0111 0111
    printf(&quot;%X\n&quot;, lamp_state);  // 변경 후 값을 출력함
}
</code></pre>
<pre><code class="language-text">7F -&gt; 77
</code></pre>
<ul>
<li><code>ResetBit</code>함수는 <code>dest_data</code>변수의 <code>bit_num</code>번 비트를 0으로 설정하는 함수로 해당 비트가 0으로 설정된 값을 반환한다. </li>
</ul>
<h3 id="지정한-비트를-1로-설정하기"><a class="header" href="#지정한-비트를-1로-설정하기">지정한 비트를 1로 설정하기</a></h3>
<ul>
<li>변수의 비트 패턴에서 지정한 비트만 1로 설정하고 다른 비트는 자신의 값을 유지하려면 비트 OR 연산자를 사용하면 된다.</li>
</ul>
<h4 id="1단계-2번-비트를-1로-설정하기"><a class="header" href="#1단계-2번-비트를-1로-설정하기">1단계: 2번 비트를 1로 설정하기</a></h4>
<ul>
<li>비트 OR 연산자는 연산하는 한쪽 비트가 1이면 다른 쪽 비트 값에 상관없이 결과 값이 1이 나오는 특징을 가지고 있다.</li>
<li>즉 기존 값을 유지해야 하는 비트는 0을 넣고 1로 설정해야 하는 비트에는 1을 넣어서 숫자를 만든 후 연산하려는 값과 이 값을 OR 연산하면 된다.</li>
</ul>
<p><img src="./images/shift_operator_3.png" alt="2번 비트를 1로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
lamp_state = lamp_state | 0x04;  // lamp_state의 2번 비트만 1로 변경함
</code></pre>
<h4 id="2단계-임의의-비트를-1로-설정하기"><a class="header" href="#2단계-임의의-비트를-1로-설정하기">2단계: 임의의 비트를 1로 설정하기</a></h4>
<ul>
<li>2번 비트를 1로 설정할 때 사용하는 <code>| 0x04</code>를 직접 명시하지 않고 2번 비트라는 정보만 가지고 만들어 보자.</li>
</ul>
<p><img src="./images/shift_operator_4.png" alt="임의의 비트를 1로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_num = 2;  // 1로 만들 비트의 번호
unsigned char mask = 0x01 &lt;&lt; bit_num;  // 0x04
lamp_state = lamp_state | mask;  // lamp_state의 2번 비트만 1로 변경함
</code></pre>
<ul>
<li>이렇게 하면 <code>bit_num</code>변수에 비트 번호만 적어 주면 해당 비트를 1로 만들 수 있다.</li>
</ul>
<h4 id="3단계-함수로-만들어-보기-1"><a class="header" href="#3단계-함수로-만들어-보기-1">3단계: 함수로 만들어 보기</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char SetBit(unsigned char dest_data, unsigned char bit_num) {
    // 1바이트 변수라서 비트 이동은 0~7까지 가능함
    if (bit_num &lt; 8) dest_data = dest_data | (0x01 &lt;&lt; bit_num);
    // 변경된 값을 반환함
    return dest_data;
}

void main() {
    unsigned char lamp_state = 0x77;  // 0x77은 2진수로 0111 0111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 전 값을 출력함
    // lamp_state 변수의 3번 비트를 1로 설정함
    lamp_state = SetBit(lamp_state, 3);
    // 변경 후 값을 출력함
    printf(&quot;%X\n&quot;, lamp_state);
}
</code></pre>
<pre><code class="language-text">77 -&gt; 7F
</code></pre>
<ul>
<li><code>SetBit</code>함수는 <code>dest_data</code>변수의 <code>bit_num</code>번 비트를 1로 설정하는 함수로 해당 비트가 1로 설정된 값을 반환한다.</li>
</ul>
<h3 id="특정-비트의-값-얻기"><a class="header" href="#특정-비트의-값-얻기">특정 비트의 값 얻기</a></h3>
<ul>
<li>변수의 비트 패턴에서 특정 비트의 값을 얻고 싶다면 비트 AND 연산자를 사용한다.</li>
</ul>
<h4 id="1단계-2번-비트-값-얻기"><a class="header" href="#1단계-2번-비트-값-얻기">1단계: 2번 비트 값 얻기</a></h4>
<ul>
<li>비트 AND 연산자는 연산하는 한쪽 비트가 1일 때 다른 쪽 비트 값이 1이면 1이 나오고 0이면 0이 나온다.</li>
<li>따라서 얻고 싶은 비트 값만 1로 넣고 나머지 비트는 모두 0을 넣어서 숫자를 만들고 AND 연산을 하면 된다.</li>
<li>이렇게 하면 자신이 지정한 비트만 값이 유지되고 나머지 비트는 모두 0이 된다.</li>
</ul>
<p><img src="./images/shift_operator_5.png" alt="2번 비트 값 얻기" /></p>
<ul>
<li>하지만 이렇게 하면 자신이 얻고자 하는 비트가 0번 비트인 경우에만 0, 1로 값이 나오고 다른 비트이면 그 비트의 2의 제곱만큼 큰 값으로 나온다.</li>
<li>따라서 이 값을 0 또는 1로 얻고 싶다면 ? 값을 0번 비트로 이동시켜야 한다.</li>
</ul>
<p><img src="./images/shift_operator_6.png" alt="값을 0번 비트로 이동" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_state;  // 2번 비트의 값을 저장할 변수
bit_state = lamp_state &amp; 0x04;  // lamp_state의 2번 비트만 값을 유지한 상태로 bit_state에 저장함.
                                // lamp_state는 변경되지 않음
bit_state = bit_state &gt;&gt; 2;  // bit_state의 값을 0 또는 1로 확인 가능
</code></pre>
<ul>
<li>비트에 값을 0 또는 1로 설정할 때와 달리 <code>bit_state</code>변수를 추가로 선언해서 사용한 이유는 <code>lamp_state</code>에 직접 연산을 해 버리면 자신의 상태 값을 잃어버리기 때문이다.</li>
</ul>
<h4 id="2단계-임의의-비트-값-얻기"><a class="header" href="#2단계-임의의-비트-값-얻기">2단계: 임의의 비트 값 얻기</a></h4>
<ul>
<li>2번 비트를 확인할 때 사용하는 <code>&amp; 0x04</code>와 <code>&gt;&gt; 2</code>를 직접 명시하지 않고 2번이라는 정보만 가지고 만들어 보자.</li>
</ul>
<p><img src="./images/shift_operator_7.png" alt="임의의 비트 값 얻기" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_num = 2;  // 1로 만들 비트의 번호
unsigned char bit_state;  // 비트의 값을 저장할 변수
unsigned char mask = 0x01 &lt;&lt; bit_num;  // 비트 옮긴 후 값은 0x04
bit_state = lamp_state &amp; mask;  // lamp_state의 2번 비트만 값을 유지한 상태로 bit_state에 저장함
                                // lamp_state는 변경되지 않음
bit_state = bit_state &gt;&gt; bit_num;  // bit_state의 값을 0 또는 1로 확인 가능
</code></pre>
<ul>
<li>이렇게 하면 <code>bit_num</code>변수에 비트 번호만 적어 주면 해당 비트의 값이 <code>bit_state</code>에 저장된다.</li>
</ul>
<h4 id="3단계-함수-만들어-보기"><a class="header" href="#3단계-함수-만들어-보기">3단계: 함수 만들어 보기</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char GetBit(unsigned char dest_data, unsigned char bit_num) {
    unsigned char bit_state = 0;

    // 1바이트 변수라서 비트 이동은 0~7까지만 가능함
    if (bit_num &lt; 8) {
        bit_state = dest_data &amp; (0x01 &lt;&lt; bit_num);
        bit_state = bit_state &gt;&gt; bit_num;
    }

    // bit_num에 지정한 비트 값을 반환함
    return bit_state;
}

void main() {
    unsigned char lamp_state = 0x75;  // 16진수 0x75는 2진수로 0111 0101
    unsigned char bit_state;
    int i;

    printf(&quot;%X -&gt; &quot;, lamp_state);  // 16진법으로 현재 값을 출력함
    // 8개의 비트 값을 모두 출력하기 위해 8번 반복함
    for (i = 0; i &lt; 8; i++) {
        // 비트를 표시할 때 최상위 비트(7번 비트)부터 순차적으로 보여주기 위해서 7, 6, 5, ... 순으로
        // 비트 값을 얻는다.
        bit_state = GetBit(lamp_state, 7 - i);
        // 비트 값을 출력함
        printf(&quot;%d&quot;, bit_state);
    }

    // 비트 값이 모두 출력되면 줄 바꿈을 함
    printf(&quot;\n&quot;);
}
</code></pre>
<pre><code class="language-text">75 -&gt; 01110101
</code></pre>
<ul>
<li><code>GetBit</code>함수는 <code>dest_data</code>변수의 <code>bit_num</code>번 비트 값을 반환하는 함수이다.</li>
<li>이렇게 기능을 구현하면 직접 특정 비트의 값을 읽거나 저장하는 연산자가 없더라도 비트 단위로 정보를 처리할 수 있다.</li>
</ul>
<blockquote>
<h4 id="setbit-함수와-resetbit-함수가-비슷해-보이는가"><a class="header" href="#setbit-함수와-resetbit-함수가-비슷해-보이는가">SetBit 함수와 ResetBit 함수가 비슷해 보이는가?</a></h4>
<ul>
<li>위의 예제에서 사용한 <code>SetBit</code>함수와 <code>ResetBit</code>함수는 기능이 유사한 함수이고 함께 사용할 확률이 높아서 다음과 같이 하나의 함수로 합쳐도 된다.</li>
<li>변수의 특정 비트를 0 또는 1로 변경하는 예제</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char ModifyBit(unsigned char dest_data, unsigned char bit_num, char value) {
    unsigned char mask;

    // 1바이트 변수라서 비트 이동은 0~7까지만 가능
    if (bit_num &lt; 8) {
        // bit_num번 비트에 값을 설정하는 데 사용할 숫자를 구성함
        mask = 0x01 &lt;&lt; bit_num;

        if (1 == value) dest_data = dest_data | mask;  // 1로 설정하는 경우
        else dest_data = dest_data &amp; ~mask;  // 0으로 설정하는 경우
    }

    // 변경된 값을 반환함
    return dest_data;
}

void main() {
    unsigned char lamp_state = 0x7F;  // 16진수 0x7F는 2진수 0111 1111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 전 값을 출력함

    // lamp_state 변수의 3번 비트를 0으로 설정함
    lamp_state = ModifyBit(lamp_state, 3, 0);  // 16진수 0x77은 2진수 0111 0111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 후 값을 출력함
   
    // lamp_state 변수의 3번 비트를 1로 설정함
    lamp_state = ModifyBit(lamp_state, 3, 1);  // 16진수 0x7F는 2진수 0111 1111
    printf(&quot;%X\n&quot;, lamp_state);  // 변경 후 값을 출력함
}
</code></pre>
<pre><code class="language-text">7F -&gt; 77 -&gt; 7F
</code></pre>
</blockquote>
<h3 id="비트-연산자를-활용하는-방법"><a class="header" href="#비트-연산자를-활용하는-방법">비트 연산자를 활용하는 방법</a></h3>
<h4 id="보수를-이용해-덧셈으로-뺄셈-구현하기"><a class="header" href="#보수를-이용해-덧셈으로-뺄셈-구현하기">보수를 이용해 덧셈으로 뺄셈 구현하기</a></h4>
<ul>
<li>부호를 고려하지 않는 1바이트(8비트, unsigned char) 메모리는 정수 값을 저장할 때 0~255의 값만 저장할 수 있다.</li>
<li>이런 1바이트 메모리는 255보다 더 큰 값이 들어오면 오버플로가 발생하고 그만큼의 값을 잃어버리게 된다.</li>
</ul>
<pre><code class="language-c">unsigned char data = 255;  // 255는 부호 없는 1바이트 변수가 가질 수 있는 최대값
data++;  // 255 + 1 = 256이 되어야 하지만 오버플로가 발생하여 0이 되어 버림
data++;  // 0이 되었으므로 이 단계에서는 1이 됨
</code></pre>
<p><img src="./images/bit_operator_1.png" alt="오버플로" /></p>
<ul>
<li>이러한 메모리 특성 때문에 <code>data</code>변수에 들어 있는 값을 0으로 만들 수 있는 방법이 두 가지 있다.</li>
<li>예를 들어 <code>data</code>변수 값이 255라면 255를 빼서 0을 만들 수도 있고 1을 더해서도 0으로 만들 수도 있다.</li>
<li>즉 덧셈으로 뺄셈을 구현할 수 있다는 뜻이다.</li>
<li><code>data</code>값이 198인 경우에 198을 빼거나 58을 더하면 된다.</li>
<li>결국 <code>data</code>변수에 들어있는 값을 0으로 만들기 위해 255나 198에 대응하는 1이나 58을 찾는 방법은 이 숫자들을 2진수로 바꿔 보면 이해할 수 있다.</li>
</ul>
<p><img src="./images/bit_operator_2.png" alt="255를 0으로 만드는 숫자를 찾는 방법" /></p>
<p><img src="./images/bit_operator_3.png" alt="198을 0으로 되도록 만드는 숫자를 찾는 방법" /></p>
<ul>
<li>뺄셈에 사용할 숫자를 비트 NOT(~) 연산자를 사용하여 비트를 반전시키고 그 값에 1을 더하면 대응하는 숫자를 구할 수 있다.</li>
<li>위와 같은 상황에서 비트를 반전시켜 얻은 값을 '1의 보수'라고 하고, 1의 보수에 1을 더해서 얻은 값을 '2의 보수'라고 한다.</li>
<li>결과적으로 B에 대한 2의 보수를 구해서 덧셈을 하면 B를 뺀 것과 같은 결과가 나온다.</li>
<li>이렇게 덧셈으로 뺄셈을 대신할 수 있다는 것은 하드웨어 입장에서 볼 때 뺄셈 회로를 하나 줄일 수도 있다는 뜻이다.</li>
<li>따라서 컴퓨터에서 뺄셈 회로가 없다고 이야기하는 것이 바로 이 개념 때문이다.</li>
</ul>
<h4 id="데이터-암호화하기"><a class="header" href="#데이터-암호화하기">데이터 암호화하기</a></h4>
<ul>
<li>비트 연산자에는 XOR(^)연산자가 있다.</li>
<li>이 연산자는 연산되는 비트 값이 서로 같으면 0이고 다르면 1이 되는 특성을 가지고 있다.</li>
<li>다음 그림처럼 0x56이 있는데 이 값과 0x37을 XOR 연산하면 0x61이라는 전혀 새로운 값이 나온다.</li>
<li>그런데 0x61과 0x37을 다시 XOR 연산하면 처음 값인 0x56이 나온다.</li>
</ul>
<p><img src="./images/data_cryto.png" alt="데이터 암호화하기" /></p>
<ul>
<li>XOR 연산자는 이런 연산 특징 때문에 간단한 암호화 데이터를 만들 때 많이 사용된다.</li>
<li>위와 같이 암호화하는 것을 '8비트 암호화'라고 한다.</li>
<li>보안성을 더 높이고 싶다면 암호에 사용하는 비트 개수를 더 늘리면 된다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-지역-변수와-전역-변수"><a class="header" href="#11-지역-변수와-전역-변수">11. 지역 변수와 전역 변수</a></h1>
<ul>
<li>C 언어는 대부분의 변수를 함수 안에 선언해서 사용한다.</li>
<li>함수가 작업의 기본 단위이기 때문이다.</li>
<li>하지만 모든 변수를 함수 안에 선언하는 것은 아니다.</li>
<li>변수의 사용 목적에 따라 함수 밖에서도 변수를 선언할 수 있다.</li>
<li>선언 위치에 따라 달라지는 변수의 종류와 특성, 그에 따라 변수의 수명(Lifetime)이 어떻게 달라지는지 알아보자.</li>
<li>변수를 선언할 때 같이 사용하면 의미가 달라지는 <code>extern</code>, <code>static</code>, <code>const</code>키워드도 알아보자.</li>
</ul>
<h2 id="11-1-함수-안에서만-사용하는-지역-변수"><a class="header" href="#11-1-함수-안에서만-사용하는-지역-변수">11-1. 함수 안에서만 사용하는 지역 변수</a></h2>
<h3 id="지역-변수-살펴보기"><a class="header" href="#지역-변수-살펴보기">지역 변수 살펴보기</a></h3>
<ul>
<li>변수에는 두 종류가 있다.</li>
<li>함수 안에 사용하는 지역 변수, 프로그램 전체에서 사용할 수 있는 전역 변수가 있다.</li>
<li>함수 안에 선언한 변수나 매개변수는 지역 변수(Local Variable)이라고 하며, 이 변수는 자신을 선언한 함수가 호출될 때 메모리에 저장 공간이 만들어졌다가 함수 호출이 끝나면 함께 사라진다.</li>
<li>즉 함수와 같은 수명(Lifetime)을 가진다.</li>
<li>함수의 수명(생명 주기)은 함수가 호출된 시점부터 <code>return</code>또는 함수의 명령문 끝에 도달하여 함수가 종료될 때까지의 시점을 말한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int ReturnNum() {
    int num = 5;
    return num;
}

void main() {
    ReturnNum();  // main 함수에서 ReturnNum 함수를 호출한다
    printf(&quot;%d&quot;, num);  // num 값은 5가 될까?
}
</code></pre>
<ul>
<li>변수 <code>num</code>이 선언되지 않은 식별자라고 하면서 오류가 발생한다.</li>
<li><code>ReturnNum</code>함수가 호출될 때 함수 안에서 선언한 지역 변수 <code>num</code>이 메모리에 만들어졌다가 함수 호출이 끝나면서 사라져 버려 <code>main</code>함수에서는 변수 <code>num</code>을 쓸 수 없는 것이다.</li>
<li>즉 지역 변수는 자신을 선언한 함수 안에서만 사용할 수 있고 다른 함수에 선언된 지역 변수는 사용할 수 없다.</li>
</ul>
<h3 id="지역-변수-이름은-중복해서-사용할-수-있다"><a class="header" href="#지역-변수-이름은-중복해서-사용할-수-있다">지역 변수 이름은 중복해서 사용할 수 있다</a></h3>
<ul>
<li>함수 안에 똑같은 이름의 변수가 있으면 오류로 처리된다.</li>
<li>하지만 서로 다른 함수에 선언된 변수라면 이름이 같아도 상관없다.</li>
<li>지역 변수는 특정한 '지역'에서만 사용하고 그 수명이 다하는 변수이기 때문이다.</li>
<li>예제: 변수의 사용 범위에 따른 유효성 이해하기</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int Sum(int data1, int data2) {  // 매개변수 data1, data2는 Sum 함수의 지역 변수
    // Sum 함수의 지역 변수 result를 선언한 후 data + data2 값으로 초기화함
    int result = data1 + data2;
    return result;
}

void main() {
    int result;  // main 함수의 지역 변수 result. 초기화되지 않아 어떤 값이 들어 있는지 모름
    result = Sum(5, 3);
    printf(&quot;5 + 3 = %d\n&quot;, result);
}
</code></pre>
<pre><code class="language-text">5 + 3 = 8
</code></pre>
<ul>
<li><code>main</code>함수의 <code>result</code>변수와 <code>Sum</code>함수의 <code>result</code>변수는 서로 다른 함수에 들어 있는 지역 변수이기 때문에 이름이 같아도 오류로 처리되지 않는다.</li>
<li>그리고 <code>main</code>함수에서는 <code>Sum</code>함수의 <code>data1</code>, <code>data2</code> 그리고 <code>result</code>변수를 사용할 수 없다.</li>
<li>지역 변수는 스스로 초기화되지 않기 때문에 필요할 때 프로그래머가 직접 초기화해야 한다.</li>
<li><code>main</code>함수의 <code>result</code>변수는 선언할 때 초기화하지 않았기 때문에 해당 변수에 어떤 값이 들어 있을지 예상할 수 없다.</li>
</ul>
<h2 id="11-2-프로그램-전체에서-사용하는-전역-변수"><a class="header" href="#11-2-프로그램-전체에서-사용하는-전역-변수">11-2. 프로그램 전체에서 사용하는 전역 변수</a></h2>
<h3 id="전역-변수-살펴보기"><a class="header" href="#전역-변수-살펴보기">전역 변수 살펴보기</a></h3>
<ul>
<li>함수 밖에 선언한 변수를 전역 변수(Global Variable)라고 한다.</li>
<li>이 변수는 프로그램이 시작할 때 만들어졌다가 프로그램이 종료될 때 함께 사라진다.</li>
<li>따라서 수명(Lifetime)이 프로그램과 같다.</li>
<li>전역 변수는 프로그램 전체 영역에서 사용할 수 있다.</li>
<li>그러므로 똑같은 이름을 가진 전역 변수가 프로그램 안에 또 있으면 오류로 처리된다.</li>
<li>전역 변수는 특별한 초기화 값이 없으면 0으로 초기화된다.</li>
<li>예제: 전역 변수를 사용하여 함수 간에 데이터 넘겨받기</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int result;  // 전역 변수. 특별한 초기화 값이 없으면 0으로 초기화됨

void Sum(int data1, int data2) {
    result = data1 + data2;
}

void main() {
    Sum(5, 3);
    printf(&quot;5 + 3 = %d\n&quot;, result);
}
</code></pre>
<pre><code class="language-text">5 + 3 = 8
</code></pre>
<ul>
<li>전역 변수는 한 번 선언하면 어떤 함수에서나 사용할 수 있으며, 프로그램 전체에서 값을 공유한다.</li>
<li>따라서 <code>return</code>명령을 사용하여 <code>Sum</code>함수의 반환값을 넘겨받지 않더라도 전역 변수의 값을 공유하여 간단하게 처리할 수 있다.</li>
</ul>
<h3 id="전역-변수를-사용할-때-주의할-점"><a class="header" href="#전역-변수를-사용할-때-주의할-점">전역 변수를 사용할 때 주의할 점</a></h3>
<ul>
<li>전역 변수를 사용하면 <code>Sum</code>함수는 <code>result</code>변수에 종속적으로 바뀌게 된다.</li>
<li><code>Sum</code>함수를 다른 프로그램에서 재사용하기 위해 코드를 복사하는 경우에 <code>result</code>변수 선언도 같이 옮겨야 하는데, 옮겨 갈 프로그램에 이미 <code>result</code>전역 변수가 있다면 둘 중 하나는 이름을 바꿔야 한다.</li>
<li>이는 재사용을 불편하게 한다.</li>
<li>따라서 전역 변수는 함수의 독립성을 강조하는 C 언어의 장점을 퇴색시킨다.</li>
</ul>
<blockquote>
<h4 id="전역-변수는-꼭-필요한-경우에만-사용하자"><a class="header" href="#전역-변수는-꼭-필요한-경우에만-사용하자">전역 변수는 꼭 필요한 경우에만 사용하자</a></h4>
<ul>
<li>특히 여러 라이브러리를 사용할 경우 전역 변수에 대한 중복 오류가 발생하면 문제 해결이 힘들다.</li>
<li>라이브러리 소스 코드는 직접 수정할 수 없기 때문에 불가능한 작업이다.</li>
<li>따라서 프로그램을 만들 때는 전역 변수는 꼭 필요한 경우에만 사용하는 습관을 들이자.</li>
</ul>
</blockquote>
<h3 id="지역-변수와-전역-변수의-이름이-같다면"><a class="header" href="#지역-변수와-전역-변수의-이름이-같다면">지역 변수와 전역 변수의 이름이 같다면?</a></h3>
<ul>
<li>변수의 이름 중복 문제는 지역 변수와 전역 변수 간에 더 큰 문제가 발생할 수 있다.</li>
<li>두 변수는 서로 성격이 달라서 이름이 같더라도 오류로 처리되지 않기 때문이다.</li>
<li>C 언어 문법은 전역보다 지역을 우선해서 처리한다.</li>
<li>따라서 지역 변수와 전역 변수의 이름이 같으면 지역 변수를 먼저 처리하기 때문에 주의가 필요하다.</li>
<li>예제: 전역 변수와 지역 변수의 이름이 같을 때 문제점 살펴보기</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int result;  // 전역 변수로 특별한 초기화 값이 없으면 0으로 초기화된다

void Sum(int data1, int data2) {
    int result;  // 지역 변수로 초기화되어 있지 않다
    // 지역 변수의 우선순위가 높기 때문에 연산 결과 값은 전역 변수 result가 아닌 지역 변수 result에 저장된다
    result = data1 + data2;
}

void main() {
    Sum(5, 3);
    printf(&quot;5 + 3 = %d\n&quot;, result);
}
</code></pre>
<pre><code class="language-text">5 + 3 = 0
</code></pre>
<ul>
<li><code>Sum</code>함수의 지역 변수 <code>result</code>와 전역 변수 <code>result</code>이름이 중복되었지만 변수 형식이 달라서 오류로 처리되지 않는다.</li>
<li>이름이 중복되는 경우에 지역 변수가 우선 처리되기 때문에 <code>data1 + data2</code>값은 지역 변수 <code>result</code>에 저장되고 전역 변수 <code>result</code>에는 아무 값도 대입되지 않는다.</li>
<li>따라서 전역 변수를 선언할 때 자동으로 초기화된 0값을 유지한다.</li>
<li>그렇기 때문에 <code>main</code>함수에서 전역 변수 <code>result</code>값을 출력하면 0이 나온다.</li>
<li><code>Sum</code>함수에서는 <code>result</code>가 전역 변수와 이름이 중복되어, 지역 변수나 전역 변수의 이름을 변경하기 전에는 전역 변수 <code>result</code>를 사용할 수 없다.</li>
<li>이런 문제가 근본적으로 발생하지 않도록 전역 변수 앞에 <code>g_</code>와 같은 접두어를 사용하여 <code>int g_result;</code>로 선언하는 것이 좋다.</li>
</ul>
<h2 id="11-3-extern-키워드"><a class="header" href="#11-3-extern-키워드">11-3. extern 키워드</a></h2>
<h3 id="소스-파일을-분리할-때-발생하는-오류"><a class="header" href="#소스-파일을-분리할-때-발생하는-오류">소스 파일을 분리할 때 발생하는 오류</a></h3>
<ul>
<li>프로그래밍을 하면서 소스 코드가 길어지면 파일 한개로 관리하는 것보다 여러 개의 파일로 나누어서 관리하는 것이 더 좋다.</li>
<li>연관이 높은 함수끼리 묶어서 파일 여러 개를 만들게 되면 소스 코드에 변경된 부분이 있을 떄에도 변경된 파일만 다시 컴파일하면 되므로 컴파일 드는 시간도 줄어든다.</li>
<li>예를 들어 위의 소스 코드에서 작업의 편의를 위해 <code>Sum</code>함수를 포함하는 <code>Sum.c</code>파일과 <code>main</code>함수를 포함하는 <code>Main.c</code>파일로 분리했다고 가정해 보자.</li>
<li>전역 변수를 그대로 가지고 있는 <code>Sum.c</code>파일은 오류가 나지 않지만, 파일이 분리되면서 전역 변수 선언을 참조하지 못하는 <code>Main.c</code>파일은 <code>result</code>를 사용한 위치에서 오류가 발생한다.</li>
<li>이 오류를 해결하기 위해 <code>Main.c</code>파일에 <code>int result;</code>라고 전역 변수를 또 추가하면 컴파일은 통과할 것이다.</li>
<li>하지만 링크할 때 프로젝트에 같은 이름의 전역 변수가 두 개 존재한다고 링크 오류가 발생한다.</li>
<li>이런 문제를 해결하려면 같은 프로젝트 안에 존재하는 전역 변수를 참조하겠다는 의미로 <code>extern</code>키워드를 사용해 <code>Main.c</code>파일에 <code>result</code>변수를 추가한다.<br></li>
</ul>
<blockquote>
<p><code>Sum.c</code>:</p>
<pre><code class="language-c">int result = 0;  // 전역 변수

void Sum(int data1, int data2) {
    result = data1 + data2;
}
</code></pre>
</blockquote>
<blockquote>
<p><code>Main.c</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

// Sum 함수 원형(Prototype)
void Sum(int, int);
extern int result;
void main() {
    Sum(5, 3);
    printf(&quot;5 + 3 = %d\n&quot;, result);
}
</code></pre>
</blockquote>
<h3 id="extern-키워드를-사용할-때-주의할-점"><a class="header" href="#extern-키워드를-사용할-때-주의할-점">extern 키워드를 사용할 때 주의할 점</a></h3>
<ul>
<li><code>extern</code>키워드를 사용할 때 주의할 점은 다음과 같다.</li>
</ul>
<blockquote>
<p><code>A.c</code>:</p>
<pre><code class="language-c">// 전역 변수들
int g_data1 = 0;
int g_data2 = 0;
int g_data5 = 0;
...
</code></pre>
<p><code>B.c</code>:</p>
<pre><code class="language-c">int g_data;  // 1.
extern int g_data2;  // 2.
extern int g_data3;  // 3.
extern int g_data4 = 0;  // 4.
extern int g_data5 = 0;  // 5.
...
</code></pre>
</blockquote>
<ol>
<li><code>A.c</code>파일에 같은 이름의 <code>g_data1</code>전역 변수가 있기 때문에 링크 오류가 발생한다.</li>
<li><code>A.c</code>파일에 선언된 <code>g_data2</code>전역 변수를 정상적으로 <code>extern</code>참조한다.</li>
<li><code>A.c</code>파일에 선언되지 않은 전역 변수를 <code>extern</code>참조했으므로 오류로 처리된다.</li>
<li><code>extern</code>참조에서 초기화를 사용했기 때문에 일반 전역 변수로 처리된다.(오류가 아니다)</li>
<li><code>extern</code>참조에서 초기화를 사용했기 때문에 일반 전역 변수로 처리된다. 그런데 <code>A.c</code>파일에도 <code>g_data5</code>전역 변수가 선언되어 있기 때문에 중복되었다고 오류로 처리된다.</li>
</ol>
<h2 id="11-4-static-키워드"><a class="header" href="#11-4-static-키워드">11-4. static 키워드</a></h2>
<ul>
<li>다른 사람들이 개발한 라이브러리에 포함된 전역 변수들의 문제라면 상황이 심각해질 수 있다.</li>
<li>이러한 문제가 발생하는 근본적인 이유는 전역 변수의 사용 범위가 프로그램 소스 전체 영역이기 때문이다.</li>
<li>그래서 C 언어는 전역 변수의 사용 범위를 제한할 수 있는 <code>static</code>키워드를 제공한다.</li>
</ul>
<h3 id="특정-소스-파일에서만-전역-변수-사용하기"><a class="header" href="#특정-소스-파일에서만-전역-변수-사용하기">특정 소스 파일에서만 전역 변수 사용하기</a></h3>
<ul>
<li>전역 변수를 선언하고 해당 전역 변수의 사용 범위를 변수를 선언한 소스 파일로 제한하고 싶다면 전역 변수 앞에 <code>static</code>키워드를 사용하면 된다.</li>
<li>이렇게 하면 다른 소스 파일에서 이 전역 변수에 <code>extern</code>키워드를 사용할 수 없을 뿐만 아니라 같은 이름의 전역 변수를 다른 소스 파일에서 선언해도 오류가 발생하지 않는다.</li>
<li>즉 같은 이름의 전역 변수를 두 개 선언하더라도 <code>static</code>키워드를 사용하면 둘 다 별개의 전역 변수로 사용할 수 있다.</li>
</ul>
<blockquote>
<p><code>A.c</code>:</p>
<pre><code class="language-c">// 전역 변수들
int g_data1 = 0;
static int g_data2 = 0;
static int g_data3 = 0;
...
</code></pre>
<p><code>B.c</code>:</p>
<pre><code class="language-c">int g_data1;  // 1.
int g_data2;  // 2.
extern int g_data3;  // 3.
...
</code></pre>
</blockquote>
<ol>
<li><code>A.c</code>파일에 같은 이름의 <code>g_data1</code>전역 변수가 있기 때문에 링크 오류가 발생한다.</li>
<li><code>A.c</code>파일의 <code>g_data2</code>와 <code>B.c</code>의 <code>g_data2</code>는 <code>static</code>으로 구별되어 별개의 전역 변수로 처리된다.</li>
<li><code>g_data3</code>는 <code>static</code>으로 선언된 전역 변수라서 <code>extern</code>참조할 수 없기 때문에 오류로 처리된다.</li>
</ol>
<blockquote>
<h4 id="소스-코드가-세-개-이상의-파일로-나뉜다면"><a class="header" href="#소스-코드가-세-개-이상의-파일로-나뉜다면">소스 코드가 세 개 이상의 파일로 나뉜다면?</a></h4>
<ul>
<li>소스 코드가 세 개의 파일 <code>A.c</code>, <code>B.c</code>, <code>C.c</code>로 구분되어 있는 경우에, <code>A.c</code>파일에 <code>static int g_data;</code>형식으로 전역 변수를 선언하고 <code>B.c</code>파일에 <code>int g_data;</code>형식으로 전역 변수를 선언했다면 두 <code>g_data</code>전역 변수는 별개로 사용되기 때문에 선언 오류가 발생하지 않는다.</li>
<li>그리고 <code>B.c</code>파일에 선언한 <code>g_data</code>전역 변수는 <code>A.c</code>파일에는 같은 이름의 전역 변수가 있어서 사용할 수 없고, <code>B.c</code>파일에서는 당연히 사용할 수 있다.</li>
<li><code>C.c</code>파일에서는 <code>extern</code>키워드로 <code>g_data</code>전역 변수를 사용할 수 있다.</li>
</ul>
</blockquote>
<h3 id="특정-함수에서만-전역-변수-사용하기"><a class="header" href="#특정-함수에서만-전역-변수-사용하기">특정 함수에서만 전역 변수 사용하기</a></h3>
<ul>
<li>전역 변수를 특정 함수 안에서만 사용하고 싶다면 해당 전역 변수를 사용하고 싶은 함수로 옮기고 그 앞에 <code>static</code>키워드를 적어주면 된다.</li>
<li>함수 안에 선언한 변수들은 지역 변수로 처리되어 함수가 호출될 때 만들어지고 호출이 끝나면 사라지지만, <code>static</code>키워드를 사용한 지역 변수는 전역 변수로 처리되어 호출 여부에 상관없이 자신이 가지고 있는 값을 유지한다.</li>
</ul>
<blockquote>
<h4 id="1-지역-변수를-사용한-경우"><a class="header" href="#1-지역-변수를-사용한-경우">1. 지역 변수를 사용한 경우</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void Test() {
    int data = 0;
    printf(&quot;%d, &quot;, data++);
}

void main() {
    int i;
    for(i = 0; i &lt; 5; i++) Test();
}
</code></pre>
<pre><code class="language-text">0, 0, 0, 0, 0,
</code></pre>
<ul>
<li><code>Test</code>함수에 사용한 <code>data</code>변수는 지역 변수라서 함수가 호출될 때마다 만들어지고 0으로 초기화된다.</li>
<li>따라서 그 값을 출력하면 0이 나온다.</li>
<li><code>data++</code>를 사용하는 코드가 있지만 함수 호출이 끝나면 <code>data</code>변수도 사라지기 때문에 이 값은 유지되지 않는다.</li>
<li>그래서 출력 결과가 0만 나오게 된다.</li>
</ul>
<h4 id="2-static--지역-변수를-사용한-경우"><a class="header" href="#2-static--지역-변수를-사용한-경우">2. static + 지역 변수를 사용한 경우</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void Test() {
    static int data = 0;
    printf(&quot;%d, &quot;, data++);
}

void main() {
    int i;
    for(i = 0; i &lt; 5; i++) Test();
}
</code></pre>
<pre><code class="language-text">0, 1, 2, 3, 4,
</code></pre>
<ul>
<li><code>Test</code>함수에 사용한 <code>data</code>변수는 앞에 <code>static</code>키워드를 사용해 이 함수에서만 사용할 수 있는 전역 변수이다.</li>
<li>따라서 <code>Test</code>함수의 호출 여부와 상관없이 <code>data</code>변수는 자신의 값을 유지하기 때문에 처음 호출되었을때는 0이 출력되지만, <code>data++</code>코드가 적용되어 다음 호출할 때에는 1씩 증가한 값이 출력된다.</li>
</ul>
</blockquote>
<h4 id="const-키워드도-알아-두자"><a class="header" href="#const-키워드도-알아-두자">const 키워드도 알아 두자!</a></h4>
<ul>
<li>프로그래밍을 하다 보면 자신이 만든 함수를 다른 사람에게 제공하는 경우가 있다.</li>
<li>이런 경우 함수를 사용할 때 주의 사항을 매뉴얼로 만들어서 제공하거나 소스 코드에 주석을 달아서 알려 준다.</li>
<li>예를 들어 다음과 같이 <code>GetArea</code>함수를 제공할 때, 이 함수의 첫 번째 인자 값은 변경하지 말라고 주석으로 강조해 두었다.</li>
<li>그런데 사용자가 그 뜻을 잘못 파악했거나 실수로 첫 번째 인자의 값을 바꾸게 되면 이것에 대해서 오류가 나지 않기 때문에 버그가 생기더라도 찾기가 쉽지 않다.</li>
</ul>
<pre><code class="language-c">// GetArea 함수의 첫 번째 인자 pi값은 절대 변경하지 말 것
double GetArea(double pi, double radius, int limit) {
    double result;
    pi = 3.14;  // 사용자가 임의로 바꾸면 안 될 부분
    result = pi * radius * radius;
    return result;
}
</code></pre>
<ul>
<li>그래서 주의사항을 좀 더 강력하게 알려주기 위해 변경하지 말아야 할 변수를 변경하는 경우에 문법적으로 오류가 발생하도록 <code>const</code>키워드를 사용한다.</li>
</ul>
<h4 id="const-키워드를-사용하는-방법"><a class="header" href="#const-키워드를-사용하는-방법">const 키워드를 사용하는 방법</a></h4>
<ul>
<li><code>const</code>키워드는 constant의 약자로, 변수를 상수처럼 쓰고 싶을 때 사용한다.</li>
<li>변수를 상수처럼 사용한다는 뜻은 변수의 값을 변경하지 않겠다는 의미이다.</li>
<li>만약 프로그래머가 실수로 <code>const</code>가 명시된 변수 값을 변경하면 번역할 때 오류가 발생한다.</li>
</ul>
<pre><code class="language-c">// GetArea 함수의 첫 번째 인자 pi값은 절대 변경하지 말 것
double GetArea(const double pi, double radius, int limit) {
    double result;
    pi = 3.14;  // const 변수를 사용자가 임의로 변경하면 번역할 때 오류 불생
    result = pi * radius * radius;
    return result;
}
</code></pre>
<ul>
<li>결국 <code>const</code>키워드는 변수의 속성이나 기능 자체를 변경하는 것이 아니다.</li>
<li>컴파일할 때 <code>const</code>키워드를 사용한 변수의 값이 변경되면 프로그래머에게 문법 오류로 알려 주는 역할을 한다.</li>
<li>즉 소스 코드를 작성한 사람의 의도를 분명하게 표현하는 문법이며 실수 방지를 위해 사용한다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-배열과-문자열"><a class="header" href="#12-배열과-문자열">12. 배열과 문자열</a></h1>
<h2 id="12-1-배열"><a class="header" href="#12-1-배열">12-1. 배열</a></h2>
<h3 id="배열이란"><a class="header" href="#배열이란">배열이란?</a></h3>
<ul>
<li>똑같은 자료형으로 많은 수의 변수를 선언하고 사용할 때는 나열식 표현에 한계가 있다.</li>
<li>그래서 C 언어는 데이터를 그룹으로 묶어서 표현하는 '배열'(Array)문법을 사용한다.</li>
</ul>
<h3 id="배열-선언하고-사용하기"><a class="header" href="#배열-선언하고-사용하기">배열 선언하고 사용하기</a></h3>
<ul>
<li>학생 20명의 성적을 저장하기 위해 다음과 같이 배열을 선언한다</li>
</ul>
<pre><code class="language-c">short student[20];
</code></pre>
<ul>
<li><code>short student[20];</code>은 2바이트 정수형 데이터 20개를 저장할 수 있는 배열을 <code>student</code>이름을 선언한다는 뜻이다.</li>
<li>배열을 선언하는 방법은 변수를 선언하는 방법과 비슷하다.</li>
<li>다만 <code>[]</code>기호(대괄호)를 사용하여 저장 공간을 몇 개 만들 것인지 명시하는 것만 다르다.</li>
<li>이때 데이터를 저장할 요소 개수는 반드시 숫자 상수로 명시해야 한다.</li>
<li>배열은 그룹으로 묶인 데이터를 하나의 변수로 관리한다</li>
<li>여기에서 <code>student</code>는 <code>short</code>형 변수 20개를 선언한 것과 같다.</li>
<li><code>short</code>형은 2바이트이므로 <code>student</code>변수는 총 40바이트 크기로 만들어진다.</li>
<li>개별 요소에 접근하기 위해서는 변수 이름 뒤에 <code>[]</code>를 적고 자신이 사용하고 싶은 요소의 색인(Index)을 명시하면 된다.</li>
<li>색인은 0부터 시작해서 1씩 증가한다.</li>
<li>만약 요소가 5개라면 색인을 0, 1, 2, 3, 4까지 사용할 수 있다.</li>
<li>따라서 <code>student</code>배열의 첫 번째 저장 공간은 <code>student[0]</code>이 된다.</li>
</ul>
<h4 id="배열의-특정-요소에-값-대입하기"><a class="header" href="#배열의-특정-요소에-값-대입하기">배열의 특정 요소에 값 대입하기</a></h4>
<ul>
<li>배열에 값을 저장하려면 <code>[]</code>기호를 사용해서 특정 요소의 위치를 명시해주어야 한다.</li>
<li>예를 들어 배열의 두 번째 항목에 10을 넣고 싶다면 다음과 같이 대입 명령문을 써주면 된다.</li>
</ul>
<pre><code class="language-c">student[1] = 10;
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    short student[20];

    student[1] = 10;  // 배열의 두 번째 요소에 10을 대입한다
    printf(&quot;%d\n&quot;, student[1]);
}
</code></pre>
<pre><code class="language-text">10
</code></pre>
<blockquote>
<h4 id="배열을-선언할-때-주의할-점은-무엇일까"><a class="header" href="#배열을-선언할-때-주의할-점은-무엇일까">배열을 선언할 때 주의할 점은 무엇일까?</a></h4>
<ul>
<li>일반 변수는 변수 크기가 자료형에 따라 결정되기 때문에 컴파일러가 소스를 컴파일하는 시점에 변수 크기를 계산하는 데 전혀 문제가 없다.</li>
<li>그런데 배열 문법으로 선언한 변수는 자료형과 []안에 적힌 숫자를 곱해서 변수의 크기를 결정한다.</li>
<li>따라서 배열 문법으로 변수를 선언할 때 컴파일러가 다음 문장만으로 배열 변수의 크기를 계산할 수 있도록 []안에 반드시 상수를 적어주어야 한다.</li>
</ul>
<pre><code class="language-c">short student[20];  // short형(2바이트) x 20 = 40바이트
</code></pre>
<ul>
<li>C 언어에서 지역 변수의 메모리 크기는 '스택 프레임'을 구성하는 데 중요한 판단 기준이기 때문에 컴파일할 때 프로그램에서 변수들이 사용할 전체 메모리 크기를 반드시 결정할 수 있어야 한다.</li>
<li>'스택 프레임'이란 C 언어가 지역 변수를 관리하는 규칙이며 16-2에서 자세히 공부하자.</li>
</ul>
</blockquote>
<ul>
<li>만약 다음과 같이 <code>[]</code>안에 상수를 적지 않고 <code>count</code>라는 변수를 적으면 <code>count</code>변수에 저장된 값에 따라 <code>student</code>변수의 크기가 달라진다.</li>
<li>따라서 컴파일러는 컴파일하는 시점에 <code>student</code>변수의 크기를 결정할 수 없기 때문에 오류가 발생한다.</li>
</ul>
<pre><code class="language-c">int count = 20;
short student[count];  // short student[20]; 으로 적어야 오류가 해결됨
error C2057: 상수 식이 필요합니다.
error C2466: 상수 크기 0의 배열을 할당할 수 없습니다.
error C2133: 'student': 알 수 없는 크기입니다.
</code></pre>
<ul>
<li><code>count</code>변수가 바로 위에 선언되어 있고 20이라는 값이 대입되어 있는데 <code>short student[count];</code>의 크기를 컴파일러가 왜 계산하지 못하지?</li>
<li>컴파일 작업은 단순히 C 언어로 된 명령문을 기계어로 번역하는 작업이기 때문에 소스 코드에 선언된 변수가 현재 어떤 값을 저장하고 있는지를 알 필요가 없다.</li>
<li>즉 변수가 어떤 값을 가지고 있는지는 프로그램이 실행될 때 필요한 것이지 컴파일 작업과는 아무 상관이 없다.</li>
<li>따라서 컴파일 시점에 컴파일러는 <code>count</code>변수에 어떤 값이 들어 있는지 알 수 없다.</li>
</ul>
<h4 id="배열-요소에-for문으로-값-대입하기"><a class="header" href="#배열-요소에-for문으로-값-대입하기">배열 요소에 for문으로 값 대입하기</a></h4>
<ul>
<li>배열을 선언할 때는 <code>[]</code>안에 꼭 상수를 써주어야 한다.</li>
<li>그러나 배열의 특정 요소에 값을 대입할 때는 <code>[]</code>안에 변수를 사용할 수 있다.</li>
</ul>
<pre><code class="language-c">int index = 1;
student[index] = 10;  // student[1] = 10; 과 같은 의미
</code></pre>
<ul>
<li>배열의 요소에 값을 대입하거나 사용할 때 상수뿐만 아니라 변수를 사용할 수 있다는 것은 반복문과 같은 제어 문법을 함께 사용할 수 있다는 뜻이다.</li>
</ul>
<pre><code class="language-c">short student[20], i++;
for(i = 0; i &lt; 5; i++) student[i] = 5;
</code></pre>
<h3 id="배열-초기화하기"><a class="header" href="#배열-초기화하기">배열 초기화하기</a></h3>
<ul>
<li>배열 문법은 지역 변수를 그룹으로 묶은 것이기 때문에 배열 문법으로 선언한 변수도 지역 변수처럼 자동으로 초기화되지 않는다.</li>
<li>그래서 배열의 각 요소에 일정한 값을 대입하여 초기화해서 사용해야 한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    short student[20];

    student[1] = 10;
    printf(&quot;%d %d\n&quot;, student[1], student[2]);
}
</code></pre>
<pre><code class="language-text">10 120
</code></pre>
<ul>
<li>배열의 요소를 초기화하지 않으면 예상하지 못한 엉뚱한 값이 들어가게 된다.</li>
<li>일반적으로 프로그래머들은 초기값으로 0을 사용한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    short student[20], i;
    for (i = 0; i &lt; 20; i++) student[i] = 0;

    student[1] = 10;
    printf(&quot;%d %d\n&quot;, student[1], student[2]);
}
</code></pre>
<pre><code class="language-text">10 0
</code></pre>
<h4 id="쉼표를-사용한-배열-초기화-문법"><a class="header" href="#쉼표를-사용한-배열-초기화-문법">쉼표를 사용한 배열 초기화 문법</a></h4>
<ul>
<li>배열을 초기화하는 데 매번 반복문을 사용하기가 불편하다.</li>
<li>배열로 선언한 변수도 일반 변수처럼 초기화하는 방법이 있다.</li>
<li><code>{}</code>로 묶어서 초기값들을 저장한다.</li>
</ul>
<pre><code class="language-c">short student[20] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
</code></pre>
<ul>
<li>C 언어에서는 초기값을 0으로 사용하는 것이 일반적이기 때문에 <code>{}</code>안에 다음과 같이 적어 주면 ,(쉼표)뒤에 있는 모든 값이 0으로 초기화된다.</li>
</ul>
<pre><code class="language-c">short student[20] = {0,};
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    short student[20] = {0,};  // 반복문 대신 쉼표를 사용해 배열의 모든 요소를 0으로 초기화한다.

    student[1] = 10;
    printf(&quot;%d %d\n&quot;, student[1], student[2]);
}
</code></pre>
<pre><code class="language-text">10 0
</code></pre>
<ul>
<li>쉼표를 사용하여 배열의 요소들을 초기화할 때 주의해야 할 점이 있다.</li>
<li>만약 배열의 모든 요소를 3으로 초기화하고 싶은 경우 다음과 같이 코드를 만들면 어떻게 될까?</li>
</ul>
<pre><code class="language-c">short data[5] = {3,};  // short data[5] = {3, 0, 0, 0, 0}; 과 같음
</code></pre>
<ul>
<li>,(쉼표)뒤를 생략하면 초기화되는 값은 0으로 고정되어 있다.</li>
<li>배열의 요소가 많은 경우에 0 아닌 다른 값으로 초기화하고 싶다면 반복문을 쓰는 것이 좋다.</li>
</ul>
<h4 id="배열-크기-생략하기"><a class="header" href="#배열-크기-생략하기">배열 크기 생략하기</a></h4>
<ul>
<li>배열을 선언할 때 <code>[]</code>안의 요소 개수를 생략하고 다음과 같이 쓸 수도 있다.</li>
</ul>
<pre><code class="language-c">short data[] = {1, 2, 1, 2, 1};
</code></pre>
<ul>
<li>이 경우에 <code>{}</code>안에 나열된 항목이 5개이므로 5개의 저장 공간이 만들어진다.</li>
<li>이처럼 초기화에 사용하는 요소 개수만 정확하게 명시되면 배열의 크기를 생략할 수 있다.</li>
</ul>
<blockquote>
<h4 id="초기화-문법은-배열-변수를-선언할-때만-사용하자"><a class="header" href="#초기화-문법은-배열-변수를-선언할-때만-사용하자">초기화 문법은 배열 변수를 선언할 때만 사용하자</a></h4>
<ul>
<li>배열의 각 요소를 초기화할 때 <code>{}</code>를 사용하기 때문에 배열의 특정 요소에 값을 지정할 때 <code>{}</code>를 사용해도 된다고 착각하기 쉽다.</li>
<li><code>{}</code>는 다음과 같이 사용할 수 없다.</li>
</ul>
<pre><code class="language-c">short student[20];
student[1] = {5};  // error C2059: 구문 오류: '{'
student[2] = {6, 7};  // error C2059: 구분 오류: '{'
</code></pre>
</blockquote>
<h3 id="배열의-요소-값-사용하기"><a class="header" href="#배열의-요소-값-사용하기">배열의 요소 값 사용하기</a></h3>
<ul>
<li>배열에 저장된 요소 값을 읽어오거나 요소 값끼리 연산할 수도 있다.</li>
</ul>
<pre><code class="language-c">short data[3];
data[0] = 2;   // data 배열의 0번째 요소에 2를 대입함
data[1] = data[0] + 5;  // data[0]에 2가 저장되어 있으므로 data[1]에 7이 저장됨
data[2] = data[0] + data[1];  // 2 + 7의 값 9가 data[2]에 저장됨
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    // data 배열을 1~5 값으로 초기화함
    char data[5] = {1, 2, 3, 4, 5};
    // 합한 값을 저장할 result 변수를 0으로 초기화함
    int result = 0, i;

    // 배열의 각 요소 값을 result 변수에 합하는 과정을 다섯 번 반복함
    for (i = 0; i &lt; 5; i++) {
        result = result + data[i];
    }

    // 합한 결과 값을 출력함
    printf(&quot;data 배열의 각 요소의 합은 %d입니다\n&quot;, result);
}
</code></pre>
<pre><code class="language-text">data 배열의 각 요소의 합은 15입니다
</code></pre>
<h4 id="배열은-사용자-정의-자료형이다"><a class="header" href="#배열은-사용자-정의-자료형이다">배열은 사용자 정의 자료형이다</a></h4>
<ul>
<li>배열은 같은 크기의 메모리를 그룹으로 묶어 새로운 크기의 변수를 만들기 때문에 '사용자 정의 자료형'(User-defined Data Type)이라고 부른다.</li>
<li>다음처럼 <code>char</code>형은 1바이트 크기이지만 <code>char three[3]</code>이란 배열을 선언하면 3바이트 자료형이 새롭게 만들어지는 것이다.</li>
</ul>
<pre><code class="language-c">char three[3];  // three는 3바이트 크기의 변수, three의 자료형이 char[3]이 됨
</code></pre>
<ul>
<li>따라서 C 문법이 기본으로 제공하는 자료형으로는 표현할 수 없던 3바이트, 5바이트 크기의 변수도 배열을 사용하면 자유롭게 만들 수 있다.</li>
</ul>
<h2 id="12-2-문자열"><a class="header" href="#12-2-문자열">12-2. 문자열</a></h2>
<h3 id="배열로-문자열-표현하기"><a class="header" href="#배열로-문자열-표현하기">배열로 문자열 표현하기</a></h3>
<ul>
<li>문자열은 간단히 말하면 문자의 집합을 뜻한다.</li>
<li>자료형이 같은 변수를 대량으로 선언하고 사용할 때 자료를 묶어서 표현하는 것이 바로 배열이었다.</li>
<li>문자열도 이 배열을 사용해 표현할 수 있다.</li>
</ul>
<blockquote>
<h4 id="문자열의-길이와-배열의-크기는-어떻게-다를까"><a class="header" href="#문자열의-길이와-배열의-크기는-어떻게-다를까">문자열의 길이와 배열의 크기는 어떻게 다를까?</a></h4>
<ul>
<li>문자열은 길이(Length)를 기준 단위로 사용하고, 배열은 크기(size)를 기준 단위로 사용한다.</li>
</ul>
</blockquote>
<h4 id="문자열의-길이-정보-표시하기"><a class="header" href="#문자열의-길이-정보-표시하기">문자열의 길이 정보 표시하기</a></h4>
<ul>
<li>C 언어에서 문자를 저장하는 데 가장 적합한 자료형은 <code>char</code>형이다.</li>
<li>그래서 문자열을 저장하려면 <code>char</code>형 변수를 그룹으로 묶어서 관리하는 <code>char</code>배열을 사용해야 한다.</li>
<li>배열을 이용해서 문자열을 저장하려면 문자 정보 외에도 배열에 몇 개의 문자가 있는지 함께 저장해야 한다.</li>
<li>하지만 문자열과 문자 개수 정보를 나누어서 관리하면 문자열을 표현하는 데 불편할 것이다.</li>
<li>따라서 입력하려는 문자의 끝에 NULL(널) 문자 0을 추가로 입력해서 '이 배열에 저장된 정보는 문자열이다'라고 컴파일러에게 알려준다.</li>
</ul>
<pre><code class="language-c">// 문자 개수는 5개이고 끝에 0을 덧붙여야 하므로 배열의 크기는 6
char data[6] = { 'h', 'a', 'p', 'p', 'y', 0 };
</code></pre>
<ul>
<li>여기에서 사용하는 0은 NULL문자(아스키코드 0번)을 의미하므로 작은따옴표 ''를 사용하지 않는다.</li>
<li>작은따옴표를 사용한 '0'은 일반적으로 사용하는 문자 '0'을 의미한다.</li>
<li>그런데 <code>{}</code>와 <code>''</code>을 사용하여 문자열에 포함된 문자를 하나씩 나열하는 것은 불편하기 때문에 다음과 같이 C 언어의 문자열형 상수 표현을 사용하여 단순하게 초기화할 수도 있다.</li>
</ul>
<pre><code class="language-c">char data[6] = &quot;happy&quot;;  // 이렇게 쓰면 문자열의 끝에 NULL 문자 0이 자동으로 포함됨
</code></pre>
<ul>
<li>문자열을 표현하기 위해 &quot;happy&quot;(문자열형 상수)라고 큰따옴표를 이용했다.</li>
<li>따라서 이 문자열이 차지하는 메모리 크기는 5바이트가 아니라 뒤에 NULL 문자 0이 자동으로 추가되어 6바이트이다.</li>
<li><code>char data[6] = {'h', 'a', 'p', 'p', 'y', 0};</code>과 <code>char data[6] = &quot;happy&quot;;</code>는 같은 뜻이다.</li>
</ul>
<blockquote>
<h4 id="문자열의-처리-속도를-높일-수-있다"><a class="header" href="#문자열의-처리-속도를-높일-수-있다">문자열의 처리 속도를 높일 수 있다!</a></h4>
<ul>
<li>다음 표현은 위에서 본 문자열 표현과 처리 결과가 같다.</li>
</ul>
<pre><code class="language-c">// 문자열 길이를 바로 알 수 있지만 변수를 두 개 사용해야 함
char data[5] = {'h', 'a', 'p', 'p', 'y'};
char data_length = 5;
</code></pre>
<ul>
<li>변수가 두 개인 까닭에 얼핏 불편해 보이지만, 문자열을 복사·비교·출력·저장하기 위한 처리 속도를 높이는 것이 중요하다면 이 표현으로 문자열을 저장하는 게 좋다.</li>
</ul>
</blockquote>
<ul>
<li><code>printf</code>함수로 문자열을 출력할 때 <code>%s</code>를 사용한다.</li>
<li><code>printf</code>함수는 지정한 메모리 그룹이 요소 값이 NULL 문자 0이 나올 때까지 문자들을 반복적으로 출력해 준다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char data[6] = {'h', 'a', 'p', 'p', 'y', 0};  // char data[6] = &quot;happy&quot;; 같은 표현임
    char ment[] = &quot;C programming!&quot;;  // []안의 15를 생략해도 됨

    printf(&quot;%s\n&quot;, data);
    printf(&quot;%s\n&quot;, ment);
}

</code></pre>
<pre><code class="language-text">happy
C programming!
</code></pre>
<blockquote>
<h4 id="null-문자는-0이라고-적어도-되고-0이라고-적어도-된다"><a class="header" href="#null-문자는-0이라고-적어도-되고-0이라고-적어도-된다">NULL 문자는 0이라고 적어도 되고 '\0'이라고 적어도 된다</a></h4>
<ul>
<li>문자열 정보를 저장하는 배열의 마지막에 추가로 입력하는 0은 NULL 문자 0(아스키코드 0번)을 의미한다.</li>
<li>우리가 평소에 사용하는 숫자 0은 아스키코드 48번이므로 헷갈리지 않도록 주의해야 한다.</li>
<li>그런데 문자열 끝에 입력하는 NULL 문자 0을 다음과 같이 <code>\0</code>으로 표현하는 경우도 있다.</li>
</ul>
<pre><code class="language-c">char data[6] = {'h', 'a', 'p', 'p', 'y', '\0'};
</code></pre>
<ul>
<li>왜 번거롭게 작은따옴표 <code>''</code>와 백슬래시()까지 붙이는 <code>\0</code>가 등장한 걸까?</li>
<li>우리는 컴퓨터에 문자를 입력하기 위한 입력 장치로 키보드를 사용한다.</li>
<li>3장에서 배운 아스키코드 표에 포함된 문자들을 모두 키보드로 입력할 수는 없다.</li>
<li>예를 들어 아스키코드 7번은 비프음을 발생시키는 문자인데 이런 문자는 키보드에 존재하지 않는다.</li>
<li>따라서 비프음을 발생시키는 소스 코드를 작성할 때는 다음과 같이 아스키코드를 직접 사용해야 한다.</li>
</ul>
<pre><code class="language-c">char beepsound = 7;
</code></pre>
<ul>
<li>만약 &quot;abcd&quot;라는 문자열이 있는데 c와 d문자 사이에 비프음(아스키코드 7번)을 넣고 싶다면 어떻게 해야 할까?</li>
<li>이런 경우 컴파일러에게 7이 아스키코드임을 알려주기 위해 다음과 같이 백슬래시()를 사용한다.</li>
</ul>
<pre><code class="language-c">char beepsound[6] = &quot;abc\7d&quot;;
</code></pre>
<ul>
<li>문자열 &quot;abc\7d&quot;를 작은따옴표를 사용하여 문자 하나씩 배열에 저장하는 방법은 다음과 같다.</li>
</ul>
<pre><code class="language-c">// \7은 비프음을 발생시키는 아스키 코드 7과 같음
char beepsound[6] = {'a', 'b', 'c', '\7', 'd', 0};
</code></pre>
<pre><code class="language-c">// 문자 하나씩 배열에 저장할 때는 기존 방식대로 아스키코드 번호를 그대로 적는 것이 편리함
char beepsound[6] = {'a', 'b', 'c', 7, 'd', 0};
</code></pre>
<ul>
<li>위와 같은 이유로 문자열 끝에 입력하는 NULL 문자 0도 <code>\0</code>으로 표현할 수 있는 것이다.</li>
</ul>
</blockquote>
<h4 id="저장된-문자열의-길이-구하기"><a class="header" href="#저장된-문자열의-길이-구하기">저장된 문자열의 길이 구하기</a></h4>
<ul>
<li>배열 크기가 항상 문자열의 길이와 같게 만들어지는 것은 아니기 때문에 배열에 저장된 문자열의 길이(문자의 개수)를 알기 위해서는 문자열의 끝(0, EOL, End Of Line)을 찾는 코드가 필요하다.</li>
<li>문자열의 길이를 계산하는 코드는 다음과 같다.</li>
</ul>
<pre><code class="language-c">char data[6] = &quot;happy&quot;;
int count = 0;
while (data[count] != 0) {  // data이 요소 값이 NULL 문자 0이면 문자열의 끝이라는 뜻임
    count++;  // 문자열의 끝이 아니면 문자 개수를 하나 증가시킴
}
</code></pre>
<ul>
<li>프로그래밍할 때 문자열 길이를 구하는 기능은 자주 사용하게 되므로 함수로 만들어 놓는 것이 더 좋다.</li>
<li>배열에 저장된 문자열의 길이를 구하는 함수 <code>GetStringLength</code>를 만들어 사용해 보자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int GetStringLength(char data[]) {
    int count = 0;
    // 0이 나올 때까지 문자의 개수를 더함
    while (data[count]) count++;  // while (data[count] != 0) count++; 와 같은 뜻임
    // 문자열의 길이를 반환함
    return count;
}

void main() {
    int data_length;  // 문자열 길이를 저장할 변수
    char data[10] = {'h', 'a', 'p', 'p', 'y', 0,};  // &quot;happy&quot; 문자열을 저장함
    // data 변수에 들어 있는 문자열의 길이를 구함
    data_length = GetStringLength(data);
    // 문자열의 길이(문자 개수)를 출력함
    printf(&quot;data length = %d\n&quot;, data_length);
}
</code></pre>
<pre><code class="language-text">data length = 5
</code></pre>
<ul>
<li>C 언어는 배열에 저장된 값을 다른 함수의 매개변수로 전달하는 문법을 제공하고 있다.</li>
<li><code>GetStringLength</code>함수에 매개변수를 <code>char data[]</code>형태로 선언하면, <code>main</code>함수의 <code>data</code>배열 변수를 참조할 수 있는 형태로 <code>data</code>변수가 선언되어 <code>main</code>함수의 <code>data</code>
변수에 저장되어 있던 값을 그대로 사용할 수 있다.</li>
<li>다른 변수의 내용을 참조하는 방법은 13장 포인터에서 배우자.</li>
<li><code>GetStringLength</code>함수를 호출할 때 배열의 이름(data)만 사용하면 된다.</li>
<li>그리고 배열의 값을 다른 함수에 전달하고 싶을 때는 배열의 이름만 매개변수로 전달하면 된다는 뜻이다.</li>
<li>이 작업의 동작 원리는 15장 배열과 포인터에서 자세하게 배우자.</li>
</ul>
<h3 id="문자열을-다루는-c-내장-함수"><a class="header" href="#문자열을-다루는-c-내장-함수">문자열을 다루는 C 내장 함수</a></h3>
<ul>
<li>문자열은 프로그램에서 자주 사용하기 때문에 편하게 사용할 수 있도록 C 언어에서 여러 함수들을 제공한다.</li>
<li>위의 예제에서 본 <code>GetStringLength</code>함수도 별도로 만들 필요 없이 C 언어와 함께 제공되는 문자열 표준 함수를 사용하면 편리하게 문자열의 길이를 구할 수 있다.</li>
<li>이렇게 제공되는 함수는 런타임 라이브러리에 포함되어 있으며, 그 수가 굉장히 많다.</li>
<li>이 함수들을 모두 외우거나 미리 공부할 필요는 없고, C 언어 개발 도구에서 해당 함수에 대한 설명을 볼 수 있다.</li>
<li>문자열 표준 함수의 이름은 string의 줄임 표현인 <code>str</code>라는 접두어로 시작한다.</li>
<li>문자열의 길이를 구하는 문자열 표준 함수는 <code>strlen</code>이다.</li>
<li>문자열을 복사하고 싶으면 copy의 줄임 표현인 <code>cpy</code>를 뒤에 붙여 만든 <code>strcpy</code>함수를 사용하면 된다.</li>
<li>문자열 뒤에 다른 문자열을 덧붙이는 함수 concatenation character의 줄임 표현인 <code>cat</code>을 뒤에 붙여 만든 <code>strcat</code>함수도 있다.</li>
</ul>
<pre><code class="language-c">strlen(문자열이 저장된 변수 이름)
strcpy(복사해서 저장할 변수 이름, 복사할 기존 변수 이름)
strcat(기존 문자열이 저장된 변수 이름, 새로 덧붙일 문자열)
</code></pre>
<ul>
<li>이렇게 <code>str</code>로 시작하는 문자열 표준 함수들은 <code>string.h</code>파일에서 함수의 원형을 제공하기 때문에, 이 함수들을 사용하려면 <code>#include</code>전처리기로 <code>string.h</code>파일을 소스 파일 안에 포함시켜야
한다.</li>
</ul>
<h4 id="문자열의-길이를-구하는-내장-함수-strlen"><a class="header" href="#문자열의-길이를-구하는-내장-함수-strlen">문자열의 길이를 구하는 내장 함수 strlen</a></h4>
<ul>
<li><code>strlen</code>함수는 NULL 문자(문자열 끝에 있는 0)를 제외한 문자열의 길이를 반환한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;  // 문자열 표준 함수를 사용하기 위해 추가함

void main() {
    int data_length;  // 문자열 길이를 저장할 변수
    char data[10] = {'h', 'a', 'p', 'p', 'y', 0,};  // &quot;happy&quot; 문자열을 저장함
    // data 변수에 들어 있는 문자열의 길이를 구함
    data_length = strlen(data);
    // 문자열의 길이(문자 개수)를 출력함
    printf(&quot;data length = %d\n&quot;, data_length);
}
</code></pre>
<pre><code class="language-text">data length = 5
</code></pre>
<h4 id="문자열을-복사하고-추가하는-내장-함수-strcpy-strcat"><a class="header" href="#문자열을-복사하고-추가하는-내장-함수-strcpy-strcat">문자열을 복사하고 추가하는 내장 함수 strcpy, strcat</a></h4>
<ul>
<li><code>strcpy</code>함수와 <code>strcat</code>함수를 사용하여 두 개의 문자열을 합쳐보자.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;  // 문자열 표준 함수를 사용하기 위해 추가함

void main() {
    char data[10] = {'a', 'b', 'c', 0,};  // &quot;abc&quot; 문자열을 저장함
    char result[16];  // 새로운 문자열을 저장할 변수

    strcpy(result, data);  // data에 저장된 문자열을 result로 복사함
    strcat(result, &quot;def&quot;);  // result값의 맨 뒤에 &quot;def&quot;를 덧붙임

    printf(&quot;%s + \&quot;def\&quot; = %s\n&quot;, data, result);
}
</code></pre>
<pre><code class="language-text">abc + &quot;def&quot; = abcdef
</code></pre>
<h2 id="12-3-2차원-배열"><a class="header" href="#12-3-2차원-배열">12-3. 2차원 배열</a></h2>
<h3 id="1차원-배열로-2차원-형태를-표현하려면"><a class="header" href="#1차원-배열로-2차원-형태를-표현하려면">1차원 배열로 2차원 형태를 표현하려면?</a></h3>
<ul>
<li>지금까지 사용한 배열은 1차원 배열이다.</li>
<li>바둑판에 놓인 돌의 좌표와 같은 정보는 가로와 세로가 있는 2차원 형태이다.</li>
<li>바둑판에 놓여 있는 돌의 정보를 저장하고 싶다면 돌 한 개의 정보를 어떤 형식의 변수에 저장할 것인지를 먼저 결정해야 한다.</li>
<li>돌의 정보는 돌이 놓여 있지 않으면 0, 검은 돌이 놓여 있으면 1, 흰 돌이 놓여 있으면 2와 같이 세 가지 경우로 나눌 수 있다.</li>
<li>따라서 1바이트인 <code>char</code>형으로도 충분히 이 세 가지 값을 구별하여 저장할 수 있다.</li>
<li>정보를 저장할 단위가 정해졌으니, 바둑판 전체를 저장할 수 있는 메모리 크기를 결정하기 위하여 데이터 개수를 계산해야 한다.</li>
<li>바둑판은 가로 19개, 세로 19개의 돌을 놓을 수 있기 때문에 총 351개(19x19)의 돌을 놓을 수 있다.</li>
<li>따라서 바둑판에 놓여 있는 돌의 정보를 저장하기 위해 다음과 같이 1차원 배열을 선언한다.</li>
</ul>
<pre><code class="language-c">char data[361];
</code></pre>
<ul>
<li>2차원 형태의 정보를 1차원 배열에 저장하기 위해서 한 행에 이어 그 다음 행을 저장하는 방식을 사용한다.</li>
<li>즉 <code>data</code>배열의 0번에서 18번까지 1행의 정보가 저장되고, 19번에서 37번까지 2행의 정보가 저장되는 방식이다.</li>
<li>각 배열의 요소에는 돌이 놓여 있지 않으면 0, 검은 돌이 놓여 있으면 1, 흰 돌이 놓여 있으면 2로 저장하면 2차원인 바둑판 정보를 <code>data</code>배열에 모두 저장할 수 있다.</li>
<li>그런데 이렇게 2차원 정보를 1차원 배열에 저장하면 소스 코드를 작성할 때 요소의 위치를 파악하기 어렵다.</li>
</ul>
<h3 id="2차원-배열의-필요성"><a class="header" href="#2차원-배열의-필요성">2차원 배열의 필요성</a></h3>
<ul>
<li>차원은 공간에서 좌표를 구성하는 축의 개수를 의미한다.</li>
<li>따라서 2차원은 좌표를 적을 때 2개의 축을 사용하고 각 축의 이름은 X축, Y축이며, X축은 수평 방향에 대한 기준 값이고 Y축은 수직 방향에 대한 기준 값이다.</li>
<li>2차원 공간에 있는 한 점(대상)은 자신의 위치를 좌표로 나타낼 때 (x축 좌표 값, y축 좌표 값)형태로 사용한다.</li>
<li>이와 같은 방법으로 '2차원 배열'에 2차원 형식의 데이터를 저장한다.</li>
<li>바둑판을 축소하여 5(행)x4(열)로 간단하게 살펴보자.</li>
</ul>
<p><img src="./images/2_dimensional_array_diagram_1.png" alt="5행 x 4열 바둑판" /></p>
<ul>
<li>위 바둑판에는 최대 20개의 돌을 놓을 수 있는 지점이 있다.</li>
<li>각 지점에는 세 가지 상황이 발생할 수 있다.</li>
<li>프로그램에서는 상태를 숫자로 표현해야 하기 때문에 각 상황을 0, 1, 2로 가정하자.</li>
</ul>
<pre><code class="language-text">놓인 돌이 없음 -&gt; 0이라고 가정함
검은 돌이 놓임 -&gt; 1이라고 가정함
흰 돌이 놓임  -&gt; 2라고 가정함
</code></pre>
<ul>
<li>세 가지 상황은 동시에 발생할 수 없으므로 0, 1, 2 중 하나를 저장할 수 있는 20개의 저장 공간이 필요하다.</li>
<li>세 가지 상황 중 한 가지를 저장하려면 <code>char</code>(1바이트, 256가지 경우 중에서 한 가지를 저장)형이면 충분하다.</li>
<li>따라서 다음과 같이 변수를 선언하면 총 20바이트의 메모리를 사용할 수 있기 때문에 위 바둑판의 상태를 모두 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">char data[20];  // 1차원 배열로 20바이트 크기의 변수를 선언함
</code></pre>
<ul>
<li>하지만 이렇게 2차원 형식의 데이터를 1차원 배열로 관리하면 프로그래밍하기 어렵다.</li>
<li>따라서 이런 경우에는 2차원 데이터와 표현 방식이 같은 2차원 배열을 사용하자.</li>
</ul>
<h3 id="2차원-배열-선언하기"><a class="header" href="#2차원-배열-선언하기">2차원 배열 선언하기</a></h3>
<pre><code class="language-c">char data1, data2, data3, data4;  // 4개의 변수를 개별적으로 선언함
</code></pre>
<pre><code class="language-c">char data[4];  // 4개의 변수를 그룹으로 묶어서 1차원 배열 형태로 선언함
</code></pre>
<pre><code class="language-c">// char[4] 형식의 1차원 배열 5개를 선언함
char data1[4], data2[4], data3[4], data4[4], data5[4];
</code></pre>
<ul>
<li>위와 같은 형식의 1차원 배열 5개를 묶으려면 어떻게 해야할까?</li>
<li>5개의 1차원 배열은 모두 <code>char[4]</code>형식으로 같기 때문에, 배열을 사용해서 묶을 수 있다.</li>
</ul>
<pre><code class="language-c">char data[5][4];  // char[4] 형식의 1차원 배열 5개를 묶어 2차원 배열로 선언함
</code></pre>
<p><img src="./images/2_dimensional_array_diagram_2.png" alt="2차원 배열" /></p>
<ul>
<li>1차원 배열을 선언할 때 대괄호 <code>[]</code>를 이미 사용했기 때문에, 한 번 더 묶으려면 대괄호 <code>[]</code>를 두 번 사용하면 된다.</li>
<li>이처럼 대괄호 <code>[]</code>를 두 번 사용해서 선언하는 배열이 바로 2차원 배열이다.</li>
<li>그런데 여기서 1차원 배열을 그룹으로 묶을 때 왜 <code>char data[4][5];</code>가 아니라 <code>char data[5][4];</code>라고 했을까?</li>
<li>그 이유는 연산자 우선순위 때문이다.</li>
<li><code>[]</code>연산자는 동일한 우선순위를 가질 때 왼쪽에서 오른쪽으로 연산을 수행한다.</li>
<li>즉 왼쪽에 있는 <code>[]</code>연산자를 먼저 처리하기 때문에 위에 선언한 <code>data</code>배열은 다음과 같이 선언한 것과 같다.</li>
</ul>
<pre><code class="language-c">char (data[5])[4];
</code></pre>
<ul>
<li>위에 선언한 2차원 배열을 컴파일러가 해석하는 순서에 따라 적어보면 다음과 같다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">1단계</th><th style="text-align: left">char(data[5])[4];</th><th style="text-align: left"><code>data[5]</code>라는 배열을 만들겠다는 뜻이다.<br> 즉 5개의 요소(2차원 배열에서는 전체 그룹의 개수)를 가지는 배열을 의미한다.</th></tr></thead><tbody>
<tr><td style="text-align: left">2단계</td><td style="text-align: left">char(data[5])[4];</td><td style="text-align: left">이 배열의 각 요소(<code>data[0]</code>, <code>data[1]</code>, ⋯ )는 <code>char[4]</code>크기를 가진다.<br> 즉 배열의 각 요소를 <code>char[4]</code>형식의 1차원 배열처럼 사용할 수 있다는 뜻이다.</td></tr>
</tbody></table>
</div>
<ul>
<li>위와 같이 선언한 배열은 다음과 같이 메모리에 나열된다.</li>
</ul>
<p><img src="./images/2_dimensional_array_diagram_3.png" alt="2차원 배열 메모리 나열 형태" /></p>
<ul>
<li>이렇게 선언한 <code>char data[5][4]</code>는 행이 5개이고 열이 4개인 2차원 배열이며, 각 요소에 <code>char</code>형으로 데이터를 저장할 수 있다.</li>
<li><code>data</code>변수의 크기는 <code>(자료형 크기) x (행 개수) x (열 개수)</code>이기 때문에 1 x 5 x 4 = 20 바이트이다.</li>
<li><code>data</code>변수의 논리적 메모리 형태를 그려보면 다음과 같다.</li>
</ul>
<p><img src="./images/2_dimensional_array_diagram_4.png" alt="2차원 배열 논리적 메모리 형태" /></p>
<ul>
<li><code>data</code>변수의 2번째 행, 3번째 열에 10이라는 값을 넣으려면 다음과 같이 적어주면 된다.</li>
</ul>
<pre><code class="language-c">data[1][2] = 10;
</code></pre>
<h4 id="2차원-배열이-실제-메모리에-저장되는-형태"><a class="header" href="#2차원-배열이-실제-메모리에-저장되는-형태">2차원 배열이 실제 메모리에 저장되는 형태</a></h4>
<ul>
<li>컴퓨터가 사용하는 메모리는 2차원 개념을 제공하지 않기 때문에 <code>data</code>변수를 위한 20바이트 메모리는 1차원 형태로 메모리에 저장된다.</li>
<li>그런데 소스 코드에서 2차원 형식으로 사용할 수 있는 이유는 C 언어의 2차원 배열 문법이 내부적으로 수학 공식을 사용해서 2차원 개념을 제공하기 때문이다.</li>
<li>즉 2차원 배열은 컴파일할 때 모두 1차원 형태로 변환된다.</li>
</ul>
<blockquote>
<h4 id="2차원-배열에서-행과-열-중-어떤-것을-먼저-처리하는-것이-효율적일까"><a class="header" href="#2차원-배열에서-행과-열-중-어떤-것을-먼저-처리하는-것이-효율적일까">2차원 배열에서 행과 열 중 어떤 것을 먼저 처리하는 것이 효율적일까?</a></h4>
<ul>
<li>2차원 배열을 사용하게 되면 행을 우선으로 처리할 것인지 또는 열을 우선으로 처리할 것인지에 따라 두 가지 형태로 선언할 수 있다.</li>
</ul>
<pre><code class="language-c">char data[5][4];  // 5행 4열: 행 단위로 묶음
또는
char data[4][5];  // 4열 5행: 열 단위로 묶음
</code></pre>
<ul>
<li>2차원 배열로 변수를 선언하면 배열의 각 요소를 사용하기 위해 <code>[]</code>연산자를 두 개씩 사용하기 때문에 x, y좌표 형식으로 접근할 수 있다.</li>
<li>예를 들어 2행 4열(좌표는 (4, 2))에 있는 검은색 돌을 <code>data</code>변수에 저장하려면 다음과 같이 적으면 된다.</li>
</ul>
<p><img src="./images/2_dimensional_array_diagram_5.png" alt="바둑판 예시" /></p>
<pre><code class="language-c">data[1][3] = 1;  // 행 단위로 묶음. 2행 4열에 검은 돌이 놓인 상태 값 1을 대입함. 좌표는 (4, 2)
</code></pre>
<pre><code class="language-c">data[3][1] = 1;  // 열 단위로 묶음. 4열 2행에 검은 돌이 놓인 상태 값 1을 대입함. 좌표는 (4, 2)
</code></pre>
<ul>
<li>코드를 보면 행을 그룹으로 묶은 경우에는 <code>data[행 번호 - 1][열 번호 - 1]</code>의 형식이고 열을 그룹으로 묶은 경우에는 <code>data[열 번호 - 1][행 번호 - 1]</code>의 형식이다.</li>
<li>이것을 좌표 형식으로 바꿔 보면 행을 그룹 지은 것은 <code>data[y좌표 - 1][x좌표 - 1]</code>의 형식이고 열을 그룹 지은 것은 <code>data[x좌표 - 1][y좌표 - 1]</code>의 형식이 될 것이다.</li>
<li>수학에서 좌표를 (x, y)형식으로 사용하기 때문에 x좌표가 먼저 나오는 열 단위로 묶은 형식이 더 친근할 수 있다.</li>
<li>하지만 컴퓨터도 그렇게 생각할까?</li>
</ul>
<h4 id="열-단위로-묶음"><a class="header" href="#열-단위로-묶음">열 단위로 묶음</a></h4>
<pre><code class="language-c">char data[4][5];  // (x좌표, y좌표) 형식
</code></pre>
<p><img src="./images/2_dimensional_array_diagram_6.png" alt="열 단위로 묶음" /></p>
<ul>
<li>위 그림에서 같은 색을 가지는 요소들이 X축 기준으로 같은 줄에 있는 요소들이다.</li>
<li>따라서 2행을 보면, 그림으로는 바로 옆에 있는 바둑돌들이 메모리에 저장될 때는 5바이트씩 떨어진 위치에 저장된다.</li>
<li>컴퓨터는 출력 효율을 높이기 위해서 하드웨어적으로 X축 기준으로 연산하도록 되어 있는데, 위와 같이 메모리를 관리하면 X축으로 1만큼 이동할 때마다 메모리상으로는 5바이트씩 이동해야 하는 불편함이 있다.</li>
<li>그리고 같은 줄에 있는 항목들이 한 그룹이 되지 못해서 그룹 연산을 사용하는 다양한 기본 함수(예를 들어 <code>memcpy</code>)들도 사용할 수 없다.</li>
</ul>
<h4 id="행-단위로-묶음"><a class="header" href="#행-단위로-묶음">행 단위로 묶음</a></h4>
<pre><code class="language-c">char data[5][4];  // (y좌표, x좌표) 형식
</code></pre>
<p><img src="./images/2_dimensional_array_diagram_7.png" alt="행 단위로 묶음" /></p>
<ul>
<li>프로그래밍할 때는 (y좌표, x좌표) 형식으로 사용해야 하는 불편함이 있을지 몰라도 그림에 표시된 2차원 형식의 데이터는 수평 방향으로 그룹으로 묶여 저장된다.</li>
<li>따라서 연산도 단순해지고 같은 줄의 데이터가 자연스럽게 한 그룹이 되기 때문에 관리하기도 더 편리하다.</li>
<li>그래서 2차원 형식의 데이터를 2차원 배열에 저장할 때는 행을 기준으로 묶는 방식을 더 많이 사용한다.</li>
</ul>
</blockquote>
<h3 id="2차원-배열-초기화하기"><a class="header" href="#2차원-배열-초기화하기">2차원 배열 초기화하기</a></h3>
<ul>
<li>다음 코드는 1차원 배열을 두 개 선언하고 각 배열을 1, 2, 3과 4, 5, 6으로 초기화하고 있다.</li>
<li>2차원 배열은 형식이 같은 1차원 배열을 그룹으로 묶는 문법이기 때문에 위와 같이 선언한 두 개의 1차원 배열을 다음과 같이 하나의 2차원 배열로 변경할 수도 있다.</li>
</ul>
<pre><code class="language-c">char temp1[3] = {1, 2, 3};
char temp2[3] = {4, 5, 6};
</code></pre>
<pre><code class="language-c">char temp[2][3];
</code></pre>
<ul>
<li>2차원 배열을 이용하여 <code>temp</code>변수를 선언했으니 초기화도 해 주어야 한다.</li>
<li>1차원 배열은 하나의 그룹으로 이루어져 있기 때문에 한 개의 <code>{}</code>로 초기화를 했지만 2차원 배열은 그룹 안에 또 다른 그룹이 있는 형태이기 때문에 <code>{}</code>을 중복으로 사용해야 한다.</li>
</ul>
<pre><code class="language-c">char temp[2][3] = {{1, 2, 3}, {4, 5, 6}};
</code></pre>
<p><img src="./images/2_dimensional_array_diagram_8.png" alt="2차원 배열 초기화하기" /></p>
<blockquote>
<h4 id="2차원-데이터와-1차원-데이터를-자유자재로-변환할-수-있다"><a class="header" href="#2차원-데이터와-1차원-데이터를-자유자재로-변환할-수-있다">2차원 데이터와 1차원 데이터를 자유자재로 변환할 수 있다</a></h4>
<ul>
<li>대부분의 경우에 컴파일러가 2차원 데이터를 1차원 형태의 기계어로 잘 번역해 준다.</li>
<li>하지만 프로그래머가 좀 더 적극적으로 상황에 대처하고 싶거나 프로그램 실행 성능을 향상시키기 위해 1차원 배열과 차원을 변환하는 수학 공식을 사용하여 직접 2차원 형태를 구성하기도 한다.</li>
<li>이 방식은 실제로 많이 사용되고 다양하게 응용되기 때문에 알아두자!</li>
</ul>
<h4 id="2차원-데이터를-1차원-데이터로-변환하기"><a class="header" href="#2차원-데이터를-1차원-데이터로-변환하기">2차원 데이터를 1차원 데이터로 변환하기</a></h4>
<ul>
<li>5행 4열 크기로 줄인 바둑판을 생각해 보자.</li>
<li>1행 1열부터 시작해서 1행 2열, 1행 3열의 순서로 돌을 9개 놓고 번호를 0번부터 1씩 증가시키면서 적어 보면 다음과 같이 된다.</li>
</ul>
<p><img src="./images/2_dimensional_array_diagram_9.png" alt="2차원 데이터를 1차원 데이터로 변환하기" /></p>
<ul>
<li>이렇게 돌에 번호를 매긴 이유는 이 번호가 결국 1차원 배열의 색인을 의미하기 때문이다.</li>
<li>1행을 보면 0~3번 돌이 놓였고 2행을 보면 4~7번 돌이 놓였다.</li>
<li>이 번호를 잘 살펴보면 행이 증가할 때마다 같은 열에 있는 돌의 번호가 4씩 증가한다는 것을 알 수 있다.</li>
<li>이것은 열의 개수가 4개이기 때문이다.</li>
<li>즉 열의 개수가 5개 였다면 행이 증가할 때마다 돌에 쓰인 번호가 5씩 증가했을 것이다.</li>
<li>각 행의 처음 위치에 놓인 돌의 번호를 수학 공식으로 정리해 보면 행 번호에서 1을 뺀 후 열의 개수를 곱한 것과 같다.</li>
</ul>
<pre><code class="language-text">(행 번호 - 1) x 열 개수
</code></pre>
<ul>
<li>2열, 3열, 4열에 있는 돌의 번호는 첫 번째 돌의 번호에 각 열 번호에서 1을 뺀 숫자를 더해 주면 된다.</li>
</ul>
<pre><code class="language-text">{(행 번호 - 1) x 열 개수} + 열 번호 - 1
</code></pre>
<ul>
<li>이제 본래 바둑판으로 돌아와서 같은 조건으로 돌이 놓여 있는 경우에 10행 9열에 놓인 돌의 번호를 계산하면 179번이라는 것을 알 수 있다(바둑판은 19개의 열로 되어 있다).</li>
</ul>
<pre><code class="language-text">{(10 - 1) x 19} + (9 - 1) = 179
</code></pre>
<ul>
<li>이 공식은 2차원 형식으로 되어 있는 데이터를 1차원 형식의 배열에 저장하고 싶을 때 모두 사용할 수 있다.</li>
<li>2차원 형식의 데이터는 평면 형태로 표시되는 모든 종류의 데이터가 다 포함될 수 있다.</li>
</ul>
<h4 id="1차원-데이터를-2차원-데이터로-변환하기"><a class="header" href="#1차원-데이터를-2차원-데이터로-변환하기">1차원 데이터를 2차원 데이터로 변환하기</a></h4>
<ul>
<li>1차원 데이터를 2차원 데이터로 변환하려면 행 번호와 열 번호를 계산해서 찾아야 한다.</li>
<li>먼저 행 번호를 찾는 방법부터 살펴보자.</li>
</ul>
<p><img src="./images/2_dimensional_array_diagram_9.png" alt="1차원 데이터를 2차원 데이터로 변환하기" /></p>
<ul>
<li>이 바둑판의 같은 행에 놓인 돌의 번호를 보면 4로 나누었을 때 몫이 같다는 것을 알 수 있다(몫을 구할 때는 반올림이 적용되지 않는다).</li>
<li>예를 들어 1행에 있는 돌들은 0/4, 1/4, 2/4, 3/4이기 때문에 모두 몫이 0이고,</li>
<li>2행에 있는 돌들은 4/4, 5/4, 6/4, 7/4이기 때문에 모두 몫이 1이다.</li>
<li>이때 4로 나눈 몫이 동일한 이유는 같은 행에 있는 돌의 번호가 열의 개수에 영향을 받기 때문이다.</li>
<li>이런 특징을 이용해서 돌의 번호로 행 번호를 찾는 방법은 다음과 같이 공식으로 정리할 수 있다.</li>
</ul>
<pre><code class="language-text">행 번호 = (돌 번호 / 열 개수) + 1
</code></pre>
<ul>
<li>이제 열 번호를 찾는 방법을 살펴보자.</li>
<li>같은 열에 있는 돌의 번호는 4로 나눈 나머지가 같다.</li>
<li>즉 1열에 있는 각 돌의 번호를 4로 나눈 나머지를 계산해 보면 0%4, 4%4, 8%4이기 때문에 나머지가 모두 0이다.</li>
<li>2열에 있는 각 돌의 번호를 4로 나눈 나머지를 계산해 보면 1%4, 5%4, 9%4이기 때문에 나머지가 모두 1이다.</li>
<li>그리고 이 나머지 값은 열이 증가할 때마다 1씩 증가하는 규칙이 있다.</li>
<li>따라서 돌 번호로 열 번호를 찾는 방버은 다음 공식을 사용하면 된다.</li>
</ul>
<pre><code class="language-text">열 번호 = (돌 번호 % 열 개수) + 1
</code></pre>
<ul>
<li>이제 본래 바둑판으로 돌아와서 같은 조건으로 돌이 놓여 있는 경우에 199번 돌은 (199 / 19) + 1, 즉 11행에 있고 (199 % 19) + 1, 즉 10열에 위치해 있다는 것을 알 수 있다.</li>
<li>이 공식은 1차원 형태로 되어 있는 데이터를 2차원 형식으로 표현하고 싶을 때 모두 사용할 수 있다.</li>
<li>2차원 배열은 메모리상에 1차원 형태로 데이터를 저장하면서 프로그래머가 이 메모리를 사용할 때 컴파일러가 수학 공식을 적용하여 2차원 개념을 제공하는 것이다.</li>
<li>따라서 메모리에 저장되는 형태만 놓고 보면 2차원 배열로 선언한 <code>temp</code>변수나 1차원 배열로 선언한 <code>test</code>변수는 메모리 형태가 같다.</li>
</ul>
<pre><code class="language-c">char temp[5][4];
char test[20];
</code></pre>
<ul>
<li>2차원 좌표를 1차원 좌표로 변환하는 공식이나 1차원 좌표를 2차원 좌표로 변환하는 공식을 이해하고 있다면 2차원 배열 문법에 의존하지 않고 1차원 배열을 사용해서도 얼마든지 2차원 데이터를 저장하고 관리할
수 있다.</li>
<li>1차원 배열로 어떻게 2차원 개념을 사용하는지 앞에서 배운 내용을 공식으로 만들어 보자.</li>
</ul>
<pre><code class="language-c">char temp[M][N];  // L, M, N 값은 숫자 상수로 가정함
char test[L];     // M * N 값이 L 값과 같다고 가정함
</code></pre>
<ul>
<li>위와 같이 <code>temp</code>변수는 2차원 배열로 선언되고 <code>test</code>변수는 1차원 배열로 선언된 경우에 다음과 같은 공식이 성립된다.</li>
</ul>
<pre><code class="language-text">test[a] 항복과 temp[a / N][a % N]항목은 위치가 같다.
temp[b][c] 항목과 test[b x N + c]항목은 위치가 같다.
</code></pre>
</blockquote>
<h3 id="1차원-배열과-2차원-배열의-차이"><a class="header" href="#1차원-배열과-2차원-배열의-차이">1차원 배열과 2차원 배열의 차이</a></h3>
<ul>
<li>지금까지 이야기한 바둑판을 3행 4열 형태로 축소시켜 놓고 돌이 놓여 있는 상황을 1차원 배열을 사용하여 초기값으로 저장한 후 바둑판의 상황을 출력해 보면 다음과 같다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char data[12] = {0, 0, 2, 0, 1, 1, 0, 0, 2, 1, 0, 2};
    int i, x, y;

    for (i = 0; i &lt; 12; i++) {
        x = i % 4 + 1;  // 열 번호를 구함
        y = i / 4 + 1;  // 행 번호를 구함
        printf(&quot;%d행 %d열에&quot;, y, x);
        if (1 == data[i]) printf(&quot; 검은 돌이 놓여 있습니다.\n&quot;);
        else if (2 == data[i]) printf(&quot; 흰 돌이 놓여 있습니다.\n&quot;);
        else printf(&quot;는 돌이 놓여 있지 않습니다.\n&quot;);
    }
}
</code></pre>
<pre><code class="language-text">1행 1열에는 돌이 놓여 있지 않습니다.
1행 2열에는 돌이 놓여 있지 않습니다.
1행 3열에 흰 돌이 놓여 있습니다.
1행 4열에는 돌이 놓여 있지 않습니다.
2행 1열에 검은 돌이 놓여 있습니다.
2행 2열에 검은 돌이 놓여 있습니다.
2행 3열에는 돌이 놓여 있지 않습니다.
2행 4열에는 돌이 놓여 있지 않습니다.
3행 1열에 흰 돌이 놓여 있습니다.
3행 2열에 검은 돌이 놓여 있습니다.
3행 3열에는 돌이 놓여 있지 않습니다.
3행 4열에 흰 돌이 놓여 있습니다.
</code></pre>
<h3 id="2차원-배열에-바둑판-정보-저장하기"><a class="header" href="#2차원-배열에-바둑판-정보-저장하기">2차원 배열에 바둑판 정보 저장하기</a></h3>
<ul>
<li>앞의 예제와 같은 결과가 나오도록 2차원 배열을 사용해서 재구성 해보자.</li>
<li>배열이 2차원으로 되어 있어서 선언된 형태만 보아도 행, 열 구별이 1차원보다는 잘될 것이다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    char data[3][4] = {{0, 0, 2, 0},
                       {1, 1, 0, 0},
                       {2, 1, 0, 2}};
    int x, y;

    for (y = 0; y &lt; 3; y++) {
        for (x = 0; x &lt; 4; x++) {
            printf(&quot;%d행 %d열에&quot;, y + 1, x + 1);
            if (1 == data[y][x]) printf(&quot; 검은 돌이 놓여 있습니다.\n&quot;);
            else if (2 == data[y][x]) printf(&quot; 흰 돌이 놓여 있습니다.\n&quot;);
            else printf(&quot;는 돌이 놓여 있지 않습니다.\n&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">1행 1열에는 돌이 놓여 있지 않습니다.
1행 2열에는 돌이 놓여 있지 않습니다.
1행 3열에 흰 돌이 놓여 있습니다.
1행 4열에는 돌이 놓여 있지 않습니다.
2행 1열에 검은 돌이 놓여 있습니다.
2행 2열에 검은 돌이 놓여 있습니다.
2행 3열에는 돌이 놓여 있지 않습니다.
2행 4열에는 돌이 놓여 있지 않습니다.
3행 1열에 흰 돌이 놓여 있습니다.
3행 2열에 검은 돌이 놓여 있습니다.
3행 3열에는 돌이 놓여 있지 않습니다.
3행 4열에 흰 돌이 놓여 있습니다.
</code></pre>
<ul>
<li>그렇다고 해서 2차원 배열이 1차원 배열 표현보다 더 좋다는 뜻은 아니다.</li>
<li>사람이 보기에 소스 코드가 간단하다고 해서 기계어로 된 코드도 간단한 것은 아니고, 데이터를 실질적으로 저장하는 물리적 메모리는 결국 1차원 형태이기 때문이다.</li>
<li>무엇이든 익숙하지 않으면 어렵게 느껴지기 마련이다.</li>
<li>하지만 어렵더라도 계속 사용하다 보면 익숙해지고, 어느새 내용을 이해하고 사용하는 순간이 올 것이다.</li>
<li>그러면 프로그램에 대한 이해력과 응용력 또한 좋아져서 더 좋은 코드를 구성할 수 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-포인터"><a class="header" href="#13-포인터">13. 포인터</a></h1>
<h2 id="13-1-운영체제의-메모리-관리-방식"><a class="header" href="#13-1-운영체제의-메모리-관리-방식">13-1. 운영체제의 메모리 관리 방식</a></h2>
<h3 id="운영체제와-프로그래밍"><a class="header" href="#운영체제와-프로그래밍">운영체제와 프로그래밍</a></h3>
<ul>
<li>지금까지는 변수를 사용하여 메모리에 데이터를 저장하거나 읽었다.</li>
<li>이렇게 C 언어 소스 코드에서 사용한 변수들은 컴파일 작업 후 기계어로 변경되면 모두 메모리 주소로 바뀌어서 적용된다.</li>
</ul>
<p><img src="./images/variable_concept.png" alt="변수 컴파일 작업 후" /></p>
<ul>
<li>결국 기계어에서는 변수 이름보다 변수가 위치한 메모리의 주소가 훨씬 중요하다.</li>
<li>즉 변수 이름을 사용하지 않더라도 변수의 주소만 알고 있다면 변수 값을 읽거나 바꿀 수 있다는 뜻이다.</li>
<li>그런데 컴퓨터 시스템의 메모리는 운영체제가 관리하고 있다.</li>
<li>따라서 메모리 주소의 사용법을 배우기 전에 운영체제가 메모리를 어떻게 관리하는지를 먼저 알아야 한다.</li>
<li>운영체제(Operating System)는 컴퓨터 시스템을 효과적으로 관리해 주고 시스템이 가지고 있는 자원을 사용자 또는 프로그램이 잘 이용할 수 있도록 서비스해 주는 소프트웨어이다.</li>
<li>예를 들어 윈도우, 리눅스, 유닉스와 같은 소프트웨어가 운영체제이다.</li>
</ul>
<h4 id="32비트-운영체제와-64비트-운영체제"><a class="header" href="#32비트-운영체제와-64비트-운영체제">32비트 운영체제와 64비트 운영체제</a></h4>
<ul>
<li>64비트 운영체제가 보급됨에 따라 운영체제에서 실행되는 프로그램도 32비트 프로그램과 64비트 프로그램으로 나누어서 개발할 수 있다.</li>
<li>실제로 개발 현장에서는 특별한 경우가 아니라면 32비트 방식으로 개발하는 경우가 많다.</li>
<li>32비트 방식으로 개발해도 32비트 운영체제 또는 64비트 운영체제에서 모두 동작하기 때문이다.</li>
</ul>
<h4 id="64비트-운영체제의-장단점"><a class="header" href="#64비트-운영체제의-장단점">64비트 운영체제의 장단점</a></h4>
<ul>
<li>운영체제가 64비트를 지원하는 건 많은 이점이 있다.</li>
<li>동시 처리 능력이나 메모리의 확장성 같은 부분에서는 선택의 문제가 아니라 반드시 64비트로 사용해야 하는 경우도 있다.</li>
<li>예를 들어 32비트 운영체제는 우리가 메모리라고 부르는 RAM을 4GB(기가바이트, 2<sup>30</sup>)밖에 사용하지 못하지만 64비트 운영체제에서는 16EB(엑사바이트, 2<sup>60</sup>)까지
사용할 수 있다.</li>
<li>따라서 자신의 시스템이 RAM을 4GB이상 사용한다면 64비트 운영체제를 설치해야 메모리를 100% 다 사용할 수 있는 것이다.</li>
<li>하지만 64비트 운영체제가 장점만 있는 것은 아니다.</li>
<li>64비트 운영체제는 데이터의 기본 처리 단위가 64비트라는 뜻이기 때문에 기본적으로 메모리 사용량이 많다.</li>
<li>'운영체제나 프로그램이 몇 비트인가?'에 대해 이야기한 이유는 이 방식에 따라서 데이터를 처리하는 기본 단위가 달라지기 때문이다.</li>
<li>4장에서 자료형을 설명할 때 <code>int</code>형을 4바이트라고 한 이유는 32비트 운영체제를 기준으로 설명했기 때문이다.</li>
<li>예를 들어 C 언어의 <code>int</code>형 개념은 운영체제의 비트 수와 일치하기 때문에 32비트 운영체제에서는 <code>int</code>형이 32비트이다.</li>
</ul>
<h3 id="메모리-주소-지정-방식"><a class="header" href="#메모리-주소-지정-방식">메모리 주소 지정 방식</a></h3>
<ul>
<li>운영체제는 메모리 주소를 1바이트 단위로 관리한다.</li>
<li>운영체제마다 관리하는 방식에 차이가 있지만 32비트 윈도우 운영체제의 경우에 0~4,294,967,295번지까지 1바이트 단위로 주소가 매겨져 있다.</li>
<li>번지수 4,294,967,295는 2<sup>32</sup>-1을 계산한 결과이다.</li>
<li>운영체제가 32비트이고 시작 주소가 1이 아니고 0이기 때문이다.</li>
<li>메모리를 사용하려면 반드시 사용할 주소를 지정해야 하고 메모리가 1바이트 단위로만 사용되는 것은 아니기 때문에 프로그래머가 메모리를 사용할 때 한 번에 읽거나 저장할 크기를 명시해야 한다.</li>
<li>예를 들어 100번지, 101번지 이렇게 두 개 바이트를 사용하고 싶다면 '100번지부터 2바이트 크기만큼 메모리를 사용하겠다'라는 형식으로 표기해 주어야 한다.</li>
</ul>
<h3 id="직접-주소-지정-방식"><a class="header" href="#직접-주소-지정-방식">직접 주소 지정 방식</a></h3>
<ul>
<li>직접 주소 지정 방식은 메모리를 사용할 때 프로그래머가 사용할 메모리 주소를 직접 적는 방식이다.</li>
<li>예를 들어 '102번지에 1042라는 값을 2바이트 크기로 저장하겠다'라고 이야기하는 것이 직접 주소 지정 방식이다.</li>
<li>102번지라는 주소를 직접적으로 표기했기 때문이다.</li>
</ul>
<p><img src="./images/memory_diagram_1.png" alt="직접 주소 지정 방식" /></p>
<ul>
<li>메모리를 사다리 모양으로 그려서 하나씩 검증해 보는 것이 개념을 이해하는 데 도움이 된다.</li>
<li>102번지에 1042 값이 대입되었는데 이 값이 2바이트에 걸쳐서 표현되어 있다.</li>
<li>그런데 위 그림은 단순화하여 그린 것이라 실제 메모리의 형태는 아니다.</li>
<li>실제 메모리에서 10진수 1042는 두 개의 바이트에 각각 4와 18로 나뉘어 저장되기 때문에 다음과 같이 그림을 그려야 한다.</li>
</ul>
<p><img src="./images/memory_diagram_2.png" alt="직접 주소 지정 방식" /></p>
<blockquote>
<h4 id="1042가-왜-4와-18로-나누어질까"><a class="header" href="#1042가-왜-4와-18로-나누어질까">1042가 왜 4와 18로 나누어질까?</a></h4>
<ul>
<li>1042값이 왜 4와 18로 나뉘어서 저장되는지 이해하려면 1042값을 2진수 값으로 바꿔 보면 된다.</li>
<li>2진수 한 자리를 저장하기 위해서는 1비트가 필요하기 때문에 2바이트(16비트)에 맞도록 총 16자리의 2진수로 표시하면 다음과 같다.</li>
</ul>
<pre><code class="language-text">0000 0100   0001 0010  // 1024
   (4)        (18)
</code></pre>
<ul>
<li>결국 1042 값은 8비트에 저장할 수 없기 때문에 두 개의 8비트에 4와 18로 나뉘어 저장되는 것이다.</li>
<li>그런데 위의 그림에서 8비트씩 메모리에 옮길 때 102번지에 18, 103번지에 4가 대입되어 있다.</li>
<li>숫자를 적을 때 큰 숫자부터 적는 게 일반적이라서 102번지에 4가 저장되는 게 맞다고 생각할 수도 있지만, 이 그림은 윈도우 운영체제를 기준으로 그린 것이다.</li>
<li>윈도우 운영체제는 리틀 엔디언이라는 바이트 정렬을 사용하여 숫자를 표현하기 때문에 우리가 생각하는 것과 반대 방향으로 숫자가 배열된다.</li>
</ul>
</blockquote>
<h4 id="16진법으로-메모리-형태-표시하기"><a class="header" href="#16진법으로-메모리-형태-표시하기">16진법으로 메모리 형태 표시하기</a></h4>
<ul>
<li>우리가 자주 쓰는 숫자는 대부분 10진수이다.</li>
<li>컴퓨터 내부에서는 0과 1, 즉 2진수로 정보를 처리한다.</li>
<li>파일을 압축하는 연산이나 동영상 처리, 심지어 전화 통화까지도 모두 비트 단위인 2진수 패턴으로 작업할 수 있다.</li>
<li>그런데 C 언어에서는 2진수를 직접 사용하는 방법을 제공하지 않는다.</li>
<li>따라서 C 언어로 프로그래밍할 때는 2진수에 가장 가까운 표현법인 16진수를 자주 사용한다.</li>
<li>16진법은 한 자릿수를 표현하는 데 16개의 문자를 사용하기 때문에 16진수의 한 자릿수는 4비트(2<sup>4</sup>=16)로 표시할 수 있다.</li>
<li>결국 16진수로 표현된 숫자는 두 자리씩 자르면 1바이트를 의미하므로 숫자를 바이트 단위로 나누기가 편리하다.</li>
<li>예를 들어 10진법으로 쓰인 숫자 1042를 바이트 단위로 나누려면 2진법으로 먼저 변환하고, 또 다시 바이트 단위로 나누어야 한다.</li>
<li>10진수 1042를 처음부터 16진수로 저장했다면 어떨까?</li>
<li>1042값은 16진수 표기법으로 <code>0x0412</code>이므로 한 바이트에 <code>0x04</code>가 저장되고 나머지 바이트에 <code>0x12</code>가 저장된다.</li>
<li>이렇게 C 언어로 프로그래밍할 때 바이트 단위로 작업을 하면, 데이터를 저장할 때 메모리 공간을 훨씬 효율적으로 사용할 수 있다.</li>
<li>메모리에 저장하는 값들과, 주소도 16진수로 표기해보자.</li>
</ul>
<pre><code class="language-text">0x0412 값을 0x00000066 번지에 2바이트 크기로 대입하라.
</code></pre>
<p><img src="./images/memory_diagram_3.png" alt="16진법으로 메모리 형태 표시하기" /></p>
<h3 id="직접-주소-방식은-c-언어의-변수-문법과-같다"><a class="header" href="#직접-주소-방식은-c-언어의-변수-문법과-같다">직접 주소 방식은 C 언어의 '변수' 문법과 같다</a></h3>
<ul>
<li>지금까지 메모리에서 '직접 주소 지정 방식'을 살펴보았다.</li>
<li>'0x00000066 번지에 0x0412 값을 2바이트 크기로 대입하라.'는 명령을 좀 더 정확하게 이해하기 위해 컴퓨터가 사용하는 기계어와 가장 가까운 어셈블리 언어로 표현해 보면 다음과 같다.</li>
</ul>
<p><img src="./images/memory_diagram_4.png" alt="어셈블리 언어로 표현해 보기" /></p>
<ul>
<li>어셈블리어에서 <code>mov</code>명령은 move의 줄임 표현이고 <code>mov A, B</code>명령은 A에 B값을 대입하라는 뜻이다.</li>
<li><code>word ptr[]</code>명령은 <code>[]</code>에 명시된 주소에 가서 word(2바이트) 단위로 값을 읽거나 쓰겠다는 의미이다.</li>
<li>C 언어와 달리 어셈블리어에서는 16진수를 표시할 때 숫자 끝에 <code>h</code>를 붙인다.</li>
<li>C 언어는 '변수'라는 개념으로 직접 주소 지정 방식을 사용한다.</li>
<li>C 언어에서 변수를 사용하면 변수에 값을 대입하는 소스 코드가 위와 같은 어셈블리어 형태의 기계어로 번역된다.</li>
</ul>
<blockquote>
<h4 id="기계어와-어셈블리어가-무엇인지-좀-더-알아보자"><a class="header" href="#기계어와-어셈블리어가-무엇인지-좀-더-알아보자">기계어와 어셈블리어가 무엇인지 좀 더 알아보자</a></h4>
<ul>
<li>컴퓨터가 사용하는 2진 숫자로 나열된 언어를 기계어(Machine Language)라고 한다.</li>
<li>실행 파일(Executable File, *.exe)이라고 부르는 것이 기계어로 구성된 파일이다.</li>
<li>하지만 이 파일은 숫자로 이루어져 있어서 이해하기 어렵기 때문에, 형식은 비슷하면서 숫자로 배열된 명령을 영단어로 변경해서 보여주는 언어가 어셈블리(Assembly) 언어이다.</li>
<li>어셈블리 언어는 기계어에 가장 가까운 저급 언어(Low-level language)이므로 성능 평가나 시스템 원리를 설명할 때 많이 사용한다.</li>
<li><code>mov</code>, <code>word</code>처럼 자주 사용하는 몇 가지 명령과 레지스터(Register, CPU 내부에 있는 연산 가능한 메모리)를 공부해서 어셈블리 언어로 작성된 소스 코드를 보고 이해할 정도까지만 알아두자.</li>
</ul>
</blockquote>
<ul>
<li>C 언어는 변수라는 개념으로 메모리 주소를 직접 적지 않으면서도 직접 주소 지정 방식을 사용한다.</li>
<li>번역기의 도움을 받아서 내부적으로 변수가 주소로 변환되어 결과적으로는 직접 주소 지정 방식을 사용하게 되는 것이다.</li>
<li>앞에서 어셈블리어로 작성한 명령을 C 언어의 변수 문법으로 재구성해 보면 다음과 같다.</li>
</ul>
<pre><code class="language-c">short birthday;     // birthday가 메모리 주소 0x00000066에 위치한다고 가정함
birthday = 0x0412;  // mov word ptr[00000066h], 0412h 로 번역함
</code></pre>
<ul>
<li>C 언어는 왜 어셈블리어나 기계어처럼 주소를 직접 사용하지 않고 변수라는 개념을 사용할까?</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-표준-입력-함수"><a class="header" href="#14-표준-입력-함수">14. 표준 입력 함수</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-배열과-포인터"><a class="header" href="#15-배열과-포인터">15. 배열과 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-메모리-할당"><a class="header" href="#16-메모리-할당">16. 메모리 할당</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-다차원-포인터"><a class="header" href="#17-다차원-포인터">17. 다차원 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-구조체와-연결-리스트"><a class="header" href="#18-구조체와-연결-리스트">18. 구조체와 연결 리스트</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-파일-입출력"><a class="header" href="#19-파일-입출력">19. 파일 입출력</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-함수-포인터"><a class="header" href="#20-함수-포인터">20. 함수 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="주니어-프로그래머-딱지-떼는-다섯-가지-팁"><a class="header" href="#주니어-프로그래머-딱지-떼는-다섯-가지-팁">주니어 프로그래머 딱지 떼는 다섯 가지 팁!</a></h1>
<h2 id="tip-1-함수가-필요한-이유를-기억하자"><a class="header" href="#tip-1-함수가-필요한-이유를-기억하자">Tip 1. 함수가 필요한 이유를 기억하자</a></h2>
<ul>
<li>내가 개발하는 프로그램에 두 변수의 값을 합산하는 경우가 많다고 가정해 보자.</li>
</ul>
<blockquote>
<h4 id="a-유형-그냥-편하게-살자"><a class="header" href="#a-유형-그냥-편하게-살자">A 유형: '그냥 편하게 살자'</a></h4>
<pre><code class="language-c">void main() {
    int var1 = 1, var2 = -3, var3 = 5;
    int var4 = -2, var5 = 7, var6 = -9;
    int result1, result2, result3;
    
    result1 = var1 + var2;
    result2 = var3 + var4;
    result3 = var5 + var6;
    // 위와 같은 연산이 많다고 가정함
}
</code></pre>
<h4 id="b-유형-함수를-활용하자"><a class="header" href="#b-유형-함수를-활용하자">B 유형: '함수를 활용하자'</a></h4>
<pre><code class="language-c">int Sum(int data1, int data2) {
    return data1 + data2;
}

void main() {
    int var1 = 1, var2 = -3, var3 = 5;
    int var4 = -2, var5 = 7, var6 = -9;
    int result1, result2, result3;
    
    result1 = Sum(var1, var2);
    result2 = Sum(var3, var4);
    result3 = Sum(var5, var6);
    // 위와 같은 연산이 많다고 가정함
}
</code></pre>
<ul>
<li>A 유형이 B 유형에 비해 소스 코드도 간단하고 프로그램을 실행할 때 수행 속도도 더 빠르다.</li>
<li>하지만 A 유형은 변화에 대처하기 어렵다는 치명적인 단점을 가지고 있다.</li>
<li>프로그램을 개발해 달라고 의뢰한 사람이 기능 변경을 요구한다면 A 유형 프로그래머는 자신이 사용한 코드를 모두 찾아내어 바꾸는 코드를 추가해야 하기 때문에 스트레스를 많이 받을 것이다.</li>
</ul>
</blockquote>
<blockquote>
<h4 id="a-유형-아-스트레스"><a class="header" href="#a-유형-아-스트레스">A 유형: '아~ 스트레스'</a></h4>
<pre><code class="language-c">void main() {
    int var1 = 1, var2 = -3, var3 = 5;
    int var4 = -2, var5 = 7, var6 = -9;
    int result1, result2, result3;
    
    // 덧셈이 있는 곳은 다 바꿔야 함
    if(var1 &lt; 0) var1 *= -1;
    if(var2 &lt; 0) var2 *= -1;
    result1 = var1 + var2;
    if(var3 &lt; 0) var3 *= -1;
    if(var4 &lt; 0) var4 *= -1;
    result2 = var3 + var4;
    if(var5 &lt; 0) var5 *= -1;
    if(var6 &lt; 0) var6 *= -1;
    result3 = var5 + var6;
}
</code></pre>
<h4 id="b-유형-바로-변경해-드릴게요"><a class="header" href="#b-유형-바로-변경해-드릴게요">B 유형: '바로 변경해 드릴게요~'</a></h4>
<pre><code class="language-c">int Sum(int data1, int data2) {
    // 음수에 -1을 곱하면 양수가 됨
    if(data1 &lt; 0) data1 *= -1;
    if(data2 &lt; 0) data2 *= -1;
    return data1 + data2;
}

void main() {
    int var1 = 1, var2 = -3, var3 = 5;
    int var4 = -2, var5 = 7, var6 = -9;
    int result1, result2, result3;
    // 여기는 수정이 필요 없음
    result1 = Sum(var1, var2);
    result2 = Sum(var3, var4);
    result3 = Sum(var5, var6);
}
</code></pre>
<ul>
<li>A 유형은 중복 코드가 엄청나게 많이 발생하고, 소스 코드를 수정하다가 실수가 나오기 쉽다.</li>
<li>따라서 B 유형처럼 중복되는 코드를 미리 함수로 작업해 두면 대처하기가 훨씬 쉽다.</li>
<li>하지만 함수를 호출하는 행위가 수행 속도에 영향을 미치기 때문에 모든 코드를 무조건 함수로 만드는 것은 좋지 않다.</li>
<li>해당 작업의 빈도나 중요성 그리고 변화 가능성을 잘 따져서 함수로 만들 것인지를 결정하자.</li>
</ul>
</blockquote>
<h2 id="tip-2-프로그램에서-if-조건문은-줄이는-것이-좋다"><a class="header" href="#tip-2-프로그램에서-if-조건문은-줄이는-것이-좋다">Tip 2. 프로그램에서 if 조건문은 줄이는 것이 좋다</a></h2>
<ul>
<li>컴퓨터는 명령을 순차적으로 실행하는 데 최적화되어 있기 때문에, <code>if</code>조건문을 사용하여 실행 흐름을 자주 변경하면 수행 능력이 떨어진다.</li>
<li>그래서 구조나 수식을 잘 활용하여 조건문을 최대한 적게 사용하려고 노력해야 한다.</li>
<li>예를 들어 '변수 A값이 5이면 A에 2를 더한다'라는 작업을 <code>if</code>조건문으로 작성하면 다음과 같다.</li>
</ul>
<pre><code class="language-c">if(5 == A) A = A + 2;
</code></pre>
<ul>
<li>그런데 다음과 같은 수식으로도 위 소스 코드와 같은 결과를 낼 수 있다.</li>
</ul>
<pre><code class="language-c">A = A + 2 * (5 == A);  // 조건 수식 5 == A가 참이면 1. A = A + 2 * 1이 됨.
                       // 조건 수식 5 == A가 거짓이면 0. A = A + 2 * 0이 됨.
</code></pre>
<ul>
<li>물론 이 두 수식을 한두 번 사용하는 것으로 수행 능력을 논하기에는 어려움이 있을 것이다.</li>
<li>하지만 이렇게 <code>if</code>조건문 대신 조건 수식을 사용해야겠다는 생각을 늘 하다 보면 빠르게 반복 수행해야 하는 코드나 대량의 데이터를 처리하는 프로그램에서 더 좋은 코드를 만들 수 있다.</li>
</ul>
<blockquote>
<h4 id="숫자를-0-1-2-3-4-0-1-2-3-4-순서로-출력해야-한다면"><a class="header" href="#숫자를-0-1-2-3-4-0-1-2-3-4-순서로-출력해야-한다면">숫자를 0, 1, 2, 3, 4, 0, 1, 2, 3, 4 순서로 출력해야 한다면</a></h4>
<h4 id="a-유형-반복문만-사용"><a class="header" href="#a-유형-반복문만-사용">A 유형: 반복문만 사용</a></h4>
<pre><code class="language-c">int step, i;

for(step = 0; step &lt; 2; step++) {
    // 0, 1, 2, 3, 4, 출력
    for(i = 0; i &lt; 5; i++) printf(&quot;%d,&quot;, i);
}
</code></pre>
<h4 id="b-유형-if-조건문-사용"><a class="header" href="#b-유형-if-조건문-사용">B 유형: if 조건문 사용</a></h4>
<pre><code class="language-c">int i, count = 0;
for(i = 0; i &lt; 10; i++) {
    // i가 5일 때 다시 0으로 바꿈
    if(count == 5) count = 0;
    printf(&quot;%d,&quot;, count++);
}
</code></pre>
<ul>
<li>A 유형은 0~4를 출력하는 <code>for</code>반복문을 두 번 반복하는 방법을 선택했고,</li>
<li>B 유형은 출력 변수 <code>count</code>를 따로 두고 그 값이 5가 되면 다시 0으로 변경하는 방법을 선택했다.</li>
<li>그런데 다음과 같이 나머지 연산자인 <code>%</code>의 연산 특성을 이용하면 변수도 하나 줄이고 <code>if</code>조건문도 줄여서 좀 더 간결하게 코드를 구성할 수 있다.</li>
</ul>
<pre><code class="language-c">int i;
for(i = 0; i &lt; 10; i++) {
    // i를 5로 나눈 나머지를 출력함. 따라서 5, 6, 7, 8, 9는 0, 1, 2, 3, 4로 출력됨
    printf(&quot;%d,&quot;, i%5);
}
</code></pre>
</blockquote>
<ul>
<li>문법을 사용하는 방법을 아는 것도 중요하지만, 지금까지 배운 문법들이 왜 만들어졌고 어떤 특성을 가지고 있는지를 파악하려고 노력해야 코드를 더 효과적으로 구성할 수 있다.</li>
<li>여기에서 주의할 점은 굳이 <code>if</code>조건문을 줄일 필요가 없는 형태도 있다는 것이다.</li>
<li>예를 들어 'A가 2보다 크고 10보다 작으면, A를 1증가시키는 작업'을 <code>if</code>조건문으로 작성하는 경우 다음처럼 두 가지 유형으로 구성할 수 있다.</li>
</ul>
<blockquote>
<h4 id="a-유형-조건문-나열"><a class="header" href="#a-유형-조건문-나열">A 유형: 조건문 나열</a></h4>
<pre><code class="language-c">if(A &gt; 2) {
    if(A &lt; 10) A++;
}
</code></pre>
<h4 id="b-유형-관계-연산자-활용"><a class="header" href="#b-유형-관계-연산자-활용">B 유형: 관계 연산자 활용</a></h4>
<pre><code class="language-c">if(A &gt; 2 &amp;&amp; A &lt; 10) A++;
</code></pre>
</blockquote>
<ul>
<li>두 유형은 같은 작업을 하는 코드이고 조건 수식도 두 번씩 처리되지만 B 유형이 A 유형보다 조건문을 한 번 더 적게 실행한다.</li>
<li>B 유형이 A 유형보다 더 효율적일까?</li>
<li>컴파일러가 번역하면 같은 형태의 기계어를 만든다.</li>
<li>따라서 어느 쪽을 사용하든 상관 없다.</li>
</ul>
<h2 id="tip-3-조건문에서-조건-수식은-단순화시키자"><a class="header" href="#tip-3-조건문에서-조건-수식은-단순화시키자">Tip 3. 조건문에서 조건 수식은 단순화시키자</a></h2>
<ul>
<li><code>if</code>조건문을 사용하다 보면 조건 수식이 0과 다른지 비교하는 경우가 있다.</li>
<li><code>if(0 != A)</code> ⇒ <code>if(A)</code></li>
<li><code>0 != A</code>와 <code>A</code>가 완벽하게 같다는 뜻은 아니지만, 실제로 위의 두 표현은 기계어로 번역할 때 동일하게 번역된다.</li>
<li><code>if(0 == A)</code> ⇒ <code>if(!A)</code> 다음과 같은 표현도 서로 동일한 표현이다.</li>
<li>관계 연산을 사용하다 보면 '아닌 것이 아니다'와 같은 표현을 사용해서 코드가 더 복잡하게 표현되는 경우도 있다.</li>
<li>이런 경우 바깥쪽의 NOT을 없애는 공식을 사용해서 좀 더 간결하게 표현할 수 있다.</li>
<li><code>NOT(A AND B)</code> ⇔ <code>(NOT A) OR (NOT B)</code></li>
<li><code>NOT(A OR B)</code> ⇔ <code>(NOT A) AND (NOT B)</code></li>
<li>위 공식을 사용하면 다음과 같이 조건 수식을 단순화할 수 있다.</li>
<li><code>if(!(A == 0 &amp;&amp; B == 0))</code> ⇒ <code>if(A != 0 || B != 0)</code> ⇒ <code>if(A || B)</code></li>
<li>이렇게 코드를 변경한다고 수행 속도가 빨라지는 것은 아니다.</li>
<li>컴파일러가 소스를 번역할 때 위와 같은 최적화 작업을 알아서 해주기 때문에 대부분 동일한 기계어 코드가 만들어진다.</li>
<li>하지만 컴파일러에 의존하는 것보다 간단한 것은 직접 단순화하는 것이 좋다.</li>
</ul>
<h2 id="tip-4-사용하는-시스템의-메모리-정렬-방식을-알아-두자"><a class="header" href="#tip-4-사용하는-시스템의-메모리-정렬-방식을-알아-두자">Tip 4. 사용하는 시스템의 메모리 정렬 방식을 알아 두자</a></h2>
<ul>
<li>과거 컴퓨터들은 구조 설계 방식이 CISC(Complex Instruction Set Computer)와 RISC(Reduced Instruction Set Computer)로 나뉘어 있었다.</li>
<li>CISC는 모든 고급 언어의 명령에 각각의 기계어가 대응되게 한 것이고, RISC는 자주 사용하는 명령만 모아 프로세서를 만든 것이다.</li>
<li>이 두 방식의 많은 차이점 가운데, 개발자 입장에서 알아야 할 차이점은 메모리 정렬 방식이 다르다는 점이다.</li>
<li>비트 단위의 메모리 정렬은 CISC방식이나 RISC방식 모두 같기 때문에 상관없지만, 여러 개의 바이트가 모여서 표현되는 메모리를 정렬할 때는 이 두 방식에 차이가 있다.</li>
<li>예를 들어 1바이트를 사용하는 <code>char</code>형에서는 차이가 없지만, 2바이트 또는 4바이트를 사용하는 <code>short int</code>형 또는 <code>long int</code>형에서는 차이가 있다.</li>
</ul>
<h3 id="빅-엔디언-방식"><a class="header" href="#빅-엔디언-방식">빅 엔디언 방식</a></h3>
<ul>
<li>보통 운영체제에서 어떤 정보를 메모리에 저장할 때 메모리 주소가 낮은 쪽에서 높은 쪽으로 진행한다.</li>
<li>따라서 시작 주소가 끝 주소보다 작은 것이 일반적이다.</li>
<li>0x12345678 값을 4바이트 메모리에 저장할 때 빅 엔디언 방식(Big-endian Format)은 큰 자릿수(변수의 상위 바이트)의 값부터 저장한다.</li>
<li>즉 시작 주소에 해당하는 바이트에 0x12, 그 다음 바이트에 0x34와 0x56, 그리고 마지막 바이트에 0x78을 저장한다.</li>
</ul>
<p><img src="./images/big_endian_format.png" alt="빅 엔디언 방식" /></p>
<ul>
<li>RISC 기반의 하드웨어에서 동작하도록 만든 유닉스(Unix)와 유닉스를 모델로 만든 리눅스(Linux)는 이 방식으로 바이트를 정렬한다.</li>
<li>예외적으로 하드웨어 기반과 상관없이 JAVA같은 언어는 무조건 빅 엔디언 방식을 사용한다.</li>
<li>이것은 Java VM(Virtual Machine)이라는 시스템에서 하드웨어와 상관없이 메모리를 재배열하기 때문이다.</li>
</ul>
<h3 id="리틀-엔디언-방식"><a class="header" href="#리틀-엔디언-방식">리틀 엔디언 방식</a></h3>
<ul>
<li>리틀 엔디언 방식(Little-endian Format)방식은 0x12345678 값을 4바이트 메모리에 저장할 때 작은 자릿수(변수의 하위 바이트)의 값부터 저장하기 때문에 시작 주소에 해당하는 바이트에
0x78, 그 다음 바이트에 0x56과 0x34, 그리고 마지막 바이트에 0x12를 저장하는 방식이다.</li>
</ul>
<p><img src="./images/little_endian_format.png" alt="리틀 엔디언 방식" /></p>
<ul>
<li>CISC 기반의 하드웨어에서 동작하도록 만든 윈도우 운영체제는 이 방식으로 바이트를 정렬한다.</li>
<li>이렇듯 메모리 정렬 방식이 다른 운영체제에서 2바이트 이상의 메모리를 사용할 때는 바이트 단위로 저장되는 값 자체가 달라지기 때문에, 네트워크 시스템을 이용하여 데이터를 주고 받을 때 특히 주의해야 한다.</li>
</ul>
<h2 id="tip-5-형-변환-자료형이-다른-두-변수-간에-값을-대입하려면"><a class="header" href="#tip-5-형-변환-자료형이-다른-두-변수-간에-값을-대입하려면">Tip 5. 형 변환: 자료형이 다른 두 변수 간에 값을 대입하려면?</a></h2>
<ul>
<li>소스 코드를 작성하다 보면 자료형이 다른 두 변수 간에 값을 대입하는 경우가 있다.</li>
</ul>
<pre><code class="language-c">unsigned int a = 0x12345678, b = 0x12345678;
unsigned char c = 0x48, d = 0x00;
a = c;  // 4바이트에 1바이트 데이터를 저장함
d = b;  // 1바이트에 4바이트 데이터를 저장함. 컴파일하면 경고 발생함
</code></pre>
<ul>
<li>작은 크기의 데이터를 더 큰 크기의 메모리로 데이터를 저장하는 것은 문제가 발생하지 않는다.</li>
<li>하지만 큰 크기의 데이터를 자신보다 작은 크기의 메모리로 복사하면 데이터가 손실될 수 있다는 경고가 발생한다.</li>
<li>만약 프로그래머가 의도적으로 저런 코드를 사용했다면 형 변환(Casting) 연산자를 사용하여 경고를 제거할 수 있다.</li>
</ul>
<pre><code class="language-c">unsigned int b = 0x12345678;
unsigned char d = 0x00;
d = (unsigned char) b;  // 변수 b의 자료형을 unsigned int에서 일시적으로 unsigned char로 변환함
</code></pre>
<ul>
<li>대입 명령을 처리할 때만 <code>b</code>변수의 자료형을 일시적으로 <code>unsigned char</code>형으로 바꾸어 주기 때문에, 그 이후 코드부터는 다시 <code>unsigned int</code>크기로 <code>b</code>변수를 사용한다.</li>
<li>다음과 같이 자신이 데이터를 원하는 크기만큼 복사하는 것도 가능하다.</li>
</ul>
<pre><code class="language-c">unsigned int a = 0x12345678, b = 0x11223344, c = 0x11223344;
b = (unsigned short int) a; // a의 2바이트만 b로 복사함
c = (unsigned char) a;      // a의 1바이트만 c로 복사함
</code></pre>
<ul>
<li>결과적으로 형 변환 연산자를 사용하면 원하는 크기만큼 정보를 복사할 수 있지만, 복사되는 변수는 메모리가 확장되어 전체 값이 변경된다는 점에 주의하자.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tip2-주니어-프로그래머-딱지-떼는-일곱-가지-팁"><a class="header" href="#tip2-주니어-프로그래머-딱지-떼는-일곱-가지-팁">Tip2. 주니어 프로그래머 딱지 떼는 일곱 가지 팁!</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
