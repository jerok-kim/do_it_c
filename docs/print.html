<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Study: Do it C 언어 입문</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-프로그램과-c-언어"><a class="header" href="#1-프로그램과-c-언어">1. 프로그램과 C 언어</a></h1>
<h2 id="1-1-프로그래밍-기초"><a class="header" href="#1-1-프로그래밍-기초">1-1. 프로그래밍 기초</a></h2>
<h3 id="프로그램이란"><a class="header" href="#프로그램이란">프로그램이란?</a></h3>
<ul>
<li>어떤 목적을 이룰 수 있도록 프로그래밍 언어로 진행 순서를 기술한 것을 프로그램이라고 한다.</li>
<li>프로그램은 보통 확장자가 .exe인 파일을 의미한다.</li>
<li>이 파일을 실행 파일이라고 하며, 컴퓨터가 작업할 내용이 컴퓨터가 이해할 수 있는 언어(기계어)로 작성되었다.</li>
</ul>
<h3 id="프로그래밍-언어란"><a class="header" href="#프로그래밍-언어란">프로그래밍 언어란?</a></h3>
<ul>
<li>컴퓨터는 2진수(0과 1)로 이루어진 기계어를 사용한다.</li>
<li>기계어는 2진수로 이루어져 있으며, 컴퓨터의 CPU가 직접 사용할 수 있는 형태의 명령문이다.</li>
<li>사람들이 사용하기 편한 언어로 작성한 작업 내용을 컴파일러(Compiler)가 기계어로 번역한다.</li>
</ul>
<h2 id="1-2-c-언어-소개"><a class="header" href="#1-2-c-언어-소개">1-2. C 언어 소개</a></h2>
<h3 id="c-언어의-탄생"><a class="header" href="#c-언어의-탄생">C 언어의 탄생</a></h3>
<ul>
<li>1960년대에 개발되었던 운영체제들은 하드웨어 종속적인 언어를 사용하여 개발되었다.</li>
<li>따라서 하드웨어가 바뀌면 운영체제의 많은 부분을 다시 개발해야 했다.</li>
<li>켄 톰슨(Ken Thompson)과 데니스 리치(Dennis Ritchie)는 하드웨어로부터 독립된 운영체제를 만드는데 적합한 언어를 개발하는데 이것이 C 언어이다.</li>
<li>C 언어는 하드웨어의 세밀한 부분까지 제어할 수 있다.</li>
<li>그리고 특정 하드웨어를 직접 표현하지 않도록 문법을 구성하였기 때문에 하드웨어에 독립된 형태로 프로그램을 개발할 수 있다.</li>
<li>C 언어는 유닉스(UNIX) 운영체제를 만드는 데 사용한 프로그래밍 언어이다.</li>
</ul>
<h3 id="c-언어의-특징-4가지"><a class="header" href="#c-언어의-특징-4가지">C 언어의 특징 4가지</a></h3>
<ul>
<li>구조화된 언어, 이식성, 확장성, 생산성</li>
</ul>
<h4 id="c-언어는-구조화된-언어이다"><a class="header" href="#c-언어는-구조화된-언어이다">C 언어는 구조화된 언어이다</a></h4>
<ul>
<li>C 언어는 일정한 단위로 명령들을 그룹으로 묶는 방법을 제공한다.</li>
<li>C 언어로 만든 프로그램은 작업 단위가 명확하게 구분되어 유지 보수가 편리하고 기존 프로그램에서 자신이 원하는 작업을 분리하기도 쉬워서 새로운 프로그램을 개발할 때 재사용하기에도 좋다.</li>
</ul>
<h4 id="c-언어는-이식성이-높다"><a class="header" href="#c-언어는-이식성이-높다">C 언어는 이식성이 높다</a></h4>
<ul>
<li>C 언어이 이식성(Portability)이 높다는 말은 C 언어로 만든 프로그램을 거의 수정하지 않고 다른 하드웨어 또는 운영체제로 가져갔을 때도 잘 동작한다는 뜻이다.</li>
<li>이를 위해 하드웨어에 종속적일 수 있는 부분은 C 언어에서 분리해 런타임 라이브러리(Runtime Library)라는 개념으로 제공한다.</li>
<li>이 런타임 라이브러리는 각 하드웨어 또는 운영체제별로 만들어졌기 때문에 사용자가 작성한 C 언어 프로그램에는 영향을 미치지 않는다.</li>
<li>즉 하드웨어에 변화가 생기더라도 C 언어 문법이 영향을 받지 않도록 C 언어를 디자인 한 것이다.</li>
</ul>
<h4 id="c-언어는-확장성이-좋고-표현법이-다양해서-자기만의-표현법을-개발할-수-있다"><a class="header" href="#c-언어는-확장성이-좋고-표현법이-다양해서-자기만의-표현법을-개발할-수-있다">C 언어는 확장성이 좋고, 표현법이 다양해서 자기만의 표현법을 개발할 수 있다</a></h4>
<ul>
<li>C 언어는 사용할 확률이 높은 문법만 최소한으로 유지하고 사용 빈도가 낮은 문법은 사용자들이 스스로 구현하기 때문에 언어의 기능을 확장할 수 있다.</li>
<li>따라서 C 언어는 다른 언어에 비해 표현법이 더 많고, 개발자가 개발 상황에 따라 선택할 수 있는 문법 구조나 표현법이 다양하여 자율성이 높다.</li>
</ul>
<h4 id="c-언어는-생산성이-높다"><a class="header" href="#c-언어는-생산성이-높다">C 언어는 생산성이 높다</a></h4>
<ul>
<li>C 언어를 사용하는 프로그래머들은 스스로 개발 인프라(명령 그룹, 함수 등)를 구축하기 때문에 경력이 쌓일수록 인프라가 다양해져서 프로그램 개발 속도가 빨라진다.</li>
<li>그 뿐만 아니라 사용자의 여러 가지 요구에 대해 스스로 대처할 수 있어서 프로그램의 완성도와 만족도가 더 높을 수 밖에 없다.</li>
</ul>
<h2 id="1-3-전자계산기-원리와-프로그래밍-개념"><a class="header" href="#1-3-전자계산기-원리와-프로그래밍-개념">1-3. 전자계산기 원리와 프로그래밍 개념</a></h2>
<ul>
<li>모든 프로그래밍 언어는 비슷한 요소를 가지고 있다.</li>
</ul>
<h3 id="입력-버튼"><a class="header" href="#입력-버튼">입력 버튼</a></h3>
<ul>
<li>대부분의 프로그래밍 언어는 입력문을 가지고 있다.</li>
<li>ex) 키보드, 마우스</li>
<li>C 언어는 다음과 같이 표준 입력 및 콘솔 입력 방식으로 이 두 장치를 제어한다.</li>
</ul>
<pre><code>scanf, getc, getch, gets, ⋯
</code></pre>
<h3 id="lcd-출력"><a class="header" href="#lcd-출력">LCD 출력</a></h3>
<ul>
<li>대부분의 프로그래밍 언어는 출력문을 가지고 있다.</li>
<li>컴퓨터는 주로 모니터를 통해 정보를 출력하며, C 언어는 표준 출력·콘솔 출력 이라는 두 가지 형태의 출력 방식이 있다.</li>
</ul>
<pre><code>printf, putc, puts, ⋯
</code></pre>
<h3 id="상수"><a class="header" href="#상수">상수</a></h3>
<ul>
<li>숫자와 기호, 문자 등 한정된 입력 대상을 상수라고 한다.</li>
<li>프로그래밍 언어에서는 숫자 상수, 문자 상수, 문자열 상수로 나누어 표현한다.</li>
</ul>
<pre><code>1, 2, 3, 'a', 'b', &quot;abc&quot;, ⋯
</code></pre>
<h3 id="연산자"><a class="header" href="#연산자">연산자</a></h3>
<ul>
<li>덧셈, 뺄셈, 나눗셈과 같은 연산 기능이 있다.</li>
<li>모든 프로그래밍 언어는 연산 기능을 수행할 수 있는 연산자를 가지고 있다.</li>
</ul>
<pre><code>+, -, *, /, %, ⋯
</code></pre>
<h3 id="변수"><a class="header" href="#변수">변수</a></h3>
<ul>
<li>계산기나 컴퓨터는 연산 과정에서 사용자가 입력한 값을 기억하고 연산 결과로 나온 값도 기억해야 하기 때문에 기억 공간이 필요하다.</li>
<li>이 기억 공간을 변수라고 한다.</li>
</ul>
<pre><code>int sum; double money; char type; ⋯
</code></pre>
<h3 id="조건문"><a class="header" href="#조건문">조건문</a></h3>
<ul>
<li>사용자가 어떤 연산자를 선택하는지에 따라 다른 작업을 수행하도록 표현하는 문법을 프로그래밍 언어에서는 조건문이라고 한다.</li>
</ul>
<pre><code>if, switch, ⋯
</code></pre>
<h3 id="반복문"><a class="header" href="#반복문">반복문</a></h3>
<ul>
<li>계산기는 계산 작업을 반복해서 수행하도록 만들어졌다.</li>
<li>프로그래밍 언어도 사용자가 원하는 작업을 반복해서 수행할 수 있도록 반복문을 제공한다.</li>
</ul>
<pre><code>for, while, do ~ while, ⋯
</code></pre>
<blockquote>
<h4 id="고급스러운-언어-저급한-언어"><a class="header" href="#고급스러운-언어-저급한-언어">고급스러운 언어, 저급한 언어?</a></h4>
<ul>
<li>프로그래밍 언어의 표현법이 사람들이 쓰는 언어와 비슷할수록 고급(High-level) 언어이고 컴퓨터의 기계어와 비슷할수록 저급(Low-level) 언어이다.</li>
<li>고급 언어를 대표하는 것으로 Java나 C#과 같은 프로그래밍 언어가 있고,</li>
<li>저급 언어를 대표하는 것은 기계어나 어셈블리어가 있다.</li>
<li>C 언어는 고급 언어이지만, 양쪽의 특성을 모두 가지고 있기 때문에 중간(Middle-level) 언어로도 볼 수 있다.</li>
</ul>
</blockquote>
<h2 id="1-4-c-언어-서술-형식"><a class="header" href="#1-4-c-언어-서술-형식">1-4 C 언어 서술 형식</a></h2>
<ul>
<li>사용자는 번역기가 제공하는 프로그래밍 언어의 문법에 맞게 프로그램을 작성해야 한다.</li>
<li>프로그래밍 언어가 요구하는 문법을 나열하는 것을 서술(Statement) 형식이라고 한다.</li>
</ul>
<h3 id="c-언어의-기본-서술-형식"><a class="header" href="#c-언어의-기본-서술-형식">C 언어의 기본 서술 형식</a></h3>
<ul>
<li>C 언어가 문장을 서술하는 기본 형식은 단일 서술문과 복합 서술문이다.</li>
</ul>
<h4 id="단일-서술문"><a class="header" href="#단일-서술문">단일 서술문</a></h4>
<ul>
<li>단일 서술문(Single Statement)은 논리적인 최소 명령 실행 단위이다.</li>
<li>즉 한 개의 서술문 단위로 작업이 진행된다.</li>
<li>C 언어는 ;(세미콜론)으로 문장을 구분하기 때문에 한 줄에 여러 개의 서술문을 쓸 수도 있다.</li>
</ul>
<pre><code class="language-c">a = a + 30;  // 한 줄로 이루어진 단일 서술문

a = a
   + 30;  // 두 줄로 이루어진 단일 서술문

a = a + 30; b = b + 50;  // 한 줄에 두 개의 단일 서술문을 사용
</code></pre>
<h4 id="복합-서술문"><a class="header" href="#복합-서술문">복합 서술문</a></h4>
<ul>
<li>복합 서술문(Compound Statement)은 여러 단일 서술문을 {} 중괄호를 사용해 하나로 묶은 형태이다.</li>
<li>중괄호 안의 단일 서술문이 모두 수행되면 이 복합 서술문이 수행된 것으로 처리된다.</li>
<li>다음과 같이 적으면 단일 서술문 2개를 사용한 것이 아니라 복합 서술문 1개를 사용한 것이다.</li>
</ul>
<pre><code class="language-c">{
    a = a + 30;
    b = b + 50;
}
</code></pre>
<ul>
<li>복합 서술문은 {} 중괄호를 사용하기 때문에 자신의 영역이 구분된다.</li>
<li>따라서 ;(세미콜론)을 사용할 필요가 없다.</li>
</ul>
<h3 id="역할에-따른-서술-형식"><a class="header" href="#역할에-따른-서술-형식">역할에 따른 서술 형식</a></h3>
<h4 id="수식-서술문"><a class="header" href="#수식-서술문">수식 서술문</a></h4>
<ul>
<li>수식 서술문(Expression Statement)은 계산 수식을 표현한 단일 서술문이다.</li>
</ul>
<pre><code class="language-c">average = (a + b) / 2;
</code></pre>
<h4 id="조건-서술문"><a class="header" href="#조건-서술문">조건 서술문</a></h4>
<ul>
<li>조건 서술문(Selection Statement)은 조건을 만족하면 지정한 서술문을 수행하도록 작성한 서술문이다.</li>
</ul>
<pre><code class="language-c">if(a &gt; 5) a = 0;
</code></pre>
<h4 id="반복-서술문"><a class="header" href="#반복-서술문">반복 서술문</a></h4>
<ul>
<li>반복 서술문(Iteration Statement)은 단일 서술문 또는 복합 서술문을 반복하여 수행하도록 작성한 서술문이다.</li>
</ul>
<pre><code class="language-c">int sum = 0, i;
for(i = 0; i &lt; 5; i++) sum = sum + i;
</code></pre>
<h4 id="라벨-서술문"><a class="header" href="#라벨-서술문">라벨 서술문</a></h4>
<ul>
<li>라벨 서술문(Labeled Statement)은 소스 파일의 특정 위치에 라벨을 지정하고 goto 문을 사용해 그 위치로 이동할 수 있도록 작성한 서술문이다.</li>
<li>원칙 없이 프로그래머가 원하는 위치로 실행 지점을 이동하는 것은 구조화된 언어인 C 언어의 소스 코드 구성을 파괴할 수 있는 문법이기 때문에 되도록 사용하지 않는 것이 좋다.</li>
</ul>
<pre><code class="language-c">if(a &lt; 0) goto EXIT;
a = a - 1;
EXIT :
</code></pre>
<h4 id="분기-서술문"><a class="header" href="#분기-서술문">분기 서술문</a></h4>
<ul>
<li>분기 서술문(Jump Statement)은 자신이 소속된 서술문을 벗어나거나 흐름을 바꾸어 놓을 때 사용한다.</li>
<li><code>break</code>, <code>continue</code>와 같은 문법들이 분기 서술문에 해당하는데 <code>return</code>문, <code>goto</code>문 처럼 실행 흐름을 마음대로 조정(서술문의 범위를 마음대로 벗어날 수 있음)하는 것이 아니라 특정 조건 서술문이나 반복 서술문 안에서만 적용되기 때문에 잘 활용하는 것이 좋다.</li>
</ul>
<h4 id="주석문"><a class="header" href="#주석문">주석문</a></h4>
<ul>
<li>상황을 설명하거나 작업 내용을 기억하기 위해 소스 파일에 메모를 남겨야 하는 경우에 주석문(Comment)을 사용한다.</li>
<li>주석문은 /* 기호로 시작해서 */ 기호로 끝나고, 여러 줄에 걸쳐서 사용할 수 있다.</li>
<li>// 를 사용하여 한줄 주석문을 사용할 수 있다.</li>
</ul>
<h3 id="예약어"><a class="header" href="#예약어">예약어</a></h3>
<ul>
<li>프로그래밍 언어의 문법에 사용되는 단어들을 예약어(Reserved Word)라고 한다.</li>
<li>예약어는 의미나 역할이 정해져 있기 때문에 그 뜻을 바꾸거나 다른 용도로 사용할 수 없다.</li>
</ul>
<h2 id="1-5-c-프로그램-실행-파일"><a class="header" href="#1-5-c-프로그램-실행-파일">1-5. C 프로그램 실행 파일</a></h2>
<p><img src="./images/program_diagram.png" alt="프로그램 생성 과정" /></p>
<h3 id="소스-파일c"><a class="header" href="#소스-파일c">소스 파일(*.c)</a></h3>
<ul>
<li>소스 파일(Source File)은 프로그래머가 만들고 싶은 프로그램을 C 언어 문법을 사용해서 작성한 파일을 말한다.</li>
<li>소스 파일은 텍스트 형식의 파일이며 파일 확장자는 .c를 사용한다.</li>
</ul>
<h3 id="목적-파일obj"><a class="header" href="#목적-파일obj">목적 파일(*.obj)</a></h3>
<ul>
<li>목적 파일(Object File)은 컴파일러(번역기)가 소스 파일을 번역(컴파일)하면 만들어지는 파일이다.</li>
<li>컴파일러가 실행 파일 만드는 시간을 줄이기 위해 만드는 파일이기도 하다.</li>
<li>목적 파일은 컴파일러가 만들어 주기 때문에 사용자가 직접 만들 필요는 없다.</li>
<li>왜 중간에 목적 파일을 만들어 두었을까?
<ul>
<li>소스 파일을 번역해서 바로 실행 파일을 만들면, 소스 파일의 일부만 바뀌어도 소스 파일 전체를 다시 번역해서 실행 파일을 만들어야 하기 때문에 비효율적이다.</li>
<li>그래서 내용이 많은 소스 파일에서 비슷한 작업들을 모아서 여러 개의 파일로 나누고 각각의 파일을 컴파일하는 방식을 사용한다.</li>
<li>여기에서 소스 파일을 나누는 것은 C 언어의 작업이 아니라 개발자가 판단하여 진행하는 일이다.</li>
<li>큰 프로그램을 기능별로 적절하게 나누어 컴파일하자.</li>
</ul>
</li>
</ul>
<h3 id="소스-파일을-나누는-이유"><a class="header" href="#소스-파일을-나누는-이유">소스 파일을 나누는 이유</a></h3>
<ul>
<li>C 언어 컴파일러는 컴파일을 할 때 먼저 소스 파일의 내용이 변경되었는지 체크한 후 변경되었으면 다시 컴파일하여 목적 파일을 만들고, 변경되지 않았다면 이전에 만든 목적 파일을 재사용한다.</li>
<li>따라서 소스 파일이 여러 개로 나누어져 있을 때 소스 파일의 일부가 바뀌었다면, 변경된 소스 파일만 컴파일되어 새로운 목적 파일이 만들어지고 나머지 소스 파일들은 이전에 만들었던 목적 파일을 그대로 재사용하기 때문에 컴파일 시간이 줄어드는 효과가 있다.</li>
</ul>
<h3 id="실행-파일exe"><a class="header" href="#실행-파일exe">실행 파일(*.exe)</a></h3>
<ul>
<li>실행 파일(Executable File)은 컴퓨터에서 실행할 수 있는 파일을 말한다.</li>
<li>하나 이상의 목적 파일을 연결자(Linker)가 연결(Link)해서 실행 파일을 만든다.</li>
<li>이렇게 만들어진 실행 파일은 기계어로 나열된 프로그램 파일로서 더 이상의 컴파일 작업 없이 컴퓨터에서 바로 실행할 수 있다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-c언어로-만드는-첫-번째-프로그램"><a class="header" href="#2-c언어로-만드는-첫-번째-프로그램">2. C언어로 만드는 첫 번째 프로그램</a></h1>
<h2 id="2-1-c-언어-개발-환경-구축하기"><a class="header" href="#2-1-c-언어-개발-환경-구축하기">2-1. C 언어 개발 환경 구축하기</a></h2>
<ul>
<li>이 부분은 책과는 다르게 개발 환경을 구축하였다.</li>
<li>Jetbrains의 Clion IDE를 사용하였다.</li>
<li>C99, C23 버전을 사용해 보았다.</li>
</ul>
<h2 id="2-3-내가-만든-첫-번째-프로그램"><a class="header" href="#2-3-내가-만든-첫-번째-프로그램">2-3. 내가 만든 첫 번째 프로그램</a></h2>
<pre><code class="language-c">/* 첫 번째 프로그램 */
#include &lt;stdio.h&gt;

void main(void) {
    printf(&quot;Hello world!&quot;);
}
</code></pre>
<h4 id="include-stdioh"><a class="header" href="#include-stdioh">#include &lt;stdio.h&gt;</a></h4>
<ul>
<li>C 언어에서는 #으로 시작하는 문장을 전처리기라고 부른다.</li>
<li>전처리기(Preprocessor)는 '미리, 사전'에 처리한다는 뜻이다.</li>
<li>여기에서는 컴파일러에게 이 예제 소스 코드를 번역하기 위해 <code>stdio.h</code> 파일을 먼저 참조하라고 지시하는 것이다.</li>
<li><code>stdio.h</code>파일을 참조하라고 지시한 이유는 <code>main</code>함수에서 사용한 <code>printf</code>함수를 사용하기 위한 정보가 <code>stdio.h</code>파일에 기록되어 있기 때문이다.</li>
</ul>
<h4 id="main"><a class="header" href="#main">main</a></h4>
<ul>
<li>C 언어는 명령들을 일정한 작업 단위로 묶어서 코드를 작성하기 위해 함수(Function)라는 문법을 제공한다.</li>
<li>C 언어 프로그램은 사용자가 만든 함수의 집합체로 구성되는데, 프로그램의 시작을 나타내려면 main 함수를 반드시 정의해야 한다.</li>
</ul>
<h4 id="void"><a class="header" href="#void">void</a></h4>
<ul>
<li>'정해지지 않았다'는 의미의 예약어(Reserved Word)이다.</li>
<li><code>main</code>앞에 있는 <code>void</code>는 '함수의 수행 결과 값이 정해지지 않았다'라는 뜻이고 <code>main</code>뒤 ()괄호 안에 있는 <code>void</code>는 '<code>main</code>함수로 전달되는 정보가 정해지지 않았다'라는 뜻이다.</li>
</ul>
<h4 id="printfhello-world"><a class="header" href="#printfhello-world">printf(&quot;Hello world!&quot;);</a></h4>
<ul>
<li><code>printf</code>는 C 언어이 표준 출력 함수로, 모니터 등의 콘솔(Console)화면에 'Hello world!'라고 출력한다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-자료형"><a class="header" href="#3-자료형">3. 자료형</a></h1>
<h2 id="3-1-컴퓨터의-자료-기억-방식"><a class="header" href="#3-1-컴퓨터의-자료-기억-방식">3-1. 컴퓨터의 자료 기억 방식</a></h2>
<h3 id="데이터정보를-저장하는-공간-메모리"><a class="header" href="#데이터정보를-저장하는-공간-메모리">데이터(정보)를 저장하는 공간, 메모리</a></h3>
<ul>
<li>컴퓨터는 주기억 장치로 램(RAM, Random Access Memory)를 사용하기 때문에 보통 메모리라고 하면 램을 의미한다.</li>
<li>메모리는 1바이트(Byte) 단위로 주소가 매겨져 있으며 운영체제마다 주소를 관리하는 방법이 조금씩 다르다.</li>
<li>하지만 주소가 1바이트 단위로 부여되어 있다고 해서 데이터가 꼭 1바이트 단위로 저장되어야 하는 것은 아니다.</li>
<li>1바이트 단위는 운영체제가 메모리를 관리하는 단위이고, 컴퓨터는 이보다 더 작은 비트 단위로 정보를 저장하거나 읽을 수 있다.</li>
</ul>
<h4 id="1비트는-0-또는-1을-저장할-수-있는-공간이다"><a class="header" href="#1비트는-0-또는-1을-저장할-수-있는-공간이다">1비트는 0 또는 1을 저장할 수 있는 공간이다</a></h4>
<ul>
<li>메모리의 최소 저장 단위는 비트(Bit)이다.</li>
<li>1비트는 0, 1 중에서 한 개를 저장할 수 있는 크기이다.</li>
</ul>
<h4 id="저장-단위가-1비트-증가할-때마다-저장-단위는-2배로-늘어난다"><a class="header" href="#저장-단위가-1비트-증가할-때마다-저장-단위는-2배로-늘어난다">저장 단위가 1비트 증가할 때마다 저장 단위는 2배로 늘어난다</a></h4>
<ul>
<li>1비트는 숫자 2개(0~1)중 하나,</li>
<li>2비트는 숫자 4개(0~3)중 하나,</li>
<li>3비트는 숫자 8개(0~7)중 하나를 저장할 수 있는 크기이다.</li>
<li>즉 1비트 증가할 때마다 저장 단위가 2의 배수만큼 늘어난다.</li>
<li>비트가 8개 모이면 새로운 단위를 사용하며 이것을 바이트(Byte)라고 한다.</li>
<li>1바이트는 비트 8개로 이루어지기 때문에 숫자 256개(0~255)중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<blockquote>
<h4 id="메모리-단위를-더-자세하게-알아보자"><a class="header" href="#메모리-단위를-더-자세하게-알아보자">메모리 단위를 더 자세하게 알아보자</a></h4>
<ul>
<li>메모리 단위를 작은 것에서 큰 순서로 정리해 보면 다음과 같다.</li>
<li>1,024Byte = 1KB(킬로바이트, Kilo Byte)</li>
<li>1,024KB = 1MB(메가바이트, Mega Byte)</li>
<li>1,024MB = 1GB(기가바이트, Giga Byte)</li>
<li>1,024GB = 1TB(테라바이트, Tera Byte)</li>
<li>1,024TB = 1PB(페타바이트, Peta Byte)</li>
<li>1,024PB = 1EB(엑사바이트, Exa Byte)</li>
</ul>
</blockquote>
<h4 id="부호-비트를-사용하여-양수와-음수를-구별한다"><a class="header" href="#부호-비트를-사용하여-양수와-음수를-구별한다">부호 비트를 사용하여 양수와 음수를 구별한다</a></h4>
<ul>
<li>숫자는 음수도 있기 때문에 데이터에 음수가 들어 있다면 메모리에 데이터를 저장할 때 조금 다른 표현을 사용해야 한다.</li>
<li>1바이트를 기준으로 살펴보면 비트 9개에 모두 숫자를 저장하는 것이 아니라 비트 1개에는 음수 또는 양수인지의 상태를 저장하고 나머지 비트 7개에는 숫자를 저장한다.</li>
<li>여기에서 양수와 음수를 구별하는 비트를 부호 비트라고 한다.</li>
</ul>
<p><img src="./images/sign_bit_diagram.png" alt="부호 비트 다이어그램" /></p>
<ul>
<li>부호를 표현하는 데 1비트를 사용했기 때문에 나머지 7비트에만 데이터를 저장한다.</li>
<li>7비트는 양수일 때 숫자 128개(0~127)중 하나,</li>
<li>음수일 때 숫자 128개(-128~-1)중 하나를 저장할 수 있는 크기이다.</li>
<li>즉 -128~127 사이의 숫자 중 하나를 저장한다.</li>
<li>0을 양수에 포함시켜서, 0이나 양수일 때는 0을 부호 비트에 저장한다.</li>
<li>음수 표현법은 2의 보수법과 관련있고, 자세한 내용은 [한 권으로 끝내는 컴퓨터 구조와 프로그래밍] 이라는 책 스터디를 통해 알아보겠다.</li>
</ul>
<h3 id="데이터를-저장할-때-메모리를-절약하려면"><a class="header" href="#데이터를-저장할-때-메모리를-절약하려면">데이터를 저장할 때 메모리를 절약하려면?</a></h3>
<ul>
<li>컴퓨터의 CPU는 모든 데이터를 숫자로 인지하고 처리하기 때문에 문자도 숫자로 변경해주어야 한다.</li>
<li>데이터를 숫자로 변경해서 사용하면 일반적으로 유효 범위를 가지게 된다.</li>
<li>예를 들어 사람의 나이 정보를 저장하려고 한다면, 컴퓨터 메모리를 기준으로 1바이트는 0에서 255 사이의 값을 저장할 수 있기 때문에 1바이트 메모리 공간에 나이 데이터를 저장하면 된다는 결론이 나온다.</li>
<li>이렇게 데이터의 유효 범위를 예상하고 적합한 크기를 결정하는 것은 메모리에 데이터를 저장하는 데 필요한 가장 기본적인 작업이다.</li>
<li>요즘도 메모리를 절약하는 게 중요한가?
<ul>
<li>내 생각은 Yes 이다.</li>
<li>내 프로그래밍 철학은 Fast and Robust 이다.</li>
</ul>
</li>
</ul>
<h2 id="3-2-문자를-숫자로-표현하는-약속-아스키코드"><a class="header" href="#3-2-문자를-숫자로-표현하는-약속-아스키코드">3-2. 문자를 숫자로 표현하는 약속, 아스키코드</a></h2>
<ul>
<li>컴퓨터에 우리가 사용하는 데이터를 저장하려면 일단 문자를 숫자화시켜야 한다고 했는데</li>
<li>그러면 컴퓨터와 같은 기기들이 어떤 규칙으로 문자를 숫자로 변경하는지 알아보자.</li>
</ul>
<h3 id="아스키ascii코드란"><a class="header" href="#아스키ascii코드란">아스키(ASCII)코드란?</a></h3>
<ul>
<li>아스키는 컴퓨터에서 문자를 숫자로 표현하기 위한 약속이다.</li>
<li>ASCII, American Standard Code for Information Interchange</li>
<li>아스키는 1967년에 표준으로 제정되어 1986년에 마지막으로 개정되었다.</li>
<li>아스키는 초창기에 7비트 방식으로 인코딩(Encoding)되었기 때문에 출력 불가능한 제어문자 33개(0~32번)와 공백을 비롯한 출력 가능한 문자 95개로 이루어져 있다.</li>
<li>따라서 총 128개(8비트 중 7비트만 사용)의 코드로 구성된다.</li>
<li>인코딩이란 데이터를 약속한 형태의 숫자로 변경하는 것을 말한다.</li>
<li>7비트 방식으로 인코딩되었다는 것은 7비트 크기의 숫자로 변경되었다는 뜻이다.</li>
<li>하지만 컴퓨터가 발전하여 좀 더 다양한 표현이 필요해짐에 따라 8비트 인코딩을 사용하도록 확장되었다.</li>
<li>0~255 범위를 가지며 이 범위는 부호를 고려하지 않는 1바이트 메모리에 저장할 수 있다.</li>
<li>따라서 컴퓨터에서 문자가 아스키로 표현되었다면 1바이트 메모리에 저장하는 것이 가장 효율적이다.</li>
</ul>
<h2 id="3-3-자료형의-종류"><a class="header" href="#3-3-자료형의-종류">3-3. 자료형의 종류</a></h2>
<h3 id="자료형은-왜-필요할까"><a class="header" href="#자료형은-왜-필요할까">자료형은 왜 필요할까?</a></h3>
<ul>
<li>컴퓨터 메모리가 1바이트(Byte) 단위로 주소가 부여되어 있다고 해서 데이터를 저장하거나 읽을 때 1바이트 단위로만 사용해야 하는 것은 아니다.</li>
<li>자신이 사용할 데이터의 크기에 맞게 메모리(저장 공간)을 할당해서 사용하면 된다.</li>
<li>그래서 메모리를 사용할 때 몇 바이트의 메모리를 사용할 것인지를 명시해야 하는데, 이것을 데이터 타입(Data Type) 또는 자료형이라고 한다.</li>
<li>메모리 공간에서 프로그래머가 원하는 만큼의 크기(1byte, 2bytes, ⋯)를 배정해 주는 것을 '메모리를 할당한다'라고 한다.</li>
<li>C 언어는 사용 빈도가 높은 자료형을 예약어로 제공(Built-in Data Type)하고, 나머지는 사용자가 만드러서 사용할 수 있는 문법(User-defined Data Type)을 제공한다.</li>
<li>데이터를 메모리에 저장하는 작업은 정해 놓은 단위로만 가능하다.</li>
</ul>
<h3 id="정수를-표현하는-자료형"><a class="header" href="#정수를-표현하는-자료형">정수를 표현하는 자료형</a></h3>
<ul>
<li>C 언어는 정수 값을 저장하는 데 세 가지 자료형,</li>
<li>즉 1바이트, 2바이트, 4바이트 크기의 자료형을 제공한다.</li>
</ul>
<h4 id="signed-char-부호가-있는-1바이트-저장-공간"><a class="header" href="#signed-char-부호가-있는-1바이트-저장-공간">signed char: 부호가 있는 1바이트 저장 공간</a></h4>
<ul>
<li><code>signed char</code>는 1바이트(8비트) 크기의 자료형이다.</li>
<li>하지만 부호 있는 데이터를 처리하기 때문에 첫 1비트는 부호 비트로 사용하고 나머지 7비트에만 숫자를 저장한다.</li>
<li>부호 비트가 0이면 양수를 의미하고 총 128개의 숫자(0~127) 중 하나를 저장할 수 있다.</li>
<li>부호 비트가 1이면 음수를 의미하고 128개의 숫자(-128~-1) 중 하나를 저장할 수 있다.</li>
<li>따라서 <code>signed char</code>자료형은 -128~127의 숫자 중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">signed char temperature;
temperature = -2;  // 영하 2℃를 temperature 변수에 저장함
</code></pre>
<ul>
<li>temperature 변수는 자료형이 <code>signed char</code>이므로 1바이트의 메모리 공간을 사용한다.</li>
</ul>
<h4 id="unsigned-char-부호가-없는-1바이트-저장-공간"><a class="header" href="#unsigned-char-부호가-없는-1바이트-저장-공간">unsigned char: 부호가 없는 1바이트 저장 공간</a></h4>
<ul>
<li><code>unsigned char</code>는 부호 비트 없이 1바이트(8비트) 전체를 숫자 저장 공간으로 사용하기 때문에 256개의 숫자(0~255) 중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">unsigned char age;
age = 52;  // 나이 52살을 age 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>unsigned char</code>를 사용했으므로 age 변수에는 255살까지 저장할 수 있다.</li>
</ul>
<h4 id="signed-short-int-부호가-있는-2바이트-저장-공간"><a class="header" href="#signed-short-int-부호가-있는-2바이트-저장-공간">signed short int: 부호가 있는 2바이트 저장 공간</a></h4>
<ul>
<li><code>signed short int</code>는 2바이트(16비트) 크기의 자료형이다.</li>
<li>하지만 부호 있는 데이터를 처리하기 때문에 첫 1비트는 부호 비트로 사용하고 나머지 15비트에만 숫자를 저장한다.</li>
<li>따라서 부호 비트가 0이면 양수를 의미하고 2<sup>15</sup>인 32,768개의 숫자(0~32,767)중 하나를 저장할 수 있다. </li>
<li>부호 비트가 1이면 음수를 이미하고 32,768개의 숫자(-32,768~-1)중 하나를 저장할 수 있다.</li>
<li>즉 -32,768~32,767이 숫자 중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">signed short int dday;
dday = -20;  // D-Day가 20일 남았다고 dday라는 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>signed short int</code>를 사용했으므로 변수 dday에는 -32,768~32,767의 정수 값을 지정할 수 있다.</li>
</ul>
<h4 id="unsigned-short-int-부호가-없는-2바이트-저장-공간"><a class="header" href="#unsigned-short-int-부호가-없는-2바이트-저장-공간">unsigned short int: 부호가 없는 2바이트 저장 공간</a></h4>
<ul>
<li><code>unsigned short int</code>는 2바이트(16비트) 전체를 숫자 저장 공간으로 사용하기 때문에 65,536개의 숫자(0~65,535)중 하나를 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">unsigned short int seconds;
seconds = 35000;  // 3만 5000초를 seconds 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>unsigned short int</code>를 사용했으므로 seconds 변수에는 0~65,525의 정수 값을 저장할 수 있다.</li>
</ul>
<h4 id="signed-long-int-부호가-있는-4바이트-저장-공간"><a class="header" href="#signed-long-int-부호가-있는-4바이트-저장-공간">signed long int: 부호가 있는 4바이트 저장 공간</a></h4>
<ul>
<li><code>signed long int</code>는 4바이트(32비트) 크기이지만 부호 있는 데이터를 처리하기 때문에 첫 1비트만 부호 비트로 사용하고 나머지 31비트에는 숫자를 저장한다.</li>
<li>부호 비트가 0이면 양수인 2<sup>31</sup>개의 숫자(0~2<sup>31</sup>-1)중 하나를 저장할 수 있고,</li>
<li>부호 비트가 1이면 음수인 2<sup>31</sup>개의 숫자(-2<sup>31</sup>~-1)중 하나를 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">signed long int money;
money = 7000000;  // 700만 원을 money 변수에 저장함
</code></pre>
<ul>
<li>자료형으로 <code>signed long int</code>를 사용했으므로 money 변수에는 -2,147,483,648~2,147,483,647의 정수 값을 저장할 수 있다.</li>
</ul>
<h4 id="unsigned-long-int-부호가-없는-4바이트-저장-공간"><a class="header" href="#unsigned-long-int-부호가-없는-4바이트-저장-공간">unsigned long int: 부호가 없는 4바이트 저장 공간</a></h4>
<ul>
<li><code>unsigned long int</code>는 4바이트(32비트) 전체를 숫자 저장 공간으로 사용하기 때문에 2<sup>32</sup>인 4,294,967,296개의 숫자(0~4,294,967,295)중 하나를 저장할 수 있는 크기이다.</li>
</ul>
<pre><code class="language-c">unsigned long int time_seconds;
// 1970년 1월 1일부터 현재까지 흐른 시간을 초 단위로 환산한 값을 time_seconds 변수에 저장함
time_seconds = 1453100624;
</code></pre>
<ul>
<li>
<p>자료형으로 <code>unsigned long int</code>를 사용했으므로 time_seconds 변수에는 0~4,294,967,295의 정수 값을 저장할 수 있다.</p>
</li>
<li>
<p>정수 형식의 자료형을 정리해 보면, <code>char</code>자료형과 <code>int</code>자료형이 있다.</p>
</li>
<li>
<p>이것을 부호의 존재 여부에 따라 나눌 수 있고(<code>signed</code>/<code>unsigned</code>),</p>
</li>
<li>
<p><code>int</code>의 경우에는 조금 더 작은 메모리라는 뜻의 <code>short</code>키워드 또는 조금 더 큰 메모리라는 뜻의 <code>long</code>키워드를 붙여서 다양하게 표현할 수 있다.</p>
</li>
</ul>
<h3 id="정수-자료형은-주로-생략한-형태를-쓴다"><a class="header" href="#정수-자료형은-주로-생략한-형태를-쓴다">정수 자료형은 주로 생략한 형태를 쓴다</a></h3>
<ul>
<li>실제 프로그래밍을 할 때는 위에서 배운 자료형대로 <code>signed char</code>, <code>unsigned long int</code>처럼 전체 예약어를 다 적지 않고 생략된 예약어를 사용한다.</li>
<li>보통 <code>signed</code>, <code>long</code>을 생략한다.</li>
</ul>
<h3 id="실수를-표현하는-자료형"><a class="header" href="#실수를-표현하는-자료형">실수를 표현하는 자료형</a></h3>
<ul>
<li>실수를 표현하는 부동소수점 방식에는 <code>float</code>와 <code>double</code>이 있다.</li>
</ul>
<h4 id="컴퓨터에서-실수를-표현하는-방식-부동소수점"><a class="header" href="#컴퓨터에서-실수를-표현하는-방식-부동소수점">컴퓨터에서 실수를 표현하는 방식, 부동소수점</a></h4>
<ul>
<li>부동소수점(Floating-point) 표현 방식이란 실수를 표현할 때 소수점의 위치를 고정하지 않고 소수점의 위치를 나타내는 수를 따로 적는 방식이다.</li>
<li>부동소수점 표현 방식에 따라 실수 값을 메모리에 저장하면 CPU가 하드웨어적으로 연산해 주기 때문에 프로그래머가 신경 쓸 필요 없다.</li>
<li>실수 형식은 복잡한 연산 과정을 거치기 때문에 정수에 비해 처리 속도가 많이 떨어진다.</li>
<li>실수 312.567을 3.12567x10<sup>2</sup>이라고 표현하면 저장해야 할 정보가 정확하게 둘로 나뉘어져 편리하다.</li>
<li>3.12567 부분을 가수부,</li>
<li>10<sup>2</sup>에서 2를 지수부라고 한다.</li>
<li>C 언어에서는 이 표현을 3.12567E2라고 적는다.</li>
<li>프로그래밍 언어에서 사용하는 실수는 IEEE 754 규약에 정의된 부동소수점 표현이다.</li>
<li>C 언어에서는 32비트(4바이트) 크기의 부동소수점 표현(Single Precision)을 사용하는 <code>float</code>자료형과 64비트(8바이트) 크기의 부동소수점 표현(Double Precision)을 사용하는 <code>double</code>자료형을 제공한다.</li>
</ul>
<h4 id="32비트-부동소수점-표현-float"><a class="header" href="#32비트-부동소수점-표현-float">32비트 부동소수점 표현: float</a></h4>
<ul>
<li>이 자료형은 메모리 공간을 가수부와 지수부로 나누어 실수 형태의 값을 저장하며 그 형식은 다음과 같다.</li>
</ul>
<p><img src="./images/float_diagram.png" alt="IEEE 754 규약에 정의된 float형의 부동소수점 표현" /></p>
<ul>
<li>저장할 수 있는 값의 범위는 1.2E-38~3.4E38이다.</li>
<li>1.2E-38은 2<sup>-126</sup>값을 반올림한 값이고,</li>
<li>3.4E38은 2<sup>128</sup>값을 반올림한 값이다.</li>
<li>지수부의 범위는 왜 2<sup>-126</sup>부터 시작할까?</li>
<li>32비트를 기준으로 할 때, 모든 지수 비트가 0인 -127은 2<sup>-127</sup>값이 그대로 사용되지 않는다.</li>
<li>2<sup>-127</sup>은 오류나 특정한 상황을 표시하는 값으로만 사용된다.</li>
<li>반면에 모든 지수 비트가 1인 128의 경우에는 특정한 상황을 표시하기도 하지만 2<sup>128</sup>값 그대로를 의미하기도 한다.</li>
<li>따라서 <code>float</code>형의 범위가 1.2E-38~3.4E38이 되는 것이다.</li>
</ul>
<blockquote>
<h4 id="bias가-무엇인가"><a class="header" href="#bias가-무엇인가">Bias가 무엇인가?</a></h4>
<ul>
<li>일반 정수는 최상위 비트 값이 0이면 양수이고, 1이면 음수라고 정해 놓고 부호를 구별한다.</li>
<li>하지만 실수 표현에서 지수 부분의 값은 음수나 양수 표현을 최상위 비트 값을 기준으로 하지 않고 정해진 BIAS(편향 지수) 값을 기준으로 하고 있다.</li>
<li>따라서 BIAS 값이 127이라면 127이 0이라는 뜻이다.</li>
</ul>
</blockquote>
<pre><code class="language-c">float pi;
pi = 3.14;
</code></pre>
<ul>
<li>32비트 기반인 <code>float</code>는 저장 범위는 <code>int</code>와 같지만 정수부와 소수부를 모두 저장해야 하기 때문에 소수점 이하 숫자가 6자리밖에 안 된다.</li>
</ul>
<pre><code class="language-c">float pi;
pi = 3.14159264;
</code></pre>
<ul>
<li>이렇게 소수점 이하에 6개보다 많은 숫자를 쓰고 pi 변수에 저장한 후 출력해 보면, 6자리를 넘는 숫자부터는 잘못된 값을 출력한다.</li>
</ul>
<pre><code class="language-text">출력값: 3.141592741
</code></pre>
<ul>
<li>따라서 소수점 이하 숫자를 6자리 이상 사용하려면 64비트 기반의 <code>double</code>자료형을 사용해야 한다.</li>
</ul>
<h4 id="64비트-부동소수점-표현-double"><a class="header" href="#64비트-부동소수점-표현-double">64비트 부동소수점 표현: double</a></h4>
<ul>
<li>이 자료형도 메모리 공간을 가수부와 지수부로 나누어 실수 형태의 값을 저장하며 그 형식은 다음과 같다.</li>
</ul>
<p><img src="./images/double_diagram.png" alt="IEEE 754 규약에 정의된 double형 부동소수점 표현" /></p>
<ul>
<li>값의 저장 범위는 2.2E-308~1.8E308이다.</li>
<li>이 자료형은 64비트를 기반으로 하기 때문에 소수점 이하 14자리까지 안전하게 저장할 수 있다.</li>
</ul>
<blockquote>
<h4 id="실수는-어떻게-메모리에-저장될까"><a class="header" href="#실수는-어떻게-메모리에-저장될까">실수는 어떻게 메모리에 저장될까?</a></h4>
<p>IEEE 754 에 대한 자세한 내용은 아래의 링크를 참조하자.</p>
<p><a href="http://tipssoft.com/bulletin/board.php?bo_table=FAQ&amp;wr_id=177">http://tipssoft.com/bulletin/board.php?bo_table=FAQ&amp;wr_id=177</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-상수와-변수"><a class="header" href="#4-상수와-변수">4. 상수와 변수</a></h1>
<h2 id="4-1-항상-같은-수-상수"><a class="header" href="#4-1-항상-같은-수-상수">4-1. 항상 같은 수, 상수</a></h2>
<ul>
<li>상수(Constant)는 프로그램을 실행할 때 한 번 값이 결정되면 프로그램이 끝날 때까지 다른 값으로 바뀌지 않는 정보를 말한다.</li>
<li>보통 상수는 숫자형, 문자형, 문자열형으로 구분할 수 있다.</li>
</ul>
<h3 id="숫자형-상수"><a class="header" href="#숫자형-상수">숫자형 상수</a></h3>
<ul>
<li>숫자형 상수(Numeric Constant)는 프로그램에서 가장 기본적인 형태의 상수이며 정수형 상수(Integer Constant)와 실수형 상수(Floating-point constant)로 나뉜다.</li>
<li>C 언어 프로그램에서 숫자형 상수는 다음과 같이 쓰인다.</li>
</ul>
<pre><code class="language-c">unsigned int num = 4500;  // 정수형 상수 4500을 부호가 없는 int 자료형 num 변수에 저장함
float a = 0.17;  // 실수형 상수 0.17을 float 자료형 a 변수에 저장함
</code></pre>
<h3 id="정수형-상수의-다양한-진법-표현"><a class="header" href="#정수형-상수의-다양한-진법-표현">정수형 상수의 다양한 진법 표현</a></h3>
<ul>
<li>C 언어에서는 10진수 형식뿐만 아니라 8진수나 16진수 형식으로도 표현할 수 있다.</li>
</ul>
<h4 id="8진수"><a class="header" href="#8진수">8진수</a></h4>
<ul>
<li>8진수 형식의 숫자를 적을 때는 숫자 앞에 0을 붙여서 적는다.</li>
</ul>
<pre><code class="language-text">012, 050, 075
</code></pre>
<h4 id="16진수"><a class="header" href="#16진수">16진수</a></h4>
<ul>
<li>16진수 형식으로 표현할 때는 숫자 앞에 0x 또는 0X를 붙여서 적는다.</li>
</ul>
<pre><code class="language-text">0x25, 0x51, 0xFC, 0XD5, 0xaf, 0xa1
</code></pre>
<ul>
<li>16진수는 각 자리마다 0~9, A~F로 이루어진 총 16개의 숫자와 문자를 사용한다.</li>
</ul>
<h3 id="문자형-상수"><a class="header" href="#문자형-상수">문자형 상수</a></h3>
<ul>
<li>프로그램에서 문자를 표시할 때 사용하는 문자형 상수(Character Constant)는 작은 따옴표(')를 사용하여 표현하며 영문자(Alphabet), 숫자형 문자(Digit), 특수 문자(Special Character)로 구분된다.</li>
</ul>
<pre><code class="language-c">char key = 'A';  // A의 아스키 값 65를 변수 key에 저장함
char next = 'A' + 1;  // A의 아스키 값에 1을 더한 66(B의 아스키 값)을 변수 next에 저장함
</code></pre>
<ul>
<li>컴퓨터 내부에서는 모든 데이터를 숫자로 저장한다.</li>
<li>우리가 사용하는 문자들도 약속된 숫자로 번역해서 사용해야 하는데 이 약속이 아스키코드 표에 정의되어 있다.</li>
<li>C 언어에서는 프로그래머가 ASCII표를 외우지 않고도 좀 더 보기 편하게 문자 값을 사용할 수 있도록 문자형 상수를 제공한다.</li>
</ul>
<blockquote>
<h4 id="문자-3을-03으로-적으면-어떻게-될까"><a class="header" href="#문자-3을-03으로-적으면-어떻게-될까">문자 '3'을 '03'으로 적으면 어떻게 될까?</a></h4>
<ul>
<li>정상적인 경우라면 문자형 상수는 문자 하나를 ''(작은따옴표)로 둘러싸 표시하지만, 실수 또는 고의로 '03'과 같이 적더라도 기계어로 번역할 때 오류가 발생하지 않고 두 개의 문자형 상수 값이 연속으로 반영된다.</li>
<li>즉 '0'의 아스키 값은 48이고 '3'의 아스키 값은 51이기 때문에 문자형 상수 값을 저장하는 메모리의 크기가 1바이트라면 앞쪽 값을 버리고 뒤쪽 값 '3'에 해당하는 51이 저장된다.</li>
<li>메모리가 2바이트라면 '0'의 아스키 값 48이 첫 번째 바이트에 저장되고 '3'의 아스키 값 51이 두 번째 바이트에 저장된다.</li>
</ul>
</blockquote>
<h3 id="문자열형-상수"><a class="header" href="#문자열형-상수">문자열형 상수</a></h3>
<ul>
<li>문자열형 상수(Character-string Constant)는 프로그램에서 문자열(한 개 이상의 문자)을 표시할 때 사용하며 &quot;&quot;(큰따옴표)로 묶어서 표현한다.</li>
<li>문자열은 문자들로 이루어진 집합체이며 문자형 상수에서 사용하는 문자들을 모두 사용할 수 있다.</li>
<li>일반적으로 문자 하나는 1바이트를 차지하기 때문에 &quot;Hello!&quot;라고 적으면 문자 6개이므로 6바이트를 차지할 것이라고 생각하기 쉽다.</li>
<li>하지만 실제로는 7바이트를 차지하게 된다.</li>
<li>왜냐하면 문자열은 자신의 끝을 표시하기 위해 마지막 자리에 '비어있다'를 의미하는 0값이 추가되기 때문이다.</li>
<li>여기에서 0은 숫자 0을 의미하는 것이 아니라 특별한 뜻을 담고 있다.</li>
</ul>
<h2 id="4-2-데이터-저장-공간-변수"><a class="header" href="#4-2-데이터-저장-공간-변수">4-2. 데이터 저장 공간, 변수</a></h2>
<ul>
<li>변수(Variable)는 변하는 값이며, 프로그래밍에서는 두 가지 의미를 가진다.</li>
<li>첫 번째는 프로그램이 실행되는 동안 지속적으로 값이 바뀌는 정보를 말한다.</li>
<li>두 번째는 사용자로부터 데이터를 받거나 처리하려면 저장할 공간이 필요한데, 이러한 저장 공간을 뜻한다.</li>
</ul>
<h3 id="변수-이름"><a class="header" href="#변수-이름">변수 이름</a></h3>
<ul>
<li>메모리는 1바이트 단위로 부여된 주소(Address)로 구분되기 때문에 자신에게 할당된 메모리 공간을 사용하려면 해당 메모리의 시작 주소를 기억해야 한다.</li>
<li>하지만 프로그래머가 숫자로 구성된 이 주소를 일일이 기억하면서 프로그래밍을 하기는 어렵다.</li>
<li>따라서 해당 주소에 이름을 붙여 사용하는데 이 이름이 바로 변수 이름이다.</li>
</ul>
<pre><code class="language-c">int n;  // 4바이트 메모리 공간을 주소 대신 n이라는 변수 이름으로 사용함
</code></pre>
<ul>
<li>프로그램 소스에 사용한 변수 이름은 컴파일러가 소스 코드를 기계어로 번역하는 과정에서 실제 메모리상의 주소로 변경된다.</li>
<li>따라서 프로그램에서 변수 이름을 사용하는 것은 실제로 그 변수 값이 저장될 메모리 주소를 사용하는 것과 같은 의미이다.</li>
</ul>
<h3 id="변수-이름을-정할-때-기억해야-할-것"><a class="header" href="#변수-이름을-정할-때-기억해야-할-것">변수 이름을 정할 때 기억해야 할 것</a></h3>
<ul>
<li>변수 이름은 영문자 a~z, A~Z, 숫자 0~9 그리고 _(밑줄)을 조합하여 구성할 수 있다.</li>
<li>모두 숫자로 구성하거나 숫자로 시작하는 문자열은 변수 이름으로 사용할 수 없다.</li>
<li>변수 이름은 공백을 포함할 수 없다.</li>
<li>변수 이름은 대·소문자를 구별한다.</li>
<li>C 언어의 예약어는 변수 이름으로 사용할 수 없다.</li>
</ul>
<blockquote>
<h4 id="표기법은-이름을-지을-때-사용하는-규칙이다"><a class="header" href="#표기법은-이름을-지을-때-사용하는-규칙이다">표기법은 이름을 지을 때 사용하는 규칙이다</a></h4>
<ul>
<li>표기법(Notation)은 프로그램에서 변수 또는 함수의 이름을 정할 때 사용하는 일정한 규칙이다.</li>
<li>잘 알려진 표기법에는 '카멜 표기법'과 '헝가리언 표기법'이 있다.</li>
</ul>
<pre><code class="language-text">my_name, myName
</code></pre>
</blockquote>
<h3 id="변수-선언하기"><a class="header" href="#변수-선언하기">변수 선언하기</a></h3>
<ul>
<li>프로그램에서 정보를 저장하기 위해 메모리 공간을 확보하는 과정을 '변수를 선언한다'라고 한다.</li>
<li>변수의 크기가 항상 1바이트일 수는 없기 때문에 자신이 사용할 메모리 크기에 적합한 자료형을 지정하여 선언한다.</li>
</ul>
<pre><code class="language-c">signed int num;
</code></pre>
<ul>
<li><code>signed int</code>는 자료형이고 '부호를 고려하는 4바이트'를 의미하기 때문에 이 명령문으로 할당되는 메모리 공간은 4바이트가 된다.</li>
<li>이렇게 할당된 메모리 공간은 num이라는 변수 이름으로 지정했기 때문에, 해당 메모리 공간에 정보를 저장하거나 저장된 정보를 읽을 때는 num이라는 변수 이름을 사용하면 된다.</li>
</ul>
<h3 id="변수-초기화하기"><a class="header" href="#변수-초기화하기">변수 초기화하기</a></h3>
<ul>
<li>변수를 사용하기 전 초기값을 저장해서 깨끗하게 만드는 것을 '초기화'라고 한다.</li>
<li>컴퓨터 메모리는 각종 프로그램에 의해 공유되는 자원이다.</li>
<li>따라서 특정 프로그램이 특정 메모리를 지정해서 사용하는 것이 아니라, 프로그램이 실행될 때 운영체제에 의해 사용할 수 있는 적당한 공간에 할당되는 방식이다.</li>
<li>따라서 자신이 사용한 메모리는 이전에 어떤 프로그램이 사용했는지 알 수 없고 그 메모리에 어떤 값이 들어 있는지도 알 수 없다.</li>
<li>이것은 이전에 이 메모리를 사용한 프로그램이 사용 후에 메모리를 깨끗하게 청소하지 않고 끝내 버리기 때문이다.</li>
<li>이렇게 정리되지 않은 메모리에 들어 있는 값을 쓰레기 값이라고 부르고, 이 값 대신에 자신이 사용하고 싶은 값을 메모리에 저장하는 행위를 '초기화'라고 한다.</li>
</ul>
<pre><code class="language-c">int value;  // 4바이트 크기의 value 변수에 어떤 값이 저장되어 있는지 알 수 없음
</code></pre>
<pre><code class="language-c">int value = 0;  // 4바이트 크기의 value 변수에 정수형 상수 값 0을 넣어 초기화함
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    int money;  // int형 변수 money를 선언함
    money = 3000;  // 변수 money에 값 3000을 저장함
    printf(&quot;money에 저장된 값은 %d&quot;, money);
}
</code></pre>
<pre><code class="language-text">money에 저장된 값은 3000
</code></pre>
<h2 id="4-3-2진수를-16진수로-변환하는-방법"><a class="header" href="#4-3-2진수를-16진수로-변환하는-방법">4-3. 2진수를 16진수로 변환하는 방법</a></h2>
<h3 id="비트-단위-연산에-유용한-16진수"><a class="header" href="#비트-단위-연산에-유용한-16진수">비트 단위 연산에 유용한 16진수</a></h3>
<ul>
<li>메모리가 1비트 증가할 때마다 저장할 수 있는 수의 크기는 2배 늘어난다.</li>
<li>16진수 한 자릿수에는 16개의 숫자(0~9, A~F)중 하나를 저장할 수 있다.</li>
<li>따라서 16진수를 저장할 때 각 자릿수마다 4비트씩 늘어난다고 보면 된다.</li>
<li>16진수 한 자릿수는 4비트를 의미하기 때문에 13의 1과 3이 각각 4비트씩 총 8비트로 표현한다.</li>
<li>마찬가지로 BC는 B와 C가 각각 4비트씩 총 8비트로 표현된다.</li>
<li>4비트 패턴과 16진수를 연결한 표를 보면 알 수 있듯이 4비트로 표현한 값이 2진수 형태이기 때문에 16개 값만 기억한다면 16진수를 2진수로 변환하거나 2진수를 16진수로 변환하는 것이 매우 쉬워진다.</li>
<li>다음 표를 외우자!</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>10진수</th><th>16진수</th><th>2진수</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0000</td></tr>
<tr><td>1</td><td>1</td><td>0001</td></tr>
<tr><td>2</td><td>2</td><td>0010</td></tr>
<tr><td>3</td><td>3</td><td>0011</td></tr>
<tr><td>4</td><td>4</td><td>0100</td></tr>
<tr><td>5</td><td>5</td><td>0101</td></tr>
<tr><td>6</td><td>6</td><td>0110</td></tr>
<tr><td>7</td><td>7</td><td>0111</td></tr>
<tr><td>8</td><td>8</td><td>1000</td></tr>
<tr><td>9</td><td>9</td><td>1001</td></tr>
<tr><td>10</td><td>A</td><td>1010</td></tr>
<tr><td>11</td><td>B</td><td>1011</td></tr>
<tr><td>12</td><td>C</td><td>1100</td></tr>
<tr><td>13</td><td>D</td><td>1101</td></tr>
<tr><td>14</td><td>E</td><td>1110</td></tr>
<tr><td>15</td><td>F</td><td>1111</td></tr>
</tbody></table>
</div>
<ul>
<li>C 언어에서 16진수를 사용할 때는 반드시 앞에 0x를 붙여야 한다.</li>
<li>C 언어는 8진법, 10진법 그리고 16진법은 사용할 수 있어도 2진법 표현은 제공하지 않아서 비트별로 값을 표현하는 형식을 사용할 수가 없다.</li>
<li>하지만 컴퓨터 메모리에 저장된 메모리 패턴은 2진수 표현과 같다.</li>
<li>또한 비트 단위로 값을 사용할 수 있는 기술을 제공하기 때문에 2진법으로 숫자를 변경해야 하는 경우가 많으니 진법 변환을 잘 연습해두자.</li>
</ul>
<h3 id="16진수-표기에-따른-메모리-계산"><a class="header" href="#16진수-표기에-따른-메모리-계산">16진수 표기에 따른 메모리 계산</a></h3>
<ul>
<li>결국 C 언어에서 0x2E라고 표기된 16진수 값을 메모리에 저장하기 위해서는 최소한 1바이트(0010 1110)가 필요하다.</li>
<li>16진수를 0xA처럼 한 자릿수만 적더라도 대입 연산자(=)는 최소 1바이트 단위로 값을 읽고 쓰기 때문에, 표기된 숫자는 4비트만 사용하지 못하고 0x0A값(0000 1010)으로 저장된다.</li>
<li>마찬가지로 다음 코드처럼 0xA를 2바이트 변수인 data에 저장하려면 0x000A 값(0000 0000 0000 1010)으로 저장된다.</li>
</ul>
<pre><code class="language-c">short int data = 0xA;  // short int가 2바이트 메모리를 차지하기 때문에 0x000A라고 적은 것과 같음
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-함수"><a class="header" href="#5-함수">5. 함수</a></h1>
<h2 id="5-1-c-언어와-함수"><a class="header" href="#5-1-c-언어와-함수">5-1. C 언어와 함수</a></h2>
<h3 id="작업-단위로-명령을-표현하는-방법"><a class="header" href="#작업-단위로-명령을-표현하는-방법">작업 단위로 명령을 표현하는 방법</a></h3>
<ul>
<li>컴퓨터의 CPU는 단순화된 명령을 한 번에 하나씩 처리하도록 설계되어 있다.</li>
<li>프로그래밍 언어도 복잡한 표현법보다는 간단한 표현법을 나열하여 상황을 표현한다.</li>
<li>연속적인 행위들을 하나의 작업 단위로 묶어서 정의해 놓는다면 효율적이다.</li>
</ul>
<h3 id="함수란"><a class="header" href="#함수란">함수란?</a></h3>
<ul>
<li>C 언어 프로그램도 특별한 단위나 구분 없이 명령문들을 주욱 나열해서 작성하는 것보다 어떤 작업을 수행하는 일련의 명령문들을 한데 묶어서 그룹으로 만들어 두는 게 좋다.</li>
<li>작업별 그룹으로 나누어 작성한 소스 코드는 관리하기도 편할뿐더러 다른 프로그래머가 보거나 나중에라도 코드의 내용을 쉽게 이해할 수 있다.</li>
<li>C 언어는 소스 코드를 그룹화할 수 있도록 함수(Function)라는 문법을 제공한다.</li>
<li>C 언어는 소스 코드를 함수 단위로 나누어서 작성하는 것을 권장하기 때문에, 잘 작성한 C 언어 프로그램은 수많은 함수들로 이루어진 함수의 집합체라고 할 수 있다.</li>
</ul>
<h4 id="특별한-기능을-가진-main-함수"><a class="header" href="#특별한-기능을-가진-main-함수">특별한 기능을 가진 main 함수</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void main() {
    printf(&quot;Hello, world!&quot;);
}
</code></pre>
<ul>
<li>소스 코드를 번역하는 컴파일러 입장에서는 어떤 함수가 최초로 시작되는 함수인지를 알아야 제대로 된 번역을 할 수 있다.</li>
<li>C 언어는 <code>main</code>이라는 이름의 함수를 '프로그램 시작 함수'로 정해 놓았다.</li>
<li>즉 <code>main</code>함수는 '컴파일러에게 프로그램이 시작한다'고 알려주는 특별한 함수라고 생각하면 된다.</li>
</ul>
<h3 id="c-언어-프로그램은-함수의-집합체이다"><a class="header" href="#c-언어-프로그램은-함수의-집합체이다">C 언어 프로그램은 함수의 집합체이다</a></h3>
<ul>
<li>C 언어의 소스 파일에는 꼭 하나 이상의 함수가 있다.</li>
<li>C 언어로 작성한 프로그램은 함수들의 집합체이고 그 함수들끼리 서로 불러서 사용하는 형태로 진행된다.</li>
</ul>
<h2 id="5-2-함수-정의하고-호출하기"><a class="header" href="#5-2-함수-정의하고-호출하기">5-2. 함수 정의하고 호출하기</a></h2>
<h3 id="함수-정의하기"><a class="header" href="#함수-정의하기">함수 정의하기</a></h3>
<pre><code class="language-c">int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}
</code></pre>
<ul>
<li>함수의 이름은 Sum이며 int형 정수 값 두 개를 입력 받아서 int형 결과 값을 반환하는 함수이다.</li>
<li>함수 이름, 변수 이름은 모두 프로그래머가 임의로 지은 이름이고 나머지는 예약어이다.</li>
<li>이렇게 코드를 써서 함수를 실제로 구현하는 행위를 '함수를 정의한다'라고 한다.</li>
</ul>
<ol>
<li>함수 이름: 함수가 하는 일을 짐작하기 쉽게 짓는 것이 좋다.</li>
<li>매개변수: 함수가 작업을 수행할 때 필요한 데이터가 있다면 변수 단위로 명시한다.</li>
<li>작업 내용: 함수가 작업할 내용을 중괄호 {} 안에 명령문으로 나열한다.</li>
<li>반환값: 함수가 작업한 결과 값을 반환해야 할 때 사용한다(선택 사항).</li>
</ol>
<h3 id="함수-호출하기"><a class="header" href="#함수-호출하기">함수 호출하기</a></h3>
<ul>
<li>함수가 다른 함수를 사용하는 것을 '함수를 호출한다'고 한다.</li>
<li>즉 C 언어 프로그램은 함수가 다른 함수를 호출하면서 프로그램이 진행된다.</li>
<li>함수를 호출하는 함수를 호출자(Caller)라고 부르고 호출되는 함수를 피호출자(Callee)라고 한다.</li>
</ul>
<pre><code class="language-c">int Sum(int value1, int value2) {
    int result = value1 + value2;
    return value1 + value2;
}

void main() {
    int a = 2, b = 3, value;
    value = Sum(2, 3);
}
</code></pre>
<h4 id="함수-호출-과정-살펴보기"><a class="header" href="#함수-호출-과정-살펴보기">함수 호출 과정 살펴보기</a></h4>
<ol>
<li><code>main</code>함수가 <code>Sum</code>함수를 호출하면서 a와 b 값을 <code>Sum</code>함수에 전달한다.</li>
<li><code>Sum</code>함수의 매개변수에 <code>main</code>함수에서 전달 받은 값이 복사된다.</li>
<li>입력된 값으로 더하기 작업을 수행한다.</li>
<li><code>main</code>함수로 결과 값을 반환한다.</li>
</ol>
<h3 id="함수의-매개변수-자세히-살펴보기"><a class="header" href="#함수의-매개변수-자세히-살펴보기">함수의 매개변수 자세히 살펴보기</a></h3>
<ul>
<li>프로그램에서 사용하는 데이터는 필요할 때만 존재해야 효율적이므로 함수에서 필요할 때 만들었다가 함수가 끝날 때 함께 사라지도록 만드는 게 보통이다.</li>
<li>그래서 어떤 함수가 가지고 있던 데이터를 다른 함수에 전달하려면 다소 복잡한 표현법을 사용해야 한다.</li>
<li><code>main</code>함수는 <code>a</code>, <code>b</code>에 저장된 값을 더하기 위해 <code>Sum</code>함수를 호출하도록 구성했다.</li>
<li>그런데 함수 안에서 선언한 변수들은 해당 함수에서만 사용할 수 있기 때문에 <code>Sum</code>함수 내부에 선언된 <code>value1</code>, <code>value2</code>, <code>result</code>변수는 <code>Sum</code>함수에서만 사용할 수 있고, <code>main</code>함수 내부에 선언된 <code>a</code>, <code>b</code>변수는 <code>main</code>함수에서만 사용할 수 있다.</li>
<li>즉 <code>Sum</code>함수가 <code>a</code>, <code>b</code>를 직접 사용할 수 없기 때문에 <code>main</code>함수의 <code>a</code>, <code>b</code>변수 값을 <code>Sum</code>함수가 사용하기 위해 매개변수(Parameter)가 필요한 것이다.</li>
<li>매개변수는 호출자(<code>main</code>)에서 전달하는 값을 피호출자(<code>Sum</code>)에서 전달 받는 역할을 하는 변수를 의미하며 <code>Sum</code>함수의 <code>value1</code>과 <code>value2</code>가 여기에 해당한다.</li>
<li>이때 <code>main</code>에서 전달한 순서대로 <code>Sum</code>함수의 매개변수가 값을 전달 받기 때문에 순서와 개수를 잘 맞추어야 한다.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}

void main() {
    int s;
    s = Sum(2, 3);
    printf(&quot;더하기 작업의 결과는 %d \n&quot;, s);
}
</code></pre>
<ul>
<li><code>Sum</code>함수는 프로그램의 시작인 <code>main</code>함수보다 먼저 작성해야 한다.</li>
<li><code>main</code>함수 뒤에 작성하면 오류가 발생하는데, 이에 대한 자세한 내용은 [5-4]를 보자.</li>
<li><code>%d</code>는 정수를 출력할 때 사용하는 키워드이다.</li>
<li>이와 같이 출력을 위해 사용하는 여러 키워드들은 [6장]에서 배우자.</li>
<li>모든 함수가 매개변수를 가지는 것은 아니다.</li>
<li>특별히 호출자로부터 넘겨받을 정보가 없다면()안을 비워두거나 ()안에 <code>void</code>라고 적어 인자가 없음을 명시하면 된다.</li>
</ul>
<h3 id="함수의-반환값-자세히-살펴보기"><a class="header" href="#함수의-반환값-자세히-살펴보기">함수의 반환값 자세히 살펴보기</a></h3>
<h4 id="반환값이란"><a class="header" href="#반환값이란">반환값이란?</a></h4>
<ul>
<li><code>Sum</code>함수가 수행한 결과 값을 호출자로 넘겨주면 <code>Sum</code>함수의 역할은 끝이 난다.</li>
<li>함수에서 <code>return</code>이라는 예약어를 사용하면 함수는 그 위치에서 종결되며, <code>return</code>뒤에 명시된 <code>result</code>변수 값이 <code>Sum</code>함수의 반환값(Return Value)이 된다.</li>
<li>함수가 값을 반환한다는 뜻은 호출자의 어떤 변수에 값을 대입한다는 뜻이기도 하다.</li>
<li>따라서 변수를 선언할 때처럼 함수 이름 앞에 함수의 반환값에 대한 자료형을 명시해야 한다.</li>
</ul>
<blockquote>
<h4 id="함수의-반환값이-없는-경우도-있을까"><a class="header" href="#함수의-반환값이-없는-경우도-있을까">함수의 반환값이 없는 경우도 있을까?</a></h4>
<ul>
<li>모든 함수가 반환값을 가지는 것은 아니다.</li>
<li>[12장]이후에 배울 포인터나 배열 문법은 문법 자체에 값을 반환하는 기능을 가지고 있다.</li>
<li>따라서 <code>return</code>을 사용하여 결과 값을 반환할 필요가 없다.</li>
<li>반환할 값이 없으면 함수 이름 앞에 <code>void</code>를 적고 <code>return</code>을 사용하지 않으면 된다.</li>
</ul>
<pre><code class="language-c">void ZeroData(int *p) {
    *p = 0;  // 전달된 주소에 가서 0을 대입한다(의미적으로 0이 반환된 것).
}
</code></pre>
<ul>
<li><code>void</code>형식으로 정의한 함수의 <code>return</code>뒤에 반환값을 적으면 오류로 처리된다.</li>
</ul>
<pre><code class="language-c">void Test(int value1, int value2) {
    int result = value1 + value2;
    return result;  // 오류 발생
}
</code></pre>
</blockquote>
<h4 id="return의-또-다른-역할"><a class="header" href="#return의-또-다른-역할">return의 또 다른 역할</a></h4>
<ul>
<li><code>return</code>문은 값을 반환하는 기능 외에도 함수를 종료하는 기능도 가지고 있다.</li>
<li>따라서 단순히 함수를 종결할 목적으로 <code>return</code>을 사용할 때는 <code>return</code>뒤에 반환 값을 적지 않아도 오류가 발생하지 않는다.</li>
</ul>
<pre><code class="language-c">void Test(int value1, int value2) {
    int a = 5;
    return;  // Test 함수가 정상적으로 종료됨
    a = a + 1; // 오류는 아니지만 함수가 이미 종료되었기 때문에 실행되지 않음
}
</code></pre>
<ul>
<li><code>return</code>문을 두 번 적으면 오류가 발생하지는 않지만 두 번째 <code>return</code>문은 실행되지 않는다.</li>
</ul>
<h3 id="함수-이름을-짓는-방법"><a class="header" href="#함수-이름을-짓는-방법">함수 이름을 짓는 방법</a></h3>
<ul>
<li>C 언어로 작성한 소스 코드는 '함수의 집합체'이다.</li>
<li>따라서 이 함수들은 서로를 구별하고 사용할 수 있는 기준이 필요한데 그것이 함수 이름(Function Name)이다.</li>
<li>함수 이름을 짓는 법은 변수 이름 짓는 법과 똑같다.</li>
<li>영문자(a~z, A~Z), 숫자(0~9) 그리고 밑줄(_)을 조합하여 구성할 수 있다.</li>
<li>하지만 이름 전체를 숫자로 구성하거나 숫자로 시작하는 이름은 오류가 발생하기 때문에 함수 이름으로 사용할 수 없다.</li>
<li>공백을 포함할 수 없다.</li>
<li>대·소문자를 구별한다.</li>
<li>C 언어의 예약어는 함수 이름으로 사용할 수 없다.</li>
<li>한 프로그램에서 이름이 같은 함수가 두 개 이상 존재하는 경우에도 오류로 처리된다.</li>
</ul>
<blockquote>
<h4 id="프로그래밍에서-버그란-무엇일까"><a class="header" href="#프로그래밍에서-버그란-무엇일까">프로그래밍에서 버그란 무엇일까?</a></h4>
<ul>
<li>프로그래밍을 하다 보면 종종 오류가 발생한다.</li>
<li>이때 겪는 오류는 크게 두 가지인데 구문 오류(Syntax Error)와 의미상 오류(Semantic Error)가 있다.</li>
<li>구문 오류는 프로그래밍 언어가 제공하는 규칙을 제대로 지키지 않았을 때 발생한다.</li>
<li>이런 경우는 컴파일하기 전에 편집기에서 표시해 주거나, 컴파일할 때 컴파일러가 체크해 알려주기 때문에 찾기 쉽다.</li>
<li>반면에 의미상 오류는 '깡통이 맛있다'와 같은 문장처럼 문법적으로는 맞지만 의미적으로 틀릴 때 발생한다.</li>
<li>이런 오류는 정말 찾기 어렵다.</li>
<li>기계어로 번역할 때는 오류 없이 잘 번역되지만 프로그램을 실행하면 오류가 나서 중단되어 버리기 때문이다.</li>
<li>이러한 상황을 프로그래밍에서 '버그가 발생했다'고 한다.</li>
<li>프로그램에 버그가 발생하면 문법적으로는 문제가 없기 때문에 컴파일러가 오류 사항을 체크해주지 않는다.</li>
<li>따라서 프로그래머가 일일이 소스를 보면서 왜 잘못된 결과가 나오는지 체크해야 하는데, 이렇게 버그를 해결하기 위해 작업하는 행위를 디버깅(Debugging)이라고 한다.</li>
</ul>
</blockquote>
<h2 id="5-3-main-함수-정리하기"><a class="header" href="#5-3-main-함수-정리하기">5-3. main 함수 정리하기</a></h2>
<ul>
<li>한 개의 프로그램에서 <code>main</code>함수는 반드시 한 개만 있어야 한다.</li>
<li><code>main</code>함수가 없거나 두 개 이상 존재하면 컴파일할 때 오류가 발생한다.</li>
<li><code>main</code>함수는 반환형이나 매개변수를 사용자가 별도로 정할 수 없다.</li>
<li>그 대신 몇 가지 정해진 형식을 사용할 수 있도록 되어 있다.</li>
</ul>
<h3 id="main-함수의-반환값"><a class="header" href="#main-함수의-반환값">main 함수의 반환값</a></h3>
<ul>
<li>사용자가 직접 프로그램을 실행시키는 경우도 있지만 특정 프로그램이 다른 프로그램을 실행시키는 경우도 있다.</li>
<li>만약 A라는 프로그램이 B라는 프로그램을 실행시켰다고 생각해보자.</li>
<li>A프로그램 입장에서는 자신이 실행시킨 B프로그램이 정상적으로 작업을 완료했는지, 어떤 상태로 종료했는지 등을 확인해야 할 때가 있다.</li>
<li>이때 B프로그램이 A프로그램에게 자신의 상태 값을 알려주는 방법이 여러 가지 있는데, 그 중 하나가 <code>main</code>함수의 반환값이다.</li>
</ul>
<h4 id="int형으로-반환하기"><a class="header" href="#int형으로-반환하기">int형으로 반환하기</a></h4>
<ul>
<li>프로그램의 상태를 알려주기 위해 <code>main</code>함수의 반환값으로 <code>int</code>형을 사용한다.</li>
</ul>
<pre><code class="language-c">int main() {
    return 1;  // 값 1을 반환함
}
</code></pre>
<ul>
<li>예시에서 <code>return 1;</code>라고 한 것은 1이 참을 의미하므로 프로그램이 성공적으로 실행되었다는 것을 보여주기 위함이다.</li>
<li><code>main</code>함수의 반환값은 0, 1뿐만 아니라 어떤 값을 사용해도 상관없다.</li>
</ul>
<h4 id="void형으로-반환하기"><a class="header" href="#void형으로-반환하기">void형으로 반환하기</a></h4>
<ul>
<li>프로그램에 특별히 반환할 내용이 없다면 <code>void</code>를 사용하면 된다.</li>
</ul>
<pre><code class="language-c">void main() {
    // 반환값 없음
}
</code></pre>
<h3 id="main함수의-매개변수"><a class="header" href="#main함수의-매개변수">main함수의 매개변수</a></h3>
<ul>
<li>명령 프롬프트로 프로그램을 실행할 때, 실행 인자(Argument)를 적을 수 있다.</li>
<li>실행 인자는 공백으로 구분한다.</li>
<li>실행 인자는 프로그램이 시작할 때 넘겨 받는 정보를 말한다.</li>
<li>실행 인자 또한 프로그램 입장에서는 변수로 받기 때문에 <code>main</code>함수의 매개변수가 받는다.</li>
</ul>
<pre><code class="language-c">void main(int argc, char *argv[]) {
    // argc에는 실행 인자의 개수, argv에는 실행 인자값이 들어감
}
</code></pre>
<ul>
<li><code>*argv[]</code>는 포인터형 배열인데, 이것은 뒤에서 포인터와 배열을 배워야 이해할 수 있다.</li>
<li>포인터가 n개 있다는 것을 의미하는 문법이다.</li>
<li>사용자가 실행 인자를 사용하든 사용하지 않든 프로그램에서 실행 인자를 받을 필요가 없다면 매개변수 없이 <code>main()</code>이라고 명시하거나, <code>void</code>를 사용하여 <code>main(void)</code>와 같이 매개변수가 없음을 확실히 명시하면 된다.</li>
</ul>
<h2 id="5-4-함수-원형-선언하기"><a class="header" href="#5-4-함수-원형-선언하기">5-4. 함수 원형 선언하기</a></h2>
<h3 id="함수를-호출할-때-기억해야-할-것"><a class="header" href="#함수를-호출할-때-기억해야-할-것">함수를 호출할 때 기억해야 할 것</a></h3>
<ul>
<li>컴파일러는 C 언어 소스 코드를 기계어로 번역할 때, 코드의 위쪽에서 아래쪽으로 내용을 읽으며 번역한다.</li>
<li>따라서 피호출자가 호출자의 위쪽에 있는 경우에는 번역에 문제가 생기지 않는다.</li>
<li>왜냐하면 컴파일러가 호출자에서 피호출자를 호출하는 명령을 기계어로 번역할 때 피호출자가 어떤 형태의 매개변수를 원하는지, 작업 후에 결과 값을 어떻게 반환하는지를 이미 읽어서 알고 있기 때문이다.</li>
<li>하지만 호출자가 피호출자보다 위에 놓이는 경우에는 피호출자를 호출하는 명령을 번역하는 시점에 아직 컴파일러는 피호출자를 본 적이 없어서 호출 작업과 관련된 코드를 구성할 수 없기 때문이다.</li>
</ul>
<h3 id="함수-원형이란"><a class="header" href="#함수-원형이란">함수 원형이란?</a></h3>
<ul>
<li>프로그래밍을 하다 보면 두 함수가 서로를 호출하는 경우도 생긴다.</li>
<li>따라서 피호출자가 항상 호출자의 위쪽에 놓일 수는 없다.</li>
<li>이런 경우에 함수 원형(Function Prototype)을 사용해서 해결한다.</li>
<li>함수의 원형은 함수가 호출될 때 필요한 정보인 함수 이름, 매개변수, 반환 자료형을 포함하는 표현식이다.</li>
</ul>
<pre><code class="language-c">int Sum(int value1, int value2);  // 함수 원형 선언

void main() {
    int s;
    s = Sum(2, 3);
}

int Sum(int value1, int value2) {
    int result = value1 + value2;
    return result;
}
</code></pre>
<ul>
<li>함수 원형을 미리 선언해 두면 이 프로그램의 소스 파일 어딘가에 해당 형식을 가진 함수가 존재한다는 것을 컴파일러가 인지하게 된다.</li>
<li>따라서 컴파일러는 함수의 원형을 참조하여 <code>main</code>함수에서 <code>Sum</code>함수를 호출하는 구조를 만들 수 있다.</li>
</ul>
<blockquote>
<h4 id="함수-원형을-선언할-때-매개변수-이름을-생략할-수-있다"><a class="header" href="#함수-원형을-선언할-때-매개변수-이름을-생략할-수-있다">함수 원형을 선언할 때 매개변수 이름을 생략할 수 있다.</a></h4>
<ul>
<li>함수의 호출 구조를 만들 때 매개변수 정보는 개수나 자료형만 사용하기 때문에 함수 원형을 적을 때 매개변수 이름을 생략해도 된다.</li>
<li>하지만 오류가 발생하지 않는다고 해도 코드의 가독성을 위해 매개변수 이름은 생략하지 않는 것이 좋다.</li>
</ul>
</blockquote>
<ul>
<li>함수를 '정의'하는 것과 '선언'하는 것을 헷갈리지 말자.</li>
<li>함수를 정의한다는 것은 실제로 함수를 만드는, 함수를 구현하는 행위를 의미한다.</li>
<li>함수를 선언한다는 뜻은 좀 더 명확히 이야기하면 '함수의 원형을 선언한다'는 뜻과 같다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-표준-출력-함수"><a class="header" href="#6-표준-출력-함수">6. 표준 출력 함수</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-연산자"><a class="header" href="#7-연산자">7. 연산자</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-조건문"><a class="header" href="#8-조건문">8. 조건문</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-반복문"><a class="header" href="#9-반복문">9. 반복문</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-시프트-연산자와-비트-연산자"><a class="header" href="#10-시프트-연산자와-비트-연산자">10. 시프트 연산자와 비트 연산자</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-지역-변수와-전역-변수"><a class="header" href="#11-지역-변수와-전역-변수">11. 지역 변수와 전역 변수</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-배열과-문자열"><a class="header" href="#12-배열과-문자열">12. 배열과 문자열</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-포인터"><a class="header" href="#13-포인터">13. 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-표준-입력-함수"><a class="header" href="#14-표준-입력-함수">14. 표준 입력 함수</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-배열과-포인터"><a class="header" href="#15-배열과-포인터">15. 배열과 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-메모리-할당"><a class="header" href="#16-메모리-할당">16. 메모리 할당</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-다차원-포인터"><a class="header" href="#17-다차원-포인터">17. 다차원 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-구조체와-연결-리스트"><a class="header" href="#18-구조체와-연결-리스트">18. 구조체와 연결 리스트</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-파일-입출력"><a class="header" href="#19-파일-입출력">19. 파일 입출력</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-함수-포인터"><a class="header" href="#20-함수-포인터">20. 함수 포인터</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tip1-주니어-프로그래머-딱지-떼는-다섯-가지-팁"><a class="header" href="#tip1-주니어-프로그래머-딱지-떼는-다섯-가지-팁">Tip1. 주니어 프로그래머 딱지 떼는 다섯 가지 팁!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tip2-주니어-프로그래머-딱지-떼는-일곱-가지-팁"><a class="header" href="#tip2-주니어-프로그래머-딱지-떼는-일곱-가지-팁">Tip2. 주니어 프로그래머 딱지 떼는 일곱 가지 팁!</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
