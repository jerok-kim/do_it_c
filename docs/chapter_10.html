<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>시프트 연산자와 비트 연산자 - Study: Do it C 언어 입문</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html" class="active"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="10-시프트-연산자와-비트-연산자"><a class="header" href="#10-시프트-연산자와-비트-연산자">10. 시프트 연산자와 비트 연산자</a></h1>
<h2 id="10-1-비트-단위-연산과-비트-패턴"><a class="header" href="#10-1-비트-단위-연산과-비트-패턴">10-1. 비트 단위 연산과 비트 패턴</a></h2>
<h3 id="비트-단위-연산자가-필요한-이유"><a class="header" href="#비트-단위-연산자가-필요한-이유">비트 단위 연산자가 필요한 이유</a></h3>
<ul>
<li>비트는 0 또는 1을 저장할 수 있는 공간이다.</li>
<li>이 장에서 배울 것들은 이 '비트'를 다루는 데 필요한 연산자이다.</li>
<li>C 언어는 왜 비트 단위의 연산자를 제공하는 것일까?</li>
<li>프로그램이 다루는 데이터 중에 두 가지 상황 중 한 가지를 선택하거나 저장하는 경우가 많다.</li>
<li>예를 들어 '전등의 상태'를 프로그램에 저장해야 한다면, 이런 상태를 '꺼짐', '켜짐'이라고 문자 그대로 저장하면 프로그램의 처리 효율이 낮아질 수 밖에 없다.</li>
<li>따라서 문자가 아닌 숫자로 저장해 효율을 높이는 것이 좋다.</li>
<li>0이면 '꺼짐'을 의미하고 1이면 '켜짐'을 의미하도록 약속해서 사용하는 것이다.</li>
<li>이런 상황에서 우리는 '1비트'에 0 또는 1 중 한 가지 값을 저장할 필요를 느낀다.</li>
<li>하지만 C 언어에서 제공하는 자료형의 최소 단위는 1바이트(8비트)이다.</li>
<li>0, 1 중에 하나를 저장하더라도 무조건 1바이트 저장 공간을 사용하는 <code>char</code>형 변수를 선언하고 사양해야 하는 것이다.</li>
</ul>
<pre><code class="language-c">unsigned char lamp_state = 0;  // 기본값은 전등이 꺼져 있음
lamp_state = 1;                // 전등이 켜지면 1로 변경함
</code></pre>
<ul>
<li>0과 1로 자료를 저장할 수 있는 프로그램을 만들 때 비트 단위로 연산한다면 메모리를 많이 절약할 수 있다.</li>
<li>이렇게 비트 단위로 어떤 작업을 하고 싶다면 시프트 연산자와 비트 연산자를 반드시 알아야 한다.</li>
</ul>
<h3 id="비트-패턴과-16진법"><a class="header" href="#비트-패턴과-16진법">비트 패턴과 16진법</a></h3>
<ul>
<li>C 언어는 2진법 상수 표현을 제공하지 않아서 소스 코드에서는 2진법으로 변환하기 쉬운 16진법으로 사용하자.</li>
<li>다음 표는 꼭 외워라.</li>
<li>2진법 ↔ 16진법 변환표</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>0000 : 0</th><th>0001 : 1</th><th>0010 : 2</th><th>0011 : 3</th></tr></thead><tbody>
<tr><td>0100 : 4</td><td>0101 : 5</td><td>0110 : 6</td><td>0111 : 7</td></tr>
<tr><td>1000 : 8</td><td>1001 : 9</td><td>1010 : A(10)</td><td>1011 : B(11)</td></tr>
<tr><td>1100 : C(12)</td><td>1101 : D(13)</td><td>1110 : E(14)</td><td>1111 : F(15)</td></tr>
</tbody></table>
</div>
<ul>
<li>예를 들어 부호 없는 1바이트 <code>data</code>변수를 선언하고 그 변수에 16진수 값 5A로 초기화하는 코드를 다음과 같이 명시한다.</li>
</ul>
<pre><code class="language-c">unsigned char data = 0x5A;
</code></pre>
<ul>
<li>16진수 한 자리는 4비트를 의미하기 때문에 다음과 같이 1바이트(8비트) 크기의 <code>data</code>변수는 4자리씩 나뉜 2진법으로 표현한다.</li>
</ul>
<pre><code class="language-text">data : 0101 1010
</code></pre>
<ul>
<li>비트를 그림으로 그려서 설명할 때 비트 번호는 다음과 같이 명시한다.</li>
<li>오른쪽에서 왼쪽으로 갈수록 비트 번호가 커진다.</li>
</ul>
<p><img src="./images/0x5A_bit_pattern.png" alt="16진수 0x5A의 비트 패턴" /></p>
<h2 id="10-2-시프트-연산자"><a class="header" href="#10-2-시프트-연산자">10-2. 시프트 연산자</a></h2>
<h3 id="시프트-연산자의-기능"><a class="header" href="#시프트-연산자의-기능">시프트 연산자의 기능</a></h3>
<ul>
<li>시프트 연산자(&lt;&lt;, &gt;&gt;)는 변수의 값을 지정한 비트 수만큼 왼쪽 또는 오른쪽으로 비트를 이동 시키는 기능을 한다.</li>
</ul>
<pre><code class="language-c">오른쪽에서 왼쪽으로 이동
변수 &lt;&lt; 이동할 비트 수

unsigned char data = 0x1A;
// 이동 전: 0001 1010
data = data &lt;&lt; 2;
// 이동 후: 0110 1000
</code></pre>
<pre><code class="language-c">왼쪽에서 오른쪽으로 이동
변수 &gt;&gt; 이동할 비트 수

unsigned char data = 0x1A;
// 이동 전: 0001 1010
data = data &gt;&gt; 2;
// 이동 후: 0000 0110
</code></pre>
<ul>
<li><code>data = data &lt;&lt; 2</code>는 축약해서 <code>data &lt;&lt;= 2</code>로 표현할 수도 있다.</li>
<li>이동한 비트들이 변수를 위해 할당된 메모리 공간(자료형)의 크기를 벗어나면 해당 비트들은 사라지고, 비트가 이동한 빈자리에는 0이 채워진다.</li>
<li>비트가 왼쪽으로 이동해서 사라지는 것을 오버플로(Overflow)라 부르고, 오른쪽으로 이동해서 사라지는 것을 언더플로(Underflow)라고 부른다.</li>
</ul>
<p><img src="./images/shift_operator_1.png" alt="시프트 연산자 (&lt;&lt;)" /></p>
<h3 id="시프트-연산자의-특성-이용하기"><a class="header" href="#시프트-연산자의-특성-이용하기">시프트 연산자의 특성 이용하기</a></h3>
<ul>
<li>이렇게 비트를 이동시키면 어떤 효과가 있을까?</li>
<li>1이 왼쪽으로 1칸씩 이동할 때마다 2를 곱한 만큼 숫자가 커지고, 오른쪽으로 1칸씩 이동할 때마다 2를 나눈 만큼 숫자가 작아진다.</li>
<li>결국 <code>&lt;&lt;</code> 연산을 사용하여 n개의 비트를 오른쪽에서 왼쪽으로 이동하면 2<sup>n</sup>을 곱한 것과 같은 효과가 있다.</li>
<li><code>&gt;&gt;</code> 연산을 사용하여 n개의 비트를 왼쪽에서 오른쪽으로 이동하면 2<sup>n</sup>을 나눈 것과 동일한 효과가 있다.</li>
</ul>
<h4 id="시프트-연산자로-곱셈과-나눗셈-대체하기"><a class="header" href="#시프트-연산자로-곱셈과-나눗셈-대체하기">시프트 연산자로 곱셈과 나눗셈 대체하기</a></h4>
<ul>
<li>시프트 연산은 속도가 빠른 명령인데 반해 곱셈이나 나눗셈 연산자는 속도가 느린 명령이다.</li>
<li>따라서 2의 제곱(2, 4, 8, 16, ⋯)으로 곱하거나 나눌 때 시프트 연산으로 대체하는 것이 더 효율적이다.</li>
<li>물론 컴파일러가 번역할 때 최적화 옵션을 '수행 속도'로 설정해 주면 어느 정도 알아서 연산 방식을 변환해 주지만, 프로그래머가 직접 명시적으로 변환해 주는 것이 더 좋다.</li>
<li>하지만, 곱셈과 나눗셈을 모두 시프트 연산자로 대체할 수는 없다.</li>
<li>비트 패턴이 2진수로 되어 있기 때문에 비트 이동 효과가 2의 제곱만 적용되기 때문이다.</li>
</ul>
<h3 id="시프트-연산자를-사용할-때-주의할-점"><a class="header" href="#시프트-연산자를-사용할-때-주의할-점">시프트 연산자를 사용할 때 주의할 점</a></h3>
<h4 id="연산자-우선순위가-낮다"><a class="header" href="#연산자-우선순위가-낮다">연산자 우선순위가 낮다</a></h4>
<ul>
<li>시프트 연산자의 우선순위가 덧셈(+) 연산자보다 낮다.</li>
<li>그래서 곱셈(*)과 나눗셈(/), 덧셈(+) 연산자로 이루어진 수식을 그대로 시프트 연산자로 변환하는 경우에 잘못된 결과가 나올 수 있다.</li>
<li>이 문제를 해결하려면 괄호를 사용하자.</li>
</ul>
<h4 id="변수에-부호가-있는-경우"><a class="header" href="#변수에-부호가-있는-경우">변수에 부호가 있는 경우</a></h4>
<ul>
<li>부호가 있는 변수에 시프트 연산을 하면 연산 특성이 달라지기 때문에 주의해야 한다.</li>
<li><code>signed char</code>로 선언한 변수라면 최상위 비트가 부호 비트로 사용되기 때문에 음수 값을 시프트 연산할 때 <code>unsigned char</code>와 다른 방식으로 처리된다.</li>
</ul>
<pre><code class="language-c">char data = 0x85;  // 10진수 -123
data = data &gt;&gt; 3;
</code></pre>
<p><img src="./images/shift_operator_2.png" alt="시프트 연산자 (&gt;&gt;)" /></p>
<ul>
<li><code>unsigned</code>형식으로 선언된 변수들은 시프트 연산으로 비트가 이동해서 생긴 빈 공간에 무조건 0을 채우게 된다.</li>
<li><code>signed</code>변수들은 <code>&gt;&gt;</code>를 사용하여 '왼쪽에서 오른쪽으로 이동할 때' 자신의 부호를 유지하기 위해서 부호 비트가 1이면 비트가 이동한 빈 공간에 1을 채우고 부호 비트가 0이면 0으로 채운다.</li>
<li>하지만 여기에 더 큰 문제가 있다.</li>
<li>-123을 8로 나누면 -15가 나오는데, 시프트 연산자를 사용하여 나눗셈을 하려고 <code>&gt;&gt; 3</code>으로 연산하면 -16이 나온다는 것이다.</li>
<li><code>data</code>변수가 가지는 음수 값이 8의 배수인 경우에는 <code>&gt;&gt; 3</code>과 같은 결과가 나오지만 8의 배수가 아닌 경우에는 1만큼 더 적은 값이 나온다.</li>
<li>따라서 음수를 다루는 경우에는 나누어지는 숫자가 나누는 숫자의 배수인지를 체크해서 사용하거나, 나눗셈을 <code>&gt;&gt;</code>연산자로 대체하지 말고 그냥 사용하는 것이 좋다.</li>
</ul>
<h2 id="10-3-비트-연산자"><a class="header" href="#10-3-비트-연산자">10-3. 비트 연산자</a></h2>
<h3 id="비트-연산자란"><a class="header" href="#비트-연산자란">비트 연산자란?</a></h3>
<ul>
<li>비트 연산자는 비트 단위로 AND, OR, NOT, XOR(Exclusive OR, 배타적 논리합) 연산을 수행 한다.</li>
<li>논리 연산자와 구별하기 위해서 AND 연산은 &amp;, OR 연산은 |, NOT 연산은 ~, XOR 연산은 ^ 기호를 사용한다.</li>
<li>AND 연산은 연산에 참여하는 A, B값이 둘 다 1이어야 결과 값이 1이 나오고,</li>
<li>OR 연산은 A, B값이 둘 다 0인 경우에만 결과 값이 0이 나온다.</li>
<li>NOT 연산은 현재 비트 패턴이 반전(0이면 1, 1이면 0)되며,</li>
<li>XOR 연산은 A, B값이 같으면 0, 다르면 1이 된다.</li>
</ul>
<h4 id="and-연산"><a class="header" href="#and-연산">AND(&amp;) 연산</a></h4>
<ul>
<li>두 값을 비트 단위로 AND 연산을 수행하며, 연산하는 A 비트의 값이 0이면 B 비트의 값에 상관없이 0이 된다.</li>
<li>A 비트의 값이 1이면 B 비트의 값에 따라 0 또는 1이 되기 때문에, 두 비트가 모두 1일 때만 1이 된다.</li>
</ul>
<pre><code class="language-text">  0000 1111 (0x0F)
&amp; 0011 1100 (0x3C)
-------------------
  0000 1100 (0x0C)
</code></pre>
<h4 id="or-연산"><a class="header" href="#or-연산">OR(|) 연산</a></h4>
<ul>
<li>두 값을 비트 단위로 OR 연산을 수행하며, 연산하는 A 비트의 값이 1이면 B 비트의 값에 상관없이 1이 된다.</li>
<li>반대로 A 비트의 값이 0이면 B 비트의 값에 따라 0 또는 1이 되기 때문에, 두 비트 중 하나라도 1이면 1이 된다.</li>
</ul>
<pre><code class="language-text">  0000 1111 (0x0F)
| 0011 1100 (0x3C)
-------------------
  0011 1111 (0x3F)
</code></pre>
<h4 id="xor-연산"><a class="header" href="#xor-연산">XOR(^) 연산</a></h4>
<ul>
<li>두 값을 비트 단위로 XOR 연산을 수행하며, 연산하는 두 비트이 값이 같으면 0이 되고 다르면 1이 된다.</li>
<li>즉 두 비트가 서로 다른 값일 때 1이 된다.</li>
</ul>
<pre><code class="language-text">  0000 1111 (0x0F)
^ 0011 1100 (0x3C)
-------------------
  0011 0011 (0x33)
</code></pre>
<h4 id="not-연산"><a class="header" href="#not-연산">NOT(~) 연산</a></h4>
<ul>
<li>각 비트의 값을 반전시키는 작업을 수행한다.</li>
<li>따라서 비트가 0이면 1이 되고 1이면 0이 된다.</li>
</ul>
<pre><code class="language-text">~ 0000 1111 (0x0F)
-------------------
  1111 0000 (0xF0)
</code></pre>
<h4 id="비트-연산자-단축-표현"><a class="header" href="#비트-연산자-단축-표현">비트 연산자 단축 표현</a></h4>
<ul>
<li>연산자를 단축해서 사용하는 것은 단순히 표현만 단축하는 것이기 때문에 결과에 차이점은 없다.</li>
<li>하지만 단축 표현에 사용된 연산자들은 연산자 우선순위가 낮기 때문에 다른 연산자와 연산할 때 연산자 우선순위에 주의해야 한다.</li>
<li><code>A = A &amp; B;</code> : 단축 표현 <code>A &amp;= B;</code></li>
<li><code>A = A | B;</code> : 단축 표현 <code>A |= B;</code></li>
<li><code>A = A ^ B;</code> : 단축 표현 <code>A ^= B;</code></li>
</ul>
<h3 id="비트-단위로-데이터를-다루는-방법"><a class="header" href="#비트-단위로-데이터를-다루는-방법">비트 단위로 데이터를 다루는 방법</a></h3>
<ul>
<li>비트 연산자가 비트 단위의 연산을 제공하지만 한 개의 비트만 연산하는 것이 아니다.</li>
<li>비트 단위라고 해도 최소 1바이트(8비트) 단위로 연산이 이루어지기 때문에, 비트 연산자를 사용하면 자신이 변경하려는 비트를 포함하는 바이트는 모두 연산이 이루어진다.</li>
<li>하지만 프로그램을 만들다 보면 바이트 단위가 아닌 비트 단위로 데이터를 다뤄야 할 때도 있다.</li>
<li>만약 지정한 비트에만 0 또는 1을 설정하고 싶거나, 특정 비트가 가지고 있는 값을 가져오고 싶다면 그 기능은 비트 연산자의 연산 특징을 잘 응용하여 프로그래머가 직접 구현해서 사용해야 한다.</li>
</ul>
<h3 id="지정한-비트를-0으로-설정하기"><a class="header" href="#지정한-비트를-0으로-설정하기">지정한 비트를 0으로 설정하기</a></h3>
<ul>
<li>변수의 비트 패턴에서 지정한 비트만 0으로 설정하고 다른 비트는 자신의 값을 유지하려면 비트 AND 연산자 <code>&amp;</code>를 사용한다.</li>
</ul>
<h4 id="1단계-2번-비트를-0으로-설정하기"><a class="header" href="#1단계-2번-비트를-0으로-설정하기">1단계: 2번 비트를 0으로 설정하기</a></h4>
<ul>
<li>비트 AND 연산자는 연산하는 한쪽 비트가 0이면 다른 쪽 비트 값에 상관없이 결과 값이 0이 나오는 특징을 가지고 있다.</li>
<li>즉 기존 값을 유지해야 하는 비트는 1과 AND 연산하고, 0으로 설정해야 하는 비트는 0과 AND 연산을 하는 것이다.</li>
</ul>
<p><img src="./images/bit_data_1.png" alt="지정한 비트를 0으로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;        // lamp_state에 어떤 값이 있는지 알 수 없음
lamp_state = lamp_state &amp; 0xFB;  // lamp_state의 2번 비트만 0으로 변경함
</code></pre>
<h4 id="2단계-임의의-비트를-0으로-설정하기"><a class="header" href="#2단계-임의의-비트를-0으로-설정하기">2단계: 임의의 비트를 0으로 설정하기</a></h4>
<ul>
<li>2번 비트를 0으로 설정할 때 사용하는 <code>&amp; 0xFB</code>를 직접 명시하지 않고 2번이라는 정보만 가지고 만들어 보자.</li>
</ul>
<p><img src="./images/bit_data_2.png" alt="임의의 비트를 0으로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;                 // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_num = 2;                // 0으로 만들 비트의 번호
unsigned char mask = ~(0x01 &lt;&lt; bit_num);  // 0xFB
lamp_state = lamp_state &amp; mask;           // lamp_state의 2번 비트만 0으로 변경함
</code></pre>
<ul>
<li>이렇게 하면 <code>bit_num</code>변수에 비트 번호만 적어 주면 해당 비트를 0으로 만들 수 있다.</li>
</ul>
<h4 id="3단계-함수로-만들어-보기"><a class="header" href="#3단계-함수로-만들어-보기">3단계: 함수로 만들어 보기</a></h4>
<ul>
<li>변수의 특정 비트를 0으로 만드는 예제</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char ResetBit(unsigned char dest_data, unsigned char bit_num) {
    // 1바이트 변수라서 비트 이동은 0~7까지 가능함
    if (bit_num &lt; 8) dest_data = dest_data &amp; ~(0x01 &lt;&lt; bit_num);
    // 변경된 값을 반환함
    return dest_data;
}

void main() {
    unsigned char lamp_state = 0x7F;  // 16진수 0x7F는 2진수 0111 1111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 전 값을 출력함
    // lamp_state 변수의 3번 비트를 0으로 설정함
    lamp_state = ResetBit(lamp_state, 3);  // 16진수 0x77은 2진수 0111 0111
    printf(&quot;%X\n&quot;, lamp_state);  // 변경 후 값을 출력함
}
</code></pre>
<pre><code class="language-text">7F -&gt; 77
</code></pre>
<ul>
<li><code>ResetBit</code>함수는 <code>dest_data</code>변수의 <code>bit_num</code>번 비트를 0으로 설정하는 함수로 해당 비트가 0으로 설정된 값을 반환한다. </li>
</ul>
<h3 id="지정한-비트를-1로-설정하기"><a class="header" href="#지정한-비트를-1로-설정하기">지정한 비트를 1로 설정하기</a></h3>
<ul>
<li>변수의 비트 패턴에서 지정한 비트만 1로 설정하고 다른 비트는 자신의 값을 유지하려면 비트 OR 연산자를 사용하면 된다.</li>
</ul>
<h4 id="1단계-2번-비트를-1로-설정하기"><a class="header" href="#1단계-2번-비트를-1로-설정하기">1단계: 2번 비트를 1로 설정하기</a></h4>
<ul>
<li>비트 OR 연산자는 연산하는 한쪽 비트가 1이면 다른 쪽 비트 값에 상관없이 결과 값이 1이 나오는 특징을 가지고 있다.</li>
<li>즉 기존 값을 유지해야 하는 비트는 0을 넣고 1로 설정해야 하는 비트에는 1을 넣어서 숫자를 만든 후 연산하려는 값과 이 값을 OR 연산하면 된다.</li>
</ul>
<p><img src="./images/shift_operator_3.png" alt="2번 비트를 1로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
lamp_state = lamp_state | 0x04;  // lamp_state의 2번 비트만 1로 변경함
</code></pre>
<h4 id="2단계-임의의-비트를-1로-설정하기"><a class="header" href="#2단계-임의의-비트를-1로-설정하기">2단계: 임의의 비트를 1로 설정하기</a></h4>
<ul>
<li>2번 비트를 1로 설정할 때 사용하는 <code>| 0x04</code>를 직접 명시하지 않고 2번 비트라는 정보만 가지고 만들어 보자.</li>
</ul>
<p><img src="./images/shift_operator_4.png" alt="임의의 비트를 1로 설정하기" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_num = 2;  // 1로 만들 비트의 번호
unsigned char mask = 0x01 &lt;&lt; bit_num;  // 0x04
lamp_state = lamp_state | mask;  // lamp_state의 2번 비트만 1로 변경함
</code></pre>
<ul>
<li>이렇게 하면 <code>bit_num</code>변수에 비트 번호만 적어 주면 해당 비트를 1로 만들 수 있다.</li>
</ul>
<h4 id="3단계-함수로-만들어-보기-1"><a class="header" href="#3단계-함수로-만들어-보기-1">3단계: 함수로 만들어 보기</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char SetBit(unsigned char dest_data, unsigned char bit_num) {
    // 1바이트 변수라서 비트 이동은 0~7까지 가능함
    if (bit_num &lt; 8) dest_data = dest_data | (0x01 &lt;&lt; bit_num);
    // 변경된 값을 반환함
    return dest_data;
}

void main() {
    unsigned char lamp_state = 0x77;  // 0x77은 2진수로 0111 0111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 전 값을 출력함
    // lamp_state 변수의 3번 비트를 1로 설정함
    lamp_state = SetBit(lamp_state, 3);
    // 변경 후 값을 출력함
    printf(&quot;%X\n&quot;, lamp_state);
}
</code></pre>
<pre><code class="language-text">77 -&gt; 7F
</code></pre>
<ul>
<li><code>SetBit</code>함수는 <code>dest_data</code>변수의 <code>bit_num</code>번 비트를 1로 설정하는 함수로 해당 비트가 1로 설정된 값을 반환한다.</li>
</ul>
<h3 id="특정-비트의-값-얻기"><a class="header" href="#특정-비트의-값-얻기">특정 비트의 값 얻기</a></h3>
<ul>
<li>변수의 비트 패턴에서 특정 비트의 값을 얻고 싶다면 비트 AND 연산자를 사용한다.</li>
</ul>
<h4 id="1단계-2번-비트-값-얻기"><a class="header" href="#1단계-2번-비트-값-얻기">1단계: 2번 비트 값 얻기</a></h4>
<ul>
<li>비트 AND 연산자는 연산하는 한쪽 비트가 1일 때 다른 쪽 비트 값이 1이면 1이 나오고 0이면 0이 나온다.</li>
<li>따라서 얻고 싶은 비트 값만 1로 넣고 나머지 비트는 모두 0을 넣어서 숫자를 만들고 AND 연산을 하면 된다.</li>
<li>이렇게 하면 자신이 지정한 비트만 값이 유지되고 나머지 비트는 모두 0이 된다.</li>
</ul>
<p><img src="./images/shift_operator_5.png" alt="2번 비트 값 얻기" /></p>
<ul>
<li>하지만 이렇게 하면 자신이 얻고자 하는 비트가 0번 비트인 경우에만 0, 1로 값이 나오고 다른 비트이면 그 비트의 2의 제곱만큼 큰 값으로 나온다.</li>
<li>따라서 이 값을 0 또는 1로 얻고 싶다면 ? 값을 0번 비트로 이동시켜야 한다.</li>
</ul>
<p><img src="./images/shift_operator_6.png" alt="값을 0번 비트로 이동" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_state;  // 2번 비트의 값을 저장할 변수
bit_state = lamp_state &amp; 0x04;  // lamp_state의 2번 비트만 값을 유지한 상태로 bit_state에 저장함.
                                // lamp_state는 변경되지 않음
bit_state = bit_state &gt;&gt; 2;  // bit_state의 값을 0 또는 1로 확인 가능
</code></pre>
<ul>
<li>비트에 값을 0 또는 1로 설정할 때와 달리 <code>bit_state</code>변수를 추가로 선언해서 사용한 이유는 <code>lamp_state</code>에 직접 연산을 해 버리면 자신의 상태 값을 잃어버리기 때문이다.</li>
</ul>
<h4 id="2단계-임의의-비트-값-얻기"><a class="header" href="#2단계-임의의-비트-값-얻기">2단계: 임의의 비트 값 얻기</a></h4>
<ul>
<li>2번 비트를 확인할 때 사용하는 <code>&amp; 0x04</code>와 <code>&gt;&gt; 2</code>를 직접 명시하지 않고 2번이라는 정보만 가지고 만들어 보자.</li>
</ul>
<p><img src="./images/shift_operator_7.png" alt="임의의 비트 값 얻기" /></p>
<pre><code class="language-c">unsigned char lamp_state;  // lamp_state에 어떤 값이 있는지 알 수 없음
unsigned char bit_num = 2;  // 1로 만들 비트의 번호
unsigned char bit_state;  // 비트의 값을 저장할 변수
unsigned char mask = 0x01 &lt;&lt; bit_num;  // 비트 옮긴 후 값은 0x04
bit_state = lamp_state &amp; mask;  // lamp_state의 2번 비트만 값을 유지한 상태로 bit_state에 저장함
                                // lamp_state는 변경되지 않음
bit_state = bit_state &gt;&gt; bit_num;  // bit_state의 값을 0 또는 1로 확인 가능
</code></pre>
<ul>
<li>이렇게 하면 <code>bit_num</code>변수에 비트 번호만 적어 주면 해당 비트의 값이 <code>bit_state</code>에 저장된다.</li>
</ul>
<h4 id="3단계-함수-만들어-보기"><a class="header" href="#3단계-함수-만들어-보기">3단계: 함수 만들어 보기</a></h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char GetBit(unsigned char dest_data, unsigned char bit_num) {
    unsigned char bit_state = 0;

    // 1바이트 변수라서 비트 이동은 0~7까지만 가능함
    if (bit_num &lt; 8) {
        bit_state = dest_data &amp; (0x01 &lt;&lt; bit_num);
        bit_state = bit_state &gt;&gt; bit_num;
    }

    // bit_num에 지정한 비트 값을 반환함
    return bit_state;
}

void main() {
    unsigned char lamp_state = 0x75;  // 16진수 0x75는 2진수로 0111 0101
    unsigned char bit_state;
    int i;

    printf(&quot;%X -&gt; &quot;, lamp_state);  // 16진법으로 현재 값을 출력함
    // 8개의 비트 값을 모두 출력하기 위해 8번 반복함
    for (i = 0; i &lt; 8; i++) {
        // 비트를 표시할 때 최상위 비트(7번 비트)부터 순차적으로 보여주기 위해서 7, 6, 5, ... 순으로
        // 비트 값을 얻는다.
        bit_state = GetBit(lamp_state, 7 - i);
        // 비트 값을 출력함
        printf(&quot;%d&quot;, bit_state);
    }

    // 비트 값이 모두 출력되면 줄 바꿈을 함
    printf(&quot;\n&quot;);
}
</code></pre>
<pre><code class="language-text">75 -&gt; 01110101
</code></pre>
<ul>
<li><code>GetBit</code>함수는 <code>dest_data</code>변수의 <code>bit_num</code>번 비트 값을 반환하는 함수이다.</li>
<li>이렇게 기능을 구현하면 직접 특정 비트의 값을 읽거나 저장하는 연산자가 없더라도 비트 단위로 정보를 처리할 수 있다.</li>
</ul>
<blockquote>
<h4 id="setbit-함수와-resetbit-함수가-비슷해-보이는가"><a class="header" href="#setbit-함수와-resetbit-함수가-비슷해-보이는가">SetBit 함수와 ResetBit 함수가 비슷해 보이는가?</a></h4>
<ul>
<li>위의 예제에서 사용한 <code>SetBit</code>함수와 <code>ResetBit</code>함수는 기능이 유사한 함수이고 함께 사용할 확률이 높아서 다음과 같이 하나의 함수로 합쳐도 된다.</li>
<li>변수의 특정 비트를 0 또는 1로 변경하는 예제</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned char ModifyBit(unsigned char dest_data, unsigned char bit_num, char value) {
    unsigned char mask;

    // 1바이트 변수라서 비트 이동은 0~7까지만 가능
    if (bit_num &lt; 8) {
        // bit_num번 비트에 값을 설정하는 데 사용할 숫자를 구성함
        mask = 0x01 &lt;&lt; bit_num;

        if (1 == value) dest_data = dest_data | mask;  // 1로 설정하는 경우
        else dest_data = dest_data &amp; ~mask;  // 0으로 설정하는 경우
    }

    // 변경된 값을 반환함
    return dest_data;
}

void main() {
    unsigned char lamp_state = 0x7F;  // 16진수 0x7F는 2진수 0111 1111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 전 값을 출력함

    // lamp_state 변수의 3번 비트를 0으로 설정함
    lamp_state = ModifyBit(lamp_state, 3, 0);  // 16진수 0x77은 2진수 0111 0111
    printf(&quot;%X -&gt; &quot;, lamp_state);  // 변경 후 값을 출력함
   
    // lamp_state 변수의 3번 비트를 1로 설정함
    lamp_state = ModifyBit(lamp_state, 3, 1);  // 16진수 0x7F는 2진수 0111 1111
    printf(&quot;%X\n&quot;, lamp_state);  // 변경 후 값을 출력함
}
</code></pre>
<pre><code class="language-text">7F -&gt; 77 -&gt; 7F
</code></pre>
</blockquote>
<h3 id="비트-연산자를-활용하는-방법"><a class="header" href="#비트-연산자를-활용하는-방법">비트 연산자를 활용하는 방법</a></h3>
<h4 id="보수를-이용해-덧셈으로-뺄셈-구현하기"><a class="header" href="#보수를-이용해-덧셈으로-뺄셈-구현하기">보수를 이용해 덧셈으로 뺄셈 구현하기</a></h4>
<ul>
<li>부호를 고려하지 않는 1바이트(8비트, unsigned char) 메모리는 정수 값을 저장할 때 0~255의 값만 저장할 수 있다.</li>
<li>이런 1바이트 메모리는 255보다 더 큰 값이 들어오면 오버플로가 발생하고 그만큼의 값을 잃어버리게 된다.</li>
</ul>
<pre><code class="language-c">unsigned char data = 255;  // 255는 부호 없는 1바이트 변수가 가질 수 있는 최대값
data++;  // 255 + 1 = 256이 되어야 하지만 오버플로가 발생하여 0이 되어 버림
data++;  // 0이 되었으므로 이 단계에서는 1이 됨
</code></pre>
<p><img src="./images/bit_operator_1.png" alt="오버플로" /></p>
<ul>
<li>이러한 메모리 특성 때문에 <code>data</code>변수에 들어 있는 값을 0으로 만들 수 있는 방법이 두 가지 있다.</li>
<li>예를 들어 <code>data</code>변수 값이 255라면 255를 빼서 0을 만들 수도 있고 1을 더해서도 0으로 만들 수도 있다.</li>
<li>즉 덧셈으로 뺄셈을 구현할 수 있다는 뜻이다.</li>
<li><code>data</code>값이 198인 경우에 198을 빼거나 58을 더하면 된다.</li>
<li>결국 <code>data</code>변수에 들어있는 값을 0으로 만들기 위해 255나 198에 대응하는 1이나 58을 찾는 방법은 이 숫자들을 2진수로 바꿔 보면 이해할 수 있다.</li>
</ul>
<p><img src="./images/bit_operator_2.png" alt="255를 0으로 만드는 숫자를 찾는 방법" /></p>
<p><img src="./images/bit_operator_3.png" alt="198을 0으로 되도록 만드는 숫자를 찾는 방법" /></p>
<ul>
<li>뺄셈에 사용할 숫자를 비트 NOT(~) 연산자를 사용하여 비트를 반전시키고 그 값에 1을 더하면 대응하는 숫자를 구할 수 있다.</li>
<li>위와 같은 상황에서 비트를 반전시켜 얻은 값을 '1의 보수'라고 하고, 1의 보수에 1을 더해서 얻은 값을 '2의 보수'라고 한다.</li>
<li>결과적으로 B에 대한 2의 보수를 구해서 덧셈을 하면 B를 뺀 것과 같은 결과가 나온다.</li>
<li>이렇게 덧셈으로 뺄셈을 대신할 수 있다는 것은 하드웨어 입장에서 볼 때 뺄셈 회로를 하나 줄일 수도 있다는 뜻이다.</li>
<li>따라서 컴퓨터에서 뺄셈 회로가 없다고 이야기하는 것이 바로 이 개념 때문이다.</li>
</ul>
<h4 id="데이터-암호화하기"><a class="header" href="#데이터-암호화하기">데이터 암호화하기</a></h4>
<ul>
<li>비트 연산자에는 XOR(^)연산자가 있다.</li>
<li>이 연산자는 연산되는 비트 값이 서로 같으면 0이고 다르면 1이 되는 특성을 가지고 있다.</li>
<li>다음 그림처럼 0x56이 있는데 이 값과 0x37을 XOR 연산하면 0x61이라는 전혀 새로운 값이 나온다.</li>
<li>그런데 0x61과 0x37을 다시 XOR 연산하면 처음 값인 0x56이 나온다.</li>
</ul>
<p><img src="./images/data_cryto.png" alt="데이터 암호화하기" /></p>
<ul>
<li>XOR 연산자는 이런 연산 특징 때문에 간단한 암호화 데이터를 만들 때 많이 사용된다.</li>
<li>위와 같이 암호화하는 것을 '8비트 암호화'라고 한다.</li>
<li>보안성을 더 높이고 싶다면 암호에 사용하는 비트 개수를 더 늘리면 된다.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_09.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter_11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_09.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter_11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
