<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>다차원 포인터 - Study: Do it C 언어 입문</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="&lt;Do it C 언어 입문&gt; 책을 공부하면서 기록한 정리 글입니다.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 기본 문법</li><li class="chapter-item expanded "><a href="chapter_01.html"><strong aria-hidden="true">1.</strong> 프로그램과 C 언어</a></li><li class="chapter-item expanded "><a href="chapter_02.html"><strong aria-hidden="true">2.</strong> C언어로 만드는 첫 번째 프로그램</a></li><li class="chapter-item expanded "><a href="chapter_03.html"><strong aria-hidden="true">3.</strong> 자료형</a></li><li class="chapter-item expanded "><a href="chapter_04.html"><strong aria-hidden="true">4.</strong> 상수와 변수</a></li><li class="chapter-item expanded "><a href="chapter_05.html"><strong aria-hidden="true">5.</strong> 함수</a></li><li class="chapter-item expanded "><a href="chapter_06.html"><strong aria-hidden="true">6.</strong> 표준 출력 함수</a></li><li class="chapter-item expanded "><a href="chapter_07.html"><strong aria-hidden="true">7.</strong> 연산자</a></li><li class="chapter-item expanded "><a href="chapter_08.html"><strong aria-hidden="true">8.</strong> 조건문</a></li><li class="chapter-item expanded "><a href="chapter_09.html"><strong aria-hidden="true">9.</strong> 반복문</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 시프트 연산자와 비트 연산자</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 지역 변수와 전역 변수</a></li><li class="chapter-item expanded affix "><li class="part-title">C 언어 완성하기</li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 배열과 문자열</a></li><li class="chapter-item expanded "><a href="chapter_13.html"><strong aria-hidden="true">13.</strong> 포인터</a></li><li class="chapter-item expanded "><a href="chapter_14.html"><strong aria-hidden="true">14.</strong> 표준 입력 함수</a></li><li class="chapter-item expanded "><a href="chapter_15.html"><strong aria-hidden="true">15.</strong> 배열과 포인터</a></li><li class="chapter-item expanded "><a href="chapter_16.html"><strong aria-hidden="true">16.</strong> 메모리 할당</a></li><li class="chapter-item expanded "><a href="chapter_17.html" class="active"><strong aria-hidden="true">17.</strong> 다차원 포인터</a></li><li class="chapter-item expanded "><a href="chapter_18.html"><strong aria-hidden="true">18.</strong> 구조체와 연결 리스트</a></li><li class="chapter-item expanded "><a href="chapter_19.html"><strong aria-hidden="true">19.</strong> 파일 입출력</a></li><li class="chapter-item expanded "><a href="chapter_20.html"><strong aria-hidden="true">20.</strong> 함수 포인터</a></li><li class="chapter-item expanded affix "><li class="part-title">Tip</li><li class="chapter-item expanded "><a href="tip_1.html"><strong aria-hidden="true">21.</strong> 주니어 프로그래머 딱지 떼는 5가지 팁!</a></li><li class="chapter-item expanded "><a href="tip_2.html"><strong aria-hidden="true">22.</strong> 주니어 프로그래머 딱지 떼는 7가지 팁!</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Study: Do it C 언어 입문</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/do_it_c" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="17-다차원-포인터"><a class="header" href="#17-다차원-포인터">17. 다차원 포인터</a></h1>
<ul>
<li>포인터는 일반 변수를 가리킬 수도 있지만 또 다른 포인터를 가리킬 수도 있다.</li>
<li>이렇게 포인터가 포인터를 가리키는 것을 '다차원 포인터'라고 부른다.</li>
<li>다차원 포인터는 다차원 배열과 함께 자주 쓰인다.</li>
<li>C 언어로 프로그래밍할 때 어떤 경우에 다차원 포인터를 사용하고, 어떻게 문법을 구성하는지 알아보자.</li>
</ul>
<h2 id="17-1-다차원-포인터-개념"><a class="header" href="#17-1-다차원-포인터-개념">17-1. 다차원 포인터 개념</a></h2>
<h3 id="다차원-포인터란"><a class="header" href="#다차원-포인터란">다차원 포인터란?</a></h3>
<ul>
<li>'내'가 '길동이'라는 친구를 부를때 '친구야'라고 표현하는 상황을 상상해보자.</li>
<li>'길동아'라고 부르는 것은 직접 표현을 사용하는 것이고, '친구야'라고 부르는 것은 간접 표현을 사용하는 것이다.</li>
<li>이 경우 '내'가 '길동이'를 가리키는 포인터가 된 것이다.</li>
<li>'나의 친구의 친구'처럼 두 번 연속으로 간접 표현을 사용하는 것처럼 간접으로 여러번 가리키는 포인터를 '다차원 포인터'라고 부른다. </li>
</ul>
<pre><code class="language-c">short *p, data = 5;
p = &amp;data;  // 포인터 변수 p는 data 변수의 주소 값을 기억함
</code></pre>
<ul>
<li>차원은 '자신이 가리키는 대상'의 개수만큼 증가한다.</li>
<li>가리키는 대상이 없는 경우 즉, 대상 그 자체는 가리키는 대상이 없기 때문에 0차원이다.</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_1.png" alt="다차원 포인터란?" /></p>
<ul>
<li>위의 그림에서 메모리 상자의 앞면에 변수 이름과 차원을 표시했다.</li>
<li>그리고 상자 아래에 변수가 할당된 주소와 메모리의 크기(또는 자료형)을 표시했다.</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_2.png" alt="다차원 포인터란" /></p>
<h3 id="다차원-포인터-정의하기"><a class="header" href="#다차원-포인터-정의하기">다차원 포인터 정의하기</a></h3>
<ul>
<li>앞에서 배운 차원 개념과 포인터 문법을 연결해 보자.</li>
<li>포인터 변수를 선언할 때 <code>*</code>키워드를 한 개만 사용한 포인터를 1차원 포인터라고 이야기하며 <code>*</code>키워드를 하나씩 더 사용할 때마다 차원이 하나씩 증가한다.</li>
<li>그리고 <code>*</code>키워드를 두 개 이상 사용해서 선언한 포인터를 '다차원 포인터'라고 한다.</li>
<li>포인터 변수를 선언할 때 사용하는 <code>*</code>키워드는 최대 7개(컴파일러마다 다름)까지 사용할 수 있다.</li>
<li>그리고 포인터 변수를 선언할 때 사용한 <code>*</code>키워드의 개수만큼 포인터를 사용할 때 <code>*</code>연산자를 사용할 수 있다.</li>
<li>예를 들어 <code>char *p;</code>라고 선언하면 포인터 변수 자체를 의미하는 <code>p</code>또는 포인터 변수가 가리키는 곳에 값을 저장하기 위한 <code>*p</code>, 이렇게 두 가지 표현을 사용할 수 있다.</li>
<li>따라서 <code>char ***p3;</code>라고 <code>*</code>키워드를 3개 사용해서 선언하면 <code>p3</code>, <code>*p3</code>, <code>**p3</code> 또는 <code>***p3</code>라는 네 가지 표현을 사용할 수 있다.</li>
</ul>
<pre><code class="language-c">char *p1;    // 1차원 포인터: p1, *p1
char **p2;   // 2차원 포인터: p2, *p2, **p2
char ***p3;  // 3차원 포인터: p3, *p3, **p3, ***p3
</code></pre>
<h3 id="일반-변수의-한계와-다차원-포인터"><a class="header" href="#일반-변수의-한계와-다차원-포인터">일반 변수의 한계와 다차원 포인터</a></h3>
<ul>
<li>주소 값을 저장할 수 있는 크기(4바이트)의 변수라면 포인터 변수가 아니더라도 주소를 저장할 수는 있다.</li>
<li>따라서 다음과 같이 4바이트 크기의 자료형인 <code>int</code>형으로 <code>my_ptr</code>변수를 선언하고 <code>&amp;</code>연산자를 사용하여 <code>data</code>변수의 주소 값을 <code>my_ptr</code>변수에 저장할 수 있다.</li>
</ul>
<pre><code class="language-c">short data = 0;
int my_ptr = (int) &amp;data;  // &amp;data는 short *형식의 값을 가지기 때문에
                           // int형 변수인 my_ptr에 저장하기 위해서 (int)로 형 변환한다
                           // my_ptr는 4바이트 크기라서 정상적으로 주소를 저장한다
*my_ptr = 3;  // 오류 발생: my_ptr는 포인터가 아니라서 *연산자를 사용할 수 없음
</code></pre>
<p><img src="./images/multi_dimensional_pointer_3.png" alt="일반 변수의 한계와 다차원 포인터" /></p>
<ul>
<li>하지만 <code>my_ptr</code>변수는 포인터 변수가 아니기 때문에 <code>*</code>(번지 지정)연산자를 사용할 수 없다.</li>
<li>이것은 <code>my_ptr</code>변수에 저장된 주소로 이동하여 값을 대입하거나 읽을 수 없다는 뜻이다.</li>
<li>그래서 일반 변수에 주소 값을 저장하지 않고 <code>*</code>연산자를 사용해서 포인터 변수에 주소 값을 저장하는 것이다.</li>
<li>포인터 변수는 자신이 저장하고 있는 주소에 가서 값을 읽거나 쓸 수 있는 기능을 가지고 있기 때문이다.</li>
<li>정리하자면 일반 변수에도 주소 값을 저장할 수는 있지만, 자신이 저장하고 있는 주소에 가서 값을 읽거나 쓸 수 없기 때문에 의미가 없다.</li>
<li>이 개념을 잘 이해해야 이후에 배울 다차원 포인터 문법을 쉽게 이해할 수 있다.</li>
</ul>
<h2 id="17-2-2차원-포인터"><a class="header" href="#17-2-2차원-포인터">17-2. 2차원 포인터</a></h2>
<h3 id="2차원-포인터의-선언과-사용"><a class="header" href="#2차원-포인터의-선언과-사용">2차원 포인터의 선언과 사용</a></h3>
<ul>
<li>다차원 포인터 중 가장 자주 사용하는 것은 2차원 포인터이다.</li>
<li>2차원 포인터를 사용하면 2차원 배열을 다루는 게 훨씬 쉬워진다.</li>
<li>3차원 포인터부터는 2차원 포인터에서 단계가 하나씩 추가될 뿐 원리는 같다.</li>
<li>2차원 포인터는 다음과 같이 <code>*</code>키워드를 두 개 사용해서 선언한다.</li>
</ul>
<pre><code class="language-c">short **pp;
</code></pre>
<ul>
<li>그래서 포인터를 사용할 때 <code>pp</code>, <code>*pp</code> 또는 <code>**pp</code>처럼 <code>*</code>연산자를 최대 2개까지 사용할 수 있다.</li>
<li>다음 그림처럼 2차원 포인터 변수는 <code>*pp</code>를 사용하면 변수 <code>pp</code>에 저장되어 있는 106번지로 이동해서 값을 읽거나 저장할 수 있다.</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_4.png" alt="2차원 포인터" /></p>
<ul>
<li>그리고 <code>**pp</code>를 사용하면 포인터 변수 <code>pp</code>가 가리키는 대상(106번지)에 저장된 주소 값(110번지)을 대상으로 사용한다.</li>
<li>그래서 110번지에 있는 값을 읽거나 저장할 수 있다.</li>
</ul>
<h3 id="2차원-포인터의-구성"><a class="header" href="#2차원-포인터의-구성">2차원 포인터의 구성</a></h3>
<ul>
<li>앞의 그림을 보면 <code>**pp</code>라고 사용하면 두 번째 상자에 들어 있는 110을 주소로 사용해서 세 번째 상자를 가리킨다.</li>
<li>그런데 만약 다음과 같이 두 번째 상자에 주소가 아닌 다른 의미의 값(3)이 저장되어 있다면 프로그램이 엉뚱한 메모리를 사용해서 오류가 발생한다.</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_5.png" alt="2차원 포인터의 구성" /></p>
<ul>
<li>즉 두 번째 상자에 저장되어 있는 <code>3</code>은 <code>data</code>변수에 저장된 일반 숫자 값인데 이 값을 주소로 사용해서 3번지로 이동하여 값을 읽거나 저장하려고 하면 오류가 발생한다는 것이다.</li>
</ul>
<pre><code class="language-c">short **pp;
int data = 3;  // &amp;data로 얻은 주소의 자료형이 int *이기 때문에
               // 포인터 변수 pp와 자료형을 맞추기 위해서 short **로 형 변환한다
pp = (short **) &amp;data;
</code></pre>
<ul>
<li>이처럼 2차원 포인터는 세 번째 상자로 한 번 더 이동할 수 있기 때문에 두 번째 상자에 최종 대상(세 번째 상자)의 주소 값이 저장되어야 한다.</li>
<li>따라서 두 번째 상자는 다음과 같이 1차원 포인터 변수가 되어야 안정적인 구조가 된다.</li>
</ul>
<pre><code class="language-c">short **pp, *p, data = 3;
p = &amp;data;  // data 변수의 주소 값이 포인터 변수 p에 저장됨
pp = &amp;p;    // 1차원 포인터 변수 p의 주소 값이 2차원 포인터 변수 pp에 저장됨
**pp = 5;   // data 변수의 값이 3에서 5로 변경됨
</code></pre>
<p><img src="./images/multi_dimensional_pointer_6.png" alt="2차원 포인터 구성" /></p>
<ul>
<li>위의 그림처럼 주소를 저장하려면 두 번째 상자와 세 번째 상자를 1차원 포인터 구조로 만드는 것이 좋다.</li>
<li>그리고 위와 같은 구조가 되면 <code>data</code>변수는 <code>**pp</code>로도 값을 변경할 수 있고 1차원 포인터 변수 <code>p</code>를 사용하여 <code>*p</code>로도 값을 변경할 수 있다.</li>
<li>결론적으로 다차원 포인터 구조는 오른쪽으로 하나씩 이동할 때마다 차원을 하나씩 줄여 주는 것이 좋은 구조이다.</li>
<li>위와 같은 구조를 유지하면 강제적인 형 변환을 할 필요도 없고 자연스럽게 코드를 구성할 수 있다.</li>
<li>2차원 포인터를 이용하여 일반 변수의 값을 수정하는 예제를 작성해보자.</li>
</ul>
<pre><code class="language-c">/* 2차원 포인터를 사용하여 일반 변수의 값 대입하기 */

#include &lt;stdio.h&gt;

void main() {
    short data = 3;
    short *p = &amp;data;  // data 변수의 주소 값을 1차원 포인터 p에 저장함
    short **pp = &amp;p;  // 1차원 포인터 p변수의 주소 값을 2차원 포인터 pp에 저장함

    printf(&quot;[Before  ] data : %d\n&quot;, data);  // 3을 출력함
    *p = 4;  // 1차원 포인터 p를 사용하여 data 변수 값을 4로 수정함
    printf(&quot;[Use *p  ] data : %d\n&quot;, data);
    **pp = 5;  // 2차원 포인터 pp를 사용하여 data 변수 값을 5로 수정함
    printf(&quot;[Use **pp] data : %d\n&quot;, data);
}
</code></pre>
<pre><code class="language-text">[Before  ] data : 3
[Use *p  ] data : 4
[Use **pp] data : 5
</code></pre>
<h3 id="1차원-포인터-변수에-1차원-포인터-변수의-주소를-저장하면"><a class="header" href="#1차원-포인터-변수에-1차원-포인터-변수의-주소를-저장하면">1차원 포인터 변수에 1차원 포인터 변수의 주소를 저장하면?</a></h3>
<ul>
<li>앞에서 2차원 포인터를 사용해 1차원 포인터의 주소 값을 저장하는 구조가 좋다고 했다.</li>
<li>그러면 1차원 포인터를 사용해서 1차원 포인터의 주소 갑을 저장하는 구조는 어떨까?</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_7.png" alt="1차원 포인터를 사용해서 1차원 포인터의 주소 값을 저장하는 구조" /></p>
<ul>
<li>위 그림처럼 1차원 포인터 변수 <code>q</code>를 사용하여 1차원 포인터 변수 <code>p</code>의 주소 값을 저장할 수는 있다.</li>
<li>하지만 1차원 포인터 변수 <code>q</code>는 <code>*</code>연산자를 한 개만 사용할 수 있기 때문에 포인터 변수 <code>p</code>까지만 이동할 수 있고 <code>data</code>변수까지는 이동할 수 없다.</li>
<li>따라서 2차원 포인터를 사용하는 것과 구조는 비슷하지만 실용성은 떨어진다.</li>
</ul>
<pre><code class="language-c">int *q, *p, data = 3;
p = &amp;data;  // 포인터 변수 p는 data 변수의 주소 값을 기억함
q = (int *) &amp;p;  // 포인터 변수 q는 포인터 변수 p의 주소 값을 기억함
</code></pre>
<ul>
<li>또한 이렇게 사용하면 차원이 맞지 않는 문제가 발생한다.</li>
<li>일반 변수의 주소를 <code>&amp;</code>연산자를 사용하여 계산하면 1차원 형식의 포인터 값으로 반환된다.</li>
<li>1차원 포인터의 주소 값을 <code>&amp;</code>연산자를 사용해서 계산하면 차원이 하나 증가하여 2차원 형식의 포인터 값으로 반환된다.</li>
<li>따라서 차원을 맞추기 위해서 <code>(int *)</code>형식으로 형 변환을 해주어야 한다.</li>
</ul>
<h3 id="2차원-포인터가-가리키는-첫-대상이-일반-변수인-경우"><a class="header" href="#2차원-포인터가-가리키는-첫-대상이-일반-변수인-경우">2차원 포인터가 가리키는 첫 대상이 일반 변수인 경우</a></h3>
<ul>
<li>2차원 포인터가 가리키는 첫 대상이 일반 변수이면 주소 값이 아닌 일반 숫자 값을 저장하고 있을 확률이 높다.</li>
<li>일반 숫자 값을 주소로 사용하면 <code>**</code>연산자를 사용할 때 문제가 발생할 수도 있다.</li>
<li>그러므로 2차원 포인터가 가리키는 첫 대상은 1차원 포인터가 되는 게 일반적이다.</li>
<li>그러면 2차원 포인터의 첫 번째 대상으로 일반 변수를 사용하면서, 그 변수에 정상적인 주소 값을 저장해 사용하면 어떻게 될까?</li>
<li>다음과 같이 2차원 포인터 변수 <code>pp</code>가 일반 변수의 주소 값(106번지)을 저장하더라도, 그 일반 변수가 다른 변수의 주소 값(110번지)을 저장하고 있다면 구조적으로는 문제가 되지 않는다.</li>
<li>다만 차원이 하나씩 감소하는 일반적인 구조가 아니기 때문에 각 변수 간에 자료형이 맞지 않아서 형 변환을 많이 해주어야 한다.</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_8.png" alt="2차원 포인터가 가리키는 첫 대상이 일반 변수인 경우" /></p>
<ul>
<li>게다가 일반 변수 <code>my_ptr</code>는 <code>*</code>연산자를 사용할 수 없기 때문에 <code>data</code>변수의 주소 값을 저장하고 있더라도 이 주소로 이동할 수 없다.</li>
<li>하지만 2차원 포인터 변수인 <code>pp</code>는 <code>**pp</code>를 사용하여 두 번째 대상인 <code>data</code>변수를 가리킬 때 첫 번째 대상에 저장된 주소 값을 읽어서 <code>data</code>변수를 가리킬 수 있다.</li>
<li>즉 첫 번째 대상인 <code>my_ptr</code>가 어떤 형식의 변수이든 상관없이 4바이트 크기의 메모리이고 주소 값만 정상적으로 저장되어 있다면 그 주소 값을 사용하여 두 번째 대상을 가리킬 수 있다는 뜻이다.</li>
<li>따라서 2차원 포인터 변수인 <code>pp</code>는 <code>**pp = 5;</code>라고 사용했을 때 <code>my_ptr</code>변수가 1차원 포인터가 아니더라도 4바이트 크기의 메모리이고 정상적인 주소 값을 저장하고 있기 때문에 110번지로 한 번에 이동하여 값 5를 대입할 수 있다.</li>
</ul>
<pre><code class="language-c">short **pp, data = 3;
int my_ptr = (int) &amp;data;  // &amp;data는 short *형식의 값을 가지기 때문에
                           // int형 변수인 my_ptr에 저장하기 위해서 (int)로 형 변환한다
                           // my_ptr는 4바이트 크기라서 정상적으로 주소를 저장한다
pp = (short **) &amp;my_ptr;  // my_ptr의 주소 값이 2차원 포인터 변수 pp에 저장됨
                          // &amp;my_ptr로 얻는 주소 값의 자료형이 int *이기 때문에
                          // 포인터 변수 pp와 자료형을 맞추기 위해서
                          // short **로 형 변환을 한다
**pp = 5;  // data 변수의 값이 3에서 5로 변경됨
</code></pre>
<ul>
<li>결론적으로 첫 번째 상자가 2차원 포인터 변수이고 두 번째 상자는 어떤 형식의 변수가 오든지 4바이트 크기이기만 하면 무조건 세 번째 상자로 이동하여 값을 변경할 수 있다.</li>
</ul>
<h3 id="2차원-포인터가-가리키는-대상을-동적으로-할당하기"><a class="header" href="#2차원-포인터가-가리키는-대상을-동적으로-할당하기">2차원 포인터가 가리키는 대상을 동적으로 할당하기</a></h3>
<ul>
<li>1차원 포인터는 동적으로 할당한 메모리의 주소 값을 받아 사용할 수 있다.</li>
<li>따라서 2차원 포인터도 다음과 같이 두 번째 상자에 해당하는 4바이트 메모리를 <code>malloc</code>함수로 동적으로 할당해서 사용할 수 있다.</li>
<li>2차원 포인터는 자신이 가리키는 첫 대상이 어떤 종류의 변수인지 상관없이 4바이트 크기의 주소 값만 저장되어 있으면 최종 대상을 사용할 수 있기 때문이다.</li>
</ul>
<pre><code class="language-c">short **pp, data = 3;
pp = (short **) malloc(4);  // 두 번째 상자로 사용할 4바이트 메모리를 할당하고
                            // 그 주소 값을 2차원 포인터 pp에 저장한다
*pp = &amp;data;  // data 변수의 주소 값을 두 번째 상자(동적으로 할당된 메모리)에 저장함
**pp = 5;  // data 변수의 값이 3에서 5로 변경됨
</code></pre>
<p><img src="./images/multi_dimensional_pointer_9.png" alt="2차원 포인터가 가리키는 대상을 동적으로 할당하기" /></p>
<ul>
<li>결국 이 예시에서 동적으로 할당된 4바이트 메모리는 포인터가 아니라서 <code>*</code>(번지 지정)연산자를 사용할 수 없기 때문에 스스로는 아무것도 할 수 없다.</li>
<li>하지만 <code>**pp</code>라고 사용할 때 이 4바이트 메모리에 저장된 주소 값을 사용하여 세 번째 상자로 이동하기 때문에 이 4바이트 메모리는 간접적으로 1차원 포인터처럼 사용된다.</li>
<li>즉 2차원 포인터 기준으로 봤을 때 이 4바이트 메모리는 <code>short *</code>로 선언한 포인터처럼 사용되기 때문에 <code>malloc(4)</code>로 적는 것보다 다음과 같이 적는 것이 코드의 의미를 더 분명하게 전달할 수 있다.</li>
</ul>
<pre><code class="language-c">pp = (short **) malloc(sizeof(short *));  // short *는 포인터이기 때문에 크기가 4바이트임
</code></pre>
<ul>
<li>결국 이 형식은 <code>short *</code>형식의 포인터를 동적으로 할당하여 그 주소 값을 2차원 포인터 <code>pp</code>에 저장하는 형태이다.</li>
<li>그래서 위와 같이 적으면 1차원 포인터 한 개를 동적 할당한다고 이야기한다.</li>
<li>마지막으로 다음 예제는 두 번째 상자와 세 번째 상자까지 동적 메모리 할당을 사용하여 2차원 포인터 구조를 구성한 것이다.</li>
<li>이렇게 구성하면 스택 공간에는 포인터 변수 <code>pp</code>만 할당되고 <code>pp</code>에 할당 받은 동적 메모리(나머지 상자에 해당하는 메모리)는 힙에 할당된다.</li>
</ul>
<pre><code class="language-c">/* malloc 함수를 사용하여 2차원 포인터 구조 만들기 */

#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void main() {
    short **pp;
    pp = (short **) malloc(sizeof(short *));  // 4바이트를 할당함. 두 번째 상자 만듦
    *pp = (short *) malloc(sizeof(short));  // 2바이트를 할당함. 세 번째 상자 만듦

    **pp = 10;  // 2차원 포인터를 사용하여 세 번째 상자에 10을 대입함
    printf(&quot;**pp : %d\n&quot;, **pp);  // 10을 출력함
    free(*pp);  // 세 번째 상자에 해당하는 메모리 해제함
    free(pp);  // 두 번째 상자에 해당하는 메모리 해제함
}
</code></pre>
<pre><code class="language-text">**pp : 10
</code></pre>
<ul>
<li>이 예제에서 동적으로 할당한 메모리를 해제하는 순서가 정말 중요하다.</li>
<li>왜냐하면 두 번째 상자가 세 번째 상자의 주소 값을 가지고 있기 때문에 두 번째 상자를 먼저 해제하면 세 번째 상자의 주소 값을 잃어버리기 때문이다.</li>
<li>그러면 세 번째 상자에 해당하는 메모리를 해제하지 못하게 되므로, 반드시 세 번째 상자의 메모리를 먼저 해제하고 두 번째 상자의 메모리를 해제해야 한다.</li>
</ul>
<h4 id="2차원-포인터가-가리키는-대상을-동적으로-할당하면-좋은-점"><a class="header" href="#2차원-포인터가-가리키는-대상을-동적으로-할당하면-좋은-점">2차원 포인터가 가리키는 대상을 동적으로 할당하면 좋은 점</a></h4>
<ul>
<li>위의 예제에서는 2차원 포인터 개념을 설명하기 위해서 2차원 포인터가 가리키는 첫 번째 대상(두 번째 상자)을 4바이트(<code>short *</code>)로 동적 메모리 할당하고 두 번째 대상(세 번째 상자)을 2바이트(<code>short</code>)로 동적 메모리 할당했다.</li>
<li>즉 첫 번째 대상은 4바이트 1개이고 두 번째 대상은 2바이트 1개를 할당한 것이다.</li>
<li>하지만 꼭 이렇게 가리키는 대상을 1개로 구성해야 하는 것은 아니다.</li>
</ul>
<pre><code class="language-c">short **pp = (short **) malloc(3 * sizeof(short *));  // 12바이트(3*4) 크기로 메모리가 할당됨
</code></pre>
<ul>
<li>이 코드처럼 첫 번째 대상을 4바이트가 아닌 12바이트(4바이트 3개)로 할당해도 된다.</li>
<li>12바이트이면 4바이트 크기로 메모리를 나눠서 사용할 수 있기 때문에 총 세 개의 주소를 저장할 수 있다.</li>
<li>그리고 첫 번째 대상의 첫 번째 주소에 접근하고 싶으면 포인터의 주소 연산을 사용해서 <code>*(pp + 0)</code>이라고 써 주면 된다.</li>
<li>그리고 첫 번째 대상의 두 번째 주소에 접근하고 싶으면 <code>*(pp + 1)</code> 그리고 세 번째 주소에 접근하려면 <code>*(pp + 2)</code>라고 쓰면 된다.</li>
</ul>
<p><img src="./images/multi_dimensional_pointer_10.png" alt="12바이트로 할당" /></p>
<ul>
<li>2차원 포인터 <code>pp</code>가 가리키는 두 번째 대상도 2바이트(<code>short</code>)가 아닌 4바이트로 할당해서 <code>short</code>형식의 정수 값을 한 개가 아닌 두 개 저장할 수도 있다.</li>
</ul>
<pre><code class="language-c">*pp = (short *) malloc(2 * sizeof(short));  // 4바이트(2*2) 크기로 메모리가 할당됨
</code></pre>
<ul>
<li>위와 같이 4바이트가 할당되면 2바이트(<code>short</code>)씩 나눠서 2개의 정수를 저장할 수 있다.</li>
<li>첫 번째 정수 값을 저장하기 위해서는 <code>*(*pp + 0)</code>또는 <code>**pp</code>라고 사용하면 되고 두 번째 정수 값을 저장하기 위해서는 <code>*(*pp + 1)</code>이라고 사용하면 된다.</li>
<li>이렇게 2차원 포인터가 가리키는 첫 번째 대상과 두 번째 대상에 값을 한 개 이상 저장할 수 있도록 구성하면, 2차원 배열과 비슷한 형식의 메모리를 구성할 수 있다.</li>
<li>2차원 배열을 사용하는 경우에는 행의 갯나 열의 개수가 변경되면 반드시 다시 컴파일을 해서 변경 사항을 반영해야 한다.</li>
<li>하지만 2차원 포인터와 동적 메모리 할당을 사용해서 2차원 메모리 구조를 만들면 행의 개수나 열의 개수가 변경되더라도 컴파일을 다시 하지 않아도 된다.</li>
<li>조건이 변할 때 마다 매번 다시 컴파일해야 하는 프로그램보다는 별다른 변경 없이 그대로 사용할 수 있는 프로그램이 당연히 더 좋을 것이다.</li>
<li>따라서 2차원 포인터와 동적 메모리 할당을 사용하여 2차원 데이터 구조를 만드는 것이 좋다.</li>
</ul>
<h2 id="17-3-2차원-포인터와-함수의-매개변수"><a class="header" href="#17-3-2차원-포인터와-함수의-매개변수">17-3. 2차원 포인터와 함수의 매개변수</a></h2>
<h3 id="매개변수에-포인터-변수를-잘못-사용한-경우"><a class="header" href="#매개변수에-포인터-변수를-잘못-사용한-경우">매개변수에 포인터 변수를 잘못 사용한 경우</a></h3>
<ul>
<li>프로그래밍을 하다 보면 중복된 코드를 줄이고 변화에 효과적으로 대처하기 위해서 함수를 만들어 사용하는 경우가 많다.</li>
<li>그런데 함수의 매개변수로 포인터를 사용하는 경우에 차원 개념을 잘못 적용하면 원하는 값을 제대로 반환 받지 못해 오류가 발생할 수 있다.</li>
<li>이런 종류의 오류는 컴파일할 때는 문제가 없지만 실행할 때 오류가 발생할 확률이 높다.</li>
<li>다음과 같이 8바이트의 메모리를 동적으로 할당하는 <code>GetMyData</code>함수를 만들고 이 함수를 호출하는 예제 코드를 구성해 보자.</li>
<li>이 예제는 컴파일은 성공하지만 프로그램이 실행될 때 오류가 발생한다.</li>
</ul>
<pre><code class="language-c">/* 8바이트의 동적 메모리를 할당하는 함수 만들기 */

#include &lt;malloc.h&gt;

void GetMyData(int *q) {
    q = (int *) malloc(8);  // 8바이트의 메모리를 동적 할당하여 포인터 q에 저장함
}

void main() {
    int *p;        // p는 초기화되지 않아서 쓰레기(유효하지 않은) 값을 저장함
    GetMyData(p);  // 함수를 호출하여 p에 8바이트 메모리를 할당함
    *p = 5;        // 오류 발생: 할당된 메모리의 첫 4바이트에 값 5를 넣음
    free(p);       // 동적으로 할당된 메모리를 해제함
}
</code></pre>
<pre><code class="language-text">Process finished with exit code -1073741819 (0xC0000005)
</code></pre>
<h4 id="문제가-발생하는-이유"><a class="header" href="#문제가-발생하는-이유">문제가 발생하는 이유</a></h4>
<ul>
<li>이 문제가 발생한 이유는 <code>main</code>함수의 포인터 변수 <code>p</code>에서 <code>GetMyData</code>함수의 포인터 변수 <code>q</code>로 원하지 않는 주소 값이 전달되었기 때문이다.</li>
<li>이 상황을 명령이 실행되는 순서대로 적어 보면 다음과 같다.</li>
</ul>
<p><img src="./images/2_dimensional_pointer_1.png" alt="매개변수에 포인터 변수를 잘못 사용한 경우" /></p>
<blockquote>
<ol>
<li><code>p</code>는 초기화되지 않아서 쓰레기(유효하지 않은) 값을 저장함.</li>
<li><code>GetMyData</code>함수의 매개변수로 <code>p</code> 전달함.</li>
<li><code>p</code>에 저장된 주소 값을 <code>q</code>에 대입함. <code>p</code>와 <code>q</code>는 같은 주소 값(쓰레기 값)을 저장하고 있음.</li>
<li>8바이트 동적 메모리 할당. 할당된 메모리의 주소 값은 <code>q</code>에 저장함. 결국 <code>q</code>에는 새로 할당된 메모리의 주소가 저장되었을 뿐 <code>p</code>포인터 변수에는 별다른 영향을 미치지 않음.</li>
<li><code>p</code>는 처음 가지고 있던 쓰레기 값을 그대로 가지고 있는 상황인데, 그 주소에 <code>5</code>를 저장하려고 하면 원하지 않는 주소 값을 대입하는 것이기 때문에 오류 발생함.</li>
</ol>
</blockquote>
<ul>
<li>앞의 코드를 보면 포인터 변수 <code>p</code>에는 실제 메모리 주소 값이 대입된 적이 없다.</li>
<li>초기화되지 않은 쓰레기 값만 들어갔을 뿐이다.</li>
<li>그런데 이 포인터 변수를 <code>*p = 5;</code>라고 사용했으니 유효하지 않은 주소로 이동해서 값 <code>5</code>를 대입하기 때문에 문제가 발생하는 것이다.</li>
</ul>
<h4 id="동적으로-할당된-주소-값을-포인터-변수에-대입하면-문제를-해결할-수-있을까"><a class="header" href="#동적으로-할당된-주소-값을-포인터-변수에-대입하면-문제를-해결할-수-있을까">동적으로 할당된 주소 값을 포인터 변수에 대입하면 문제를 해결할 수 있을까?</a></h4>
<ul>
<li>먼저 <code>malloc</code>함수를 사용하여 8바이트 메모리를 할당하자.</li>
<li>그리고 할당된 메모리의 주소 값은 포인터 변수 <code>q</code>에 저장하고, <code>q</code>가 저장하고 있는 주소 값을 포인터 변수 <code>p</code>에 대입해 보자.</li>
</ul>
<p><img src="./images/2_dimensional_pointer_2.png" alt="동적으로 할당된 주소 값을 포인터 변수에 대입하면 문제를 해결할 수 있을까?" /></p>
<blockquote>
<ol>
<li><code>p</code>는 초기화되지 않아서 쓰레기(유효하지 않은) 값을 저장함.</li>
<li><code>GetMyData</code>함수의 매개변수로 <code>p</code> 전달함.</li>
<li><code>p</code>에 저장된 주소 값을 <code>q</code>에 대입. <code>p</code>와 <code>q</code>는 같은 주소 값을 저장하고 있음.</li>
<li>8바이트 동적 메모리 할당. 할당된 메모리의 주소 값은 <code>q</code>에 저장함. 결국 <code>q</code>에는 새로 할당된 메모리의 주소가 저장되었을 뿐 <code>p</code> 포인터 변수에는 별다른 영향을 미치지 않음.</li>
<li><code>GetMyData</code>함수에 선언한 지역 변수 <code>q</code>는 다른 함수에 선언한 지역 변수 <code>p</code>를 사용할 수 없어 오류 발생함.</li>
</ol>
</blockquote>
<ul>
<li>위와 같이 소스 코드를 수정하면 포인터 변수 <code>p</code>와 <code>q</code>는 같은 주소 값을 저장하게 된다.</li>
<li>결국 동적으로 할당된 8바이트 메모리의 주소 값을 둘 다 가지고 있는 셈이다.</li>
<li>하지만 이런 해결책은 <code>GetMyData</code>함수에 적용할 수 없다.</li>
<li>왜냐하면 <code>GetMyData</code>함수에 선언한 지역 변수 <code>q</code>는 다른 함수(<code>main</code>)에 선언한 지역 변수 <code>p</code>에 값을 대입할 수 없어서 <code>p = q;</code>라고 적으면 컴파일할 때 오류가 발생하기 때문이다.</li>
<li>결국 이 방법으로도 문제를 해결할 수가 없다.</li>
</ul>
<h3 id="함수의-매개변수로-2차원-포인터-사용하기"><a class="header" href="#함수의-매개변수로-2차원-포인터-사용하기">함수의 매개변수로 2차원 포인터 사용하기</a></h3>
<ul>
<li><code>main</code>함수의 지역 변수 <code>p</code>의 값을 변경하고 싶다면 <code>GetMyData</code>함수에서 변수 <code>p</code>의 주소 값을 전달 받아 처리해야 한다.</li>
<li>다른 함수에 선언한 지역 변수의 '이름'은 사용할 수 없지만 '주소'는 사용할 수 있기 때문이다.</li>
<li>그런데 변수 <code>p</code>가 일반 변수가 아니고 1차원 포인터 변수이기 때문에, <code>p</code>변수의 주소 값을 전달 받는 변수 <code>q</code>를 2차원 포인터로 선언해서 사용해야 한다.</li>
</ul>
<p><img src="./images/2_dimensional_pointer_3.png" alt="함수의 매개변수로 2차원 포인터 사용하기" /></p>
<blockquote>
<ol>
<li><code>p</code>는 초기화되지 않아서 쓰레기(유효하지 않은) 값을 저장함.</li>
<li><code>GetMyData</code>함수의 매개변수로 <code>&amp;p</code> 전달함.</li>
<li>2차원 포인터 <code>q</code>에 1차원 포인터 <code>p</code>의 주소 값을 저장함.</li>
<li>8바이트 동적 메모리 할당. 할당된 메모리의 주소 값은 <code>q</code>가 가리키는 대상인 포인터 변수 <code>p</code>에 저장함.</li>
<li><code>p</code>에 저장된 주소에 가서 값 5를 대입함.</li>
</ol>
</blockquote>
<p><img src="./images/2_dimensional_pointer_4.png" alt="함수의 매개변수로 2차원 포인터 사용" /></p>
<ul>
<li>위와 같이 2차원 포인터와 함수의 매개변수 개념을 사용하면 변수 <code>p</code>와 <code>q</code>가 서로 다른 함수의 지역 변수라도 <code>main</code>함수에 선언된 포인터 변수 <code>p</code>의 주소 값을 변경할 수 있다.</li>
<li>이제 이 개념을 <code>GetMyData</code>함수에 적용해 보자.</li>
</ul>
<pre><code class="language-c">/* 2차원 포인터로 8바이트 동적 메모리를 할당하는 함수 만들기 */

#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void GetMyData(int **q) {  // 포인터 변수 q는 p 변수의 주소 값을 저장함
    // 할당된 메모리의 주소 값을 포인터 q가 가리키는 main 함수의 p에 저장함
    *q = (int *) malloc(8);
}

void main() {
    int *p;         // p는 초기화되지 않아서 쓰레기(유효하지 않은) 값을 저장함
    GetMyData(&amp;p);  // 포인터 변수 p의 주소 값을 매개변수로 전달함
    *p = 5;         // 할당된 메모리의 첫 4바이트에 값 5를 넣음
    free(p);        // 할당된 동적 메모리를 해제함
}
</code></pre>
<ul>
<li>16장에서 동적 메모리 할당을 설명할 때 <code>malloc</code>함수와 <code>free</code>함수를 한 쌍으로 사용하는 것이 좋다고 했는데 위의 예제에서는 분리해서 사용했다.</li>
<li>그 이유는 <code>GetMyData</code>함수에서 동적으로 할당한 메모리의 주소 값을 <code>main</code>함수의 포인터 변수 <code>p</code>에 저장하여 사용하기 때문이다.</li>
<li>따라서 <code>GetMyData</code>함수에서 <code>free</code>함수를 사용해서 메모리를 해제하면 <code>GetMyData</code>함수에서 할당한 메모리가 해제되어 버린다. </li>
<li>즉 <code>main</code>함수의 포인터 변수 <code>p</code>에 전달된 주소 값은 이미 해제된 메모리의 주소 값인 것이다.</li>
<li>따라서 <code>GetMyData</code>함수에서 할당된 메모리를 해제하면, <code>main</code>함수에서 포인터 변수 <code>p</code>를 사용하는 곳에서 문제가 발생하므로 주의해야 한다.</li>
</ul>
<h2 id="17-4-2차원-포인터와-2차원-배열"><a class="header" href="#17-4-2차원-포인터와-2차원-배열">17-4. 2차원 포인터와 2차원 배열</a></h2>
<h3 id="여러-개의-1차원-포인터를-정적으로-할당하기"><a class="header" href="#여러-개의-1차원-포인터를-정적으로-할당하기">여러 개의 1차원 포인터를 정적으로 할당하기</a></h3>
<ul>
<li><code>short *</code>형식의 1차원 포인터가 100개 필요하다면 배열 문법을 사용하여 다음과 같이 선언할 수 있다.</li>
</ul>
<pre><code class="language-c">short *p[100];  // short *형식의 1차원 포인터를 100개 선언함
</code></pre>
<ul>
<li>배열의 요소가 100개이고 각 요소의 크기가 4바이트(포인터)이기 때문에 이 배열에 할당된 전체 메모리 크기는 400바이트이다</li>
<li>이렇게 선언하면 <code>p[0]</code>부터 <code>p[99]</code>까지 총 100개의 포인터를 사용할 수 있다.</li>
<li>하지만 위와 같은 표현에는 두 가지 비효율성이 있다.</li>
<li>첫 번째는 배열을 사용했기 때문에 컴파일할 때 변수 <code>p</code>의 메모리 크기가 400바이트로 고정되어 버린다.</li>
<li>만약 포인터 200개를 사용하도록 수정해야 한다면 변수 <code>p</code>를 <code>p[100]</code>대신 <code>p[200]</code>으로 바꿔서 선언해야 한다.</li>
<li>그리고 소스 코드를 변경했기 때문에 소스 파일을 다시 컴파일해야 하는 불편함이 있다.</li>
<li>두 번째는 메모리가 낭비될 수 있다.</li>
<li>변수 <code>p</code>는 100개의 포인터가 메모리에 할당되기 때문에 실제로 포인터를 5개만 사용하는 경우에 95개의 포인터를 저장할 수 있는 메모리가 낭비된다.</li>
<li>결국 이 문제는 배열을 선언할 때 배열 크기가 반드시 상수로 적어야 하기 때문에 발생하는 것이다.</li>
</ul>
<h3 id="여러-개의-1차원-포인터를-동적-할당하기"><a class="header" href="#여러-개의-1차원-포인터를-동적-할당하기">여러 개의 1차원 포인터를 동적 할당하기</a></h3>
<ul>
<li>17-2에서 2차원 포인터가 가리키는 첫 번째 대상에는 1차원 포인터의 주소 값을 저장해서 사용하는 것이 가장 좋지만, 4바이트 크기의 메모리에 주소 값을 저장해서 사용해도 된다고 하였다.</li>
<li>그래서 <code>malloc</code>함수로 4바이트 메모리를 할당하여 2차원 포인터에 저장하면 그 메모리를 1차원 포인터처럼 활용할 수 있기 때문에 다음과 같이 적을 수 있다.</li>
<li>결국 아래 코드는 1차원 포인터 1개를 할당하는 내용이다.</li>
</ul>
<pre><code class="language-c">short **pp;
pp = (short **) malloc(sizeof(short *));  // pp = (short **) malloc(4); 와 같은 표현
</code></pre>
<p><img src="./images/several_1_dimensional_pointer_1.png" alt="여러 개의 1차원 포인터를 동적 할당하기" /></p>
<ul>
<li><code>malloc</code>함수의 매개변수에 동적으로 할당할 메모리의 크기를 적을 때는 상수 뿐만 아니라 변수를 사용할 수 있다.</li>
<li>따라서 다음과 같이 <code>short *</code>형식의 1차원 포인터를 n개 할당할 수 있고 이렇게 할당된 메모리는 <code>*(pp + 0)</code>부터 <code>*(pp + n - 1)</code>까지 1차원 포인터 n개를 사용할 수 있다.</li>
</ul>
<pre><code class="language-c">int n;
short **pp;
scanf(&quot;%d&quot;, &amp;n);  // 사용할 1차원 포인터의 개수를 사용자에게 받음
pp = (short **) malloc(sizeof(short *) * n);
// malloc 함수의 매개변수로 short *형식의
// 1차원 포인터 n개를 할당합니다
</code></pre>
<p><img src="./images/several_1_dimensional_pointer_2.png" alt="여러 개의 1차원 포인터를 동적 할당하기 - 2" /></p>
<ul>
<li>이렇게 2차원 포인터와 <code>malloc</code>함수를 사용하면 배열을 사용하는 것보다 코드는 좀 더 복잡해지지만 프로그램 실행 중에 1차원 포인터의 개수가 바뀌어도 소스 파일을 다시 컴파일할 필요가 없다.</li>
<li>그리고 사용자가 메모리를 사용하고 싶은 크기만큼 선택할 수 있기 때문에 배열을 사용하는 것보다 메모리 효율성이 좋다.</li>
</ul>
<h3 id="2차원-배열과-동적-메모리-할당"><a class="header" href="#2차원-배열과-동적-메모리-할당">2차원 배열과 동적 메모리 할당</a></h3>
<ul>
<li>2차원 배열과 같은 용도로 사용할 수 있는 메모리를 동적으로 할당하는 방법을 살펴보자.</li>
<li>어떤 회사에서 직원들의 체력을 테스트한 결과를 저장하는 프로그램을 만들어 볼 것이다.</li>
<li>이 회사의 연령별 인원수는 20대가 4명, 30대 2명, 40대 3명이다.</li>
<li>1분간 윗몸 일으키기를 하고, 이 횟수를 연령별로 저장하는 데 필요한 메모리는 어떻게 할당하는 것이 가장 효과적일까?</li>
</ul>
<h4 id="2차원-배열로-메모리를-할당하는-방법"><a class="header" href="#2차원-배열로-메모리를-할당하는-방법">2차원 배열로 메모리를 할당하는 방법</a></h4>
<ul>
<li>먼저 1명이 1분 동안 수행한 윗몸 일으키기 횟수를 저장하기 위한 자료형(메모리 크기)을 결정해야 한다.</li>
<li>이 횟수는 정수 값이고 음수가 나올 수 없으며 200개를 넘을 가능성도 없다.</li>
<li>따라서 0~200 사이의 값을 저장하면 되기 때문에 <code>unsigned char</code>자료형(0~255)으로도 충분히 데이터를 저장할 수 있다.</li>
<li>어떤 배열 구조를 사용할지 정해보자.</li>
<li>연령별 그룹이 2그룹이고 각 그룹별로 2명에서 4명까지 포함될 수 있다.</li>
<li>따라서 2차원 배열 구조가 효율적일 것이다.</li>
<li>2차원 배열을 사용하려면 그룹별 크기가 같아야 하므로 최대 인원수인 4명으로 배열의 크기를 정해야 한다.</li>
<li>이 내용을 종합해서 2차원 배열을 변수로 선언해 보면 다음과 같다.</li>
</ul>
<pre><code class="language-c">unsigned char count[3][4];  // 3개의 그룹에 최대 4명의 사람을 관리함
</code></pre>
<p><img src="./images/2_dimensional_array_mem_1.png" alt="2차원 배열 메모리 할당" /></p>
<ul>
<li>이렇게 선언한 배열에 직원들의 윗몸 일으키기 횟수를 대입해 보자.</li>
</ul>
<pre><code class="language-c">count[0][1] = 49;  // 20대 연령의 두 번째 사람
count[1][0] = 45;  // 30대 연령의 첫 번째 사람
count[2][2] = 42;  // 40대 연령의 세 번째 사람
</code></pre>
<pre><code class="language-c">/* 2차원 배열로 연령별 윗몸 일으키기 횟수 관리하기 */

#include &lt;stdio.h&gt;

void main() {
    // 연령별 인원수. 20대 4명, 30대 2명, 40대 3명
    unsigned char limit_table[3] = {4, 2, 3};

    // 연령별 윗몸 일으키기 횟수를 저장할 배열
    unsigned char count[3][4];
    int age, member, temp, sum;

    // 연령별로 윗몸 일으키기 횟수를 입력 받음
    for (age = 0; age &lt; 3; age++) {
        // '각 연령의 윗몸 일으키기 횟수'라고 출력함
        printf(&quot;\n%d0대 연령의 윗몸 일으키기 횟수\n&quot;, age + 2);
        // 해당 연령에 소속된 사람들을 순서대로 입력 받음
        for (member = 0; member &lt; limit_table[age]; member++) {
            // '1th :, 2th :, ...'라고 출력함
            printf(&quot;%dth :&quot;, member + 1);
            // 윗몸 일으키기 횟수를 정수로 입력 받음
            scanf(&quot;%d&quot;, &amp;temp);
            // scanf로 unsigned char 변수에 직접 정수를 받을 수 없어서 temp 변수에
            // 정수로 입력 받은 후에 count 배열 요소에 저장한다
            count[age][member] = (unsigned char) temp;
        }
    }

    printf(&quot;\n\n연령별 평균 윗몸 일으키기 횟수\n&quot;);
    // 연령별로 입력된 횟수를 합산하여 평균 값을 출력함
    for (age = 0; age &lt; 3; age++) {
        sum = 0;
        // '20대 :, 30대 :, 40대 :'라고 출력함
        printf(&quot;%d0대 : &quot;, age + 2);
        // 해당 연령에 소속된 사람들의 횟수를 합산함
        for (member = 0; member &lt; limit_table[age]; member++) {
            sum = sum + count[age][member];
        }
        // 합산 값을 인원수로 나누어서 평균을 냄
        printf(&quot;%5.2f\n&quot;, (double) sum / limit_table[age]);
    }
}
</code></pre>
<pre><code class="language-text">20대 연령의 윗몸 일으키기 횟수
1th :57
2th :52
3th :55
4th :50

30대 연령의 윗몸 일으키기 횟수
1th :48
2th :41

40대 연령의 윗몸 일으키기 횟수
1th :35
2th :52
3th :43


연령별 평균 윗몸 일으키기 횟수
20대 : 53.50
30대 : 44.50
40대 : 43.33
</code></pre>
<h3 id="조건-추가-1-각-연령층에-포함된-인원수가-변한다면"><a class="header" href="#조건-추가-1-각-연령층에-포함된-인원수가-변한다면">조건 추가 1: 각 연령층에 포함된 인원수가 변한다면?</a></h3>
<ul>
<li>회사에 직원들이 변동하여 각 연령층에 포함된 인원수에 변화가 생길 수 있다는 조건을 추가해 보자.</li>
<li>이 조건을 만족하려면 <code>limit_table</code>에 고정되어 있는 4, 2, 3값을 정해 놓지 않고 프로그램이 시작할 때 사용자에게 입력 받으면 된다.</li>
<li>하지만 <code>count</code>배열에서 고려한 최대 인원수가 4명이기 때문에 사용자가 입력한 인원수가 4명보다 많아지면 <code>count</code>배열에 문제가 생긴다.</li>
<li>배열은 요소의 개수를 상수로만 입력받을 수 있기 때문에 최대 인원수를 4보다 큰 숫자로 변경하려면 소스 코드에서 <code>count</code>배열의 크기를 직접 변경해야 한다.</li>
<li>이렇게 되면 소스 코드 또한 다시 컴파일해야 한다.</li>
</ul>
<h4 id="포인터-배열-사용하여-메모리-할당하기"><a class="header" href="#포인터-배열-사용하여-메모리-할당하기">포인터 배열 사용하여 메모리 할당하기</a></h4>
<ul>
<li>이 문제를 해결하려면 사용자가 입력한 인원수만큼 메모리를 동적으로 할당해야 한다.</li>
<li>연령층에는 변화가 없기 때문에 다음과 같이 포인터 배열을 사용하여 3개의 포인터를 선언한다.</li>
<li>그리고 각 포인터에 <code>malloc</code>함수를 사용하여 사용자가 입력한 연령별 인원수로 메모리를 동적으로 할당하면 된다.</li>
</ul>
<pre><code class="language-c">unsigned char limit_table[3] = {4, 2, 3};  // 사용자가 연령층별로 입력한 인원수
unsigned char *p[3];  // 1차원 포인터 3개를 선언함
int age;

// 연령층별로 입력된 인원수만큼 동적으로 메모리를 할당함
for (age = 0; age &lt; 3; age++) {
    p[age] = (unsigned char *) malloc(limit_table[age]);
}
...
// 프로그램이 끝나기 전에 동적으로 할당된 메모리를 정리함
for (age = 0; age &lt; 3; age++) free(p[age]);
</code></pre>
<p><img src="./images/pointer_array_malloc_1.png" alt="포인터 배열 사용하여 메모리 할당하기" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void main() {
    // 연령별 인원수를 저장할 배열 - 사용자에게 입력 받음
    unsigned char limit_table[3];

    // 연령별 윗몸 일으키기 횟수를 저장할 배열
    unsigned char *p[3];
    int age, member, temp, sum;

    // 연령별로 윗몸 일으키기 횟수를 입력 받음
    for (age = 0; age &lt; 3; age++) {
        // '20대 연령의 윗몸 일으키기 횟수'라고 출력하기 위해서 설정함
        printf(&quot;\n%d0대 연령의 윗몸 일으키기 횟수\n&quot;, age + 2);
        printf(&quot;이 연령대는 몇 명입니까 :&quot;);

        // 해당 연령에 소속된 인원수를 입력 받음
        scanf(&quot;%d&quot;, &amp;temp);
        // scanf로 unsigned char 변수에 직접 정수를 받을 수 없어서
        // temp변수에 정수로 입력 받은 후 limit_table 배열에 넣어 줍니다
        limit_table[age] = (unsigned char) temp;

        // 입력 받은 인원수만큼 메모리를 할당함
        p[age] = (unsigned char *) malloc(limit_table[age]);

        // 해당 연령에 소속된 사람들을 순서대로 입력 받음
        for (member = 0; member &lt; limit_table[age]; member++) {
            // '1th :, 2th :, ...'라고 출력하기 위해서 설정함
            printf(&quot;%dth :&quot;, member + 1);
            // 윗몸 일으키기 횟수를 정수로 입력 받음
            scanf(&quot;%d&quot;, &amp;temp);
            // scanf로 unsigned char 변수에 직접 정수를 받을 수 없어서
            // temp 변수에 정수로 입력 받은 후에 *(p[age] + member)에 저장합니다
            *(p[age] + member) = (unsigned char) temp;
        }
    }

    printf(&quot;\n\n연령별 평균 윗몸 일으키기 횟수\n&quot;);
    // 연령별로 입력된 횟수를 합산하여 평균 값을 출력함
    for (age = 0; age &lt; 3; age++) {
        sum = 0;

        // '20대 :, 30대 :, 40대 :'라고 출력하기 위해 설정함
        printf(&quot;%d0대 : &quot;, age + 2);
        // 해당 연령에 소속된 사람들의 횟수를 합산함
        for (member = 0; member &lt; limit_table[age]; member++) {
            sum = sum + *(p[age] + member);
        }
        // 합산 값을 인원수로 나누어서 평균을 냄
        printf(&quot;%5.2f\n&quot;, (double) sum / limit_table[age]);
        // 이 연령에 할당했던 동적 메모리를 해제함
        free(p[age]);
    }
}
</code></pre>
<pre><code class="language-text">20대 연령의 윗몸 일으키기 횟수
이 연령대는 몇 명입니까 :4
1th :57
2th :61
3th :53
4th :59

30대 연령의 윗몸 일으키기 횟수
이 연령대는 몇 명입니까 :2
1th :49
2th :51

40대 연령의 윗몸 일으키기 횟수
이 연령대는 몇 명입니까 :3
1th :45
2th :37
3th :51


연령별 평균 윗몸 일으키기 횟수
20대 : 57.50
30대 : 50.00
40대 : 44.33
</code></pre>
<h3 id="조건-추가-2-직원의-연령층이-다양해진다면"><a class="header" href="#조건-추가-2-직원의-연령층이-다양해진다면">조건 추가 2: 직원의 연령층이 다양해진다면?</a></h3>
<ul>
<li>이렇게 되면 연령별 윗몸 일으키기 횟수를 저장할 포인터가 3개에서 4개 또는 5개로 변경될 수 있다는 뜻이 된다.</li>
<li>그리고 이 정보도 사용자에게 입력 받아서 처리할 수 있어야 하므로 연령층의 개수도 변수로 선언해서 사용해야 한다.</li>
<li>따라서 포인터 개수를 고정해서 만드는 포인터 배열은 이제 더 이상 사용할 수 없다.</li>
</ul>
<h4 id="2차원-포인터를-사용하여-2차원-데이터-형식-만들기"><a class="header" href="#2차원-포인터를-사용하여-2차원-데이터-형식-만들기">2차원 포인터를 사용하여 2차원 데이터 형식 만들기</a></h4>
<pre><code class="language-c">unsigned char *p_limit_table;  // 사용자가 연령층별로 입력한 인원수를 저장할 포인터
unsigned char **p;  // 1차원 포인터를 n개 선언할 2차원 포인터
int age_step = 3;  // 연령대의 개수, 10대, 20대, 30대
int age;

// 연령층별 인원수를 저장할 메모리를 동적으로 할당함
p_limit_table = (unsigned char *) malloc(age_step);
p_limit_table[0] = 4;  // 20대 4명
p_limit_table[1] = 2;  // 30대 2명
p_limit_table[2] = 3;  // 40대 3명

// 연령층별로 윗몸 일으키기 횟수를 저장할 포인터를 연령층 개수만큼 만듦
p = (unsigned char **) malloc(sizeof(unsigned char *) * age_step);

// 연령층별로 입력된 인원수만큼 동적으로 메모리를 할당함
for (age = 0; age &lt; age_step; age++) {
    *(p + age) = (unsigned char *) malloc(*(p_limit_table + age));
}

// 프로그램이 끝나기 전에 동적 할당된 메모리를 정리함
for (age = 0; age &lt; age_step; age++) free(*(p + age));
free(p);  // 동적 할당된 1차원 포인터 메모리를 해제함
free(p_limit_table);  // 연령별 인원수를 저장하기 위해 만든 메모리를 해제함
</code></pre>
<p><img src="./images/pointer_array_malloc_2.png" alt="2차원 포인터를 사용하여 2차원 데이터 형식 만들기" /></p>
<ul>
<li>연령층의 개수가 사용자의 입력에 따라 달라질 수 있도록 만들어야 하기 때문에 연령층의 개수를 저장할 <code>age_step</code>변수를 추가했다.</li>
<li>그리고 연령층별 인원수를 관리하던 <code>p_limit_table</code>배열 크기는 더 이상 3(20대, 30대, 40대)으로 고정할 수 없기 때문에 <code>age_step</code>변수를 <code>malloc</code>함수에 사용하여 동적으로 메모리를 할당하도록 변경했다.</li>
<li>그리고 2차원 포인터 <code>p</code>도 연령층의 개수에 따라 만들어지는 1차원 포인터의 개수가 달라지기 때문에 <code>age_step</code>변수를 <code>malloc</code>함수에 사용하여 동적으로 메모리를 할당하도록 변경했다.</li>
<li>이와 같이 메모리를 구성하면 첫 예제에서 <code>unsigned char count[3][4];</code>라고 선언한 2차원 배열 구조와 같은 용도로 사용할 수 있도록 2차원 포인터로 메모리를 할당한 것이다.</li>
<li>이렇게 2차원 포인터를 사용하면 소스 코드는 좀 복잡해지더라도 프로그램이 훨씬 유연해진다.</li>
</ul>
<pre><code class="language-c">/* 2차원 포인터로 연령별 윗몸 일으키기 횟수 관리하기 */

#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

void main() {
    // 연령별 인원수를 저장할 포인터 - 사용자에게 입력 받음
    unsigned char *p_limit_table;

    // 연령별 윗몸 일으키기 횟수를 저장할 2차원 포인터
    unsigned char **p;
    int age, age_step, member, temp, sum;

    printf(&quot;20대부터 시작해서 연령층이 몇 개인가요 :&quot;);
    scanf(&quot;%d&quot;, &amp;age_step);

    // 연령별 인원수를 저장할 메모리를 만듦
    p_limit_table = (unsigned char *) malloc(age_step);
    p = (unsigned char **) malloc(sizeof(unsigned char *) * age_step);

    // 연령별로 윗몸 일으키기 횟수를 입력 받음
    for (age = 0; age &lt; age_step; age++) {
        // '각 연령의 윗몸 일으키기 횟수'라고 출력함
        printf(&quot;\n%d0대 연령의 윗몸 일으키기 횟수\n&quot;, age + 2);
        printf(&quot;이 연령대는 몇 명입니까? :&quot;);
        // 해당 연령에 소속된 인원수를 입력 받음
        scanf(&quot;%d&quot;, &amp;temp);

        // scanf로 unsigned char 변수에 직접 정수를 받을 수 없어서 temp변수에 정수로 입력 받은 후에
        // p_limit_table이 가리키는 메모리에 넣어 줍니다
        *(p_limit_table + age) = (unsigned char) temp;
        // 입력 받은 인원수만큼 메모리를 할당함
        *(p + age) = (unsigned char *) malloc(*(p_limit_table + age));

        // 해당 연령에 소속된 직원들을 순서대로 입력 받음
        for (member = 0; member &lt; *(p_limit_table + age); member++) {
            // '1th :, 2th :, ...'라고 출력함
            printf(&quot;%dth :&quot;, member + 1);
            // 윗몸 일으키기 횟수를 정수로 입력 받음
            scanf(&quot;%d&quot;, &amp;temp);
            // scanf로 unsigned char 변수에 직접 정수를 받을 수 없어서 temp변수에 정수로 입력 받은 후에
            // p가 가리키는 메모리에 넣어 줍니다
            *(*(p + age) + member) = (unsigned char) temp;
        }
    }

    printf(&quot;\n\n연령별 평균 윗몸 일으키기 횟수\n&quot;);
    // 연령별로 입력된 횟수를 합산하여 평균 값을 출력함
    for (age = 0; age &lt; age_step; age++) {
        sum = 0;
        // '20대 :, 30대 :, 40대 :'라고 출력함
        printf(&quot;%d대 : &quot;, age + 2);
        // 해당 연령에 소속된 사람들의 횟수를 합산함
        for (member = 0; member &lt; *(p_limit_table + age);
             member++) {
            sum = sum + *(*(p + age) + member);
        }
        // 합산 값을 인원수로 나누어서 평균을 냄
        printf(&quot;%5.2f\n&quot;, (double) sum / *(p_limit_table + age));
        // 이 연령에 할당했던 동적 메모리를 해제함
        free(*(p + age));
    }

    // 윗몸 일으키기 횟수를 저장하기 위해서 구성했던 메모리를 해제함
    free(p);
    // 연령별 인원수를 기억하기 위해서 사용했던 메모리를 해제함
    free(p_limit_table);
}
</code></pre>
<pre><code class="language-text">20대부터 시작해서 연령층이 몇 개인가요 :3

20대 연령의 윗몸 일으키기 횟수
이 연령대는 몇 명입니까? :4
1th :55
2th :51
3th :63
4th :59

30대 연령의 윗몸 일으키기 횟수
이 연령대는 몇 명입니까? :2
1th :43
2th :40

40대 연령의 윗몸 일으키기 횟수
이 연령대는 몇 명입니까? :3
1th :41
2th :35
3th :38


연령별 평균 윗몸 일으키기 횟수
2대 : 57.00
3대 : 41.50
4대 : 38.00
</code></pre>
<ul>
<li>많은 프로그래머들이 2차원 포인터의 동적 할당 구조를 이해하는 것이 어려워서 사용하지 못하고 포기한다고 한다.</li>
<li>하지만 2차원 배열이나 포인터 배열을 사용하는 것보다 2차원 포인터를 이해하고 사용하면 프로그램을 훨씬 유연하게 만들 수 있으니 꼭 이해하고 넘어가자.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_16.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter_18.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_16.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter_18.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
