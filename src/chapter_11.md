# 11. 지역 변수와 전역 변수

- C 언어는 대부분의 변수를 함수 안에 선언해서 사용한다.
- 함수가 작업의 기본 단위이기 때문이다.
- 하지만 모든 변수를 함수 안에 선언하는 것은 아니다.
- 변수의 사용 목적에 따라 함수 밖에서도 변수를 선언할 수 있다.
- 선언 위치에 따라 달라지는 변수의 종류와 특성, 그에 따라 변수의 수명(Lifetime)이 어떻게 달라지는지 알아보자.
- 변수를 선언할 때 같이 사용하면 의미가 달라지는 `extern`, `static`, `const`키워드도 알아보자.

## 11-1. 함수 안에서만 사용하는 지역 변수

### 지역 변수 살펴보기

- 변수에는 두 종류가 있다.
- 함수 안에 사용하는 지역 변수, 프로그램 전체에서 사용할 수 있는 전역 변수가 있다.
- 함수 안에 선언한 변수나 매개변수는 지역 변수(Local Variable)이라고 하며, 이 변수는 자신을 선언한 함수가 호출될 때 메모리에 저장 공간이 만들어졌다가 함수 호출이 끝나면 함께 사라진다.
- 즉 함수와 같은 수명(Lifetime)을 가진다.
- 함수의 수명(생명 주기)은 함수가 호출된 시점부터 `return`또는 함수의 명령문 끝에 도달하여 함수가 종료될 때까지의 시점을 말한다.
```c
#include <stdio.h>

int ReturnNum() {
    int num = 5;
    return num;
}

void main() {
    ReturnNum();  // main 함수에서 ReturnNum 함수를 호출한다
    printf("%d", num);  // num 값은 5가 될까?
}
```
- 변수 `num`이 선언되지 않은 식별자라고 하면서 오류가 발생한다.
- `ReturnNum`함수가 호출될 때 함수 안에서 선언한 지역 변수 `num`이 메모리에 만들어졌다가 함수 호출이 끝나면서 사라져 버려 `main`함수에서는 변수 `num`을 쓸 수 없는 것이다.
- 즉 지역 변수는 자신을 선언한 함수 안에서만 사용할 수 있고 다른 함수에 선언된 지역 변수는 사용할 수 없다.

### 지역 변수 이름은 중복해서 사용할 수 있다

- 함수 안에 똑같은 이름의 변수가 있으면 오류로 처리된다.
- 하지만 서로 다른 함수에 선언된 변수라면 이름이 같아도 상관없다.
- 지역 변수는 특정한 '지역'에서만 사용하고 그 수명이 다하는 변수이기 때문이다.
- 예제: 변수의 사용 범위에 따른 유효성 이해하기
```c
#include <stdio.h>

int Sum(int data1, int data2) {  // 매개변수 data1, data2는 Sum 함수의 지역 변수
    // Sum 함수의 지역 변수 result를 선언한 후 data + data2 값으로 초기화함
    int result = data1 + data2;
    return result;
}

void main() {
    int result;  // main 함수의 지역 변수 result. 초기화되지 않아 어떤 값이 들어 있는지 모름
    result = Sum(5, 3);
    printf("5 + 3 = %d\n", result);
}
```
```text
5 + 3 = 8
```
- `main`함수의 `result`변수와 `Sum`함수의 `result`변수는 서로 다른 함수에 들어 있는 지역 변수이기 때문에 이름이 같아도 오류로 처리되지 않는다.
- 그리고 `main`함수에서는 `Sum`함수의 `data1`, `data2` 그리고 `result`변수를 사용할 수 없다.
- 지역 변수는 스스로 초기화되지 않기 때문에 필요할 때 프로그래머가 직접 초기화해야 한다.
- `main`함수의 `result`변수는 선언할 때 초기화하지 않았기 때문에 해당 변수에 어떤 값이 들어 있을지 예상할 수 없다.

## 11-2. 프로그램 전체에서 사용하는 전역 변수

### 전역 변수 살펴보기

- 함수 밖에 선언한 변수를 전역 변수(Global Variable)라고 한다.
- 이 변수는 프로그램이 시작할 때 만들어졌다가 프로그램이 종료될 때 함께 사라진다.
- 따라서 수명(Lifetime)이 프로그램과 같다.
- 전역 변수는 프로그램 전체 영역에서 사용할 수 있다.
- 그러므로 똑같은 이름을 가진 전역 변수가 프로그램 안에 또 있으면 오류로 처리된다.
- 전역 변수는 특별한 초기화 값이 없으면 0으로 초기화된다.
- 예제: 전역 변수를 사용하여 함수 간에 데이터 넘겨받기
```c
#include <stdio.h>

int result;  // 전역 변수. 특별한 초기화 값이 없으면 0으로 초기화됨

void Sum(int data1, int data2) {
    result = data1 + data2;
}

void main() {
    Sum(5, 3);
    printf("5 + 3 = %d\n", result);
}
```
```text
5 + 3 = 8
```
- 전역 변수는 한 번 선언하면 어떤 함수에서나 사용할 수 있으며, 프로그램 전체에서 값을 공유한다.
- 따라서 `return`명령을 사용하여 `Sum`함수의 반환값을 넘겨받지 않더라도 전역 변수의 값을 공유하여 간단하게 처리할 수 있다.

### 전역 변수를 사용할 때 주의할 점

- 전역 변수를 사용하면 `Sum`함수는 `result`변수에 종속적으로 바뀌게 된다.
- `Sum`함수를 다른 프로그램에서 재사용하기 위해 코드를 복사하는 경우에 `result`변수 선언도 같이 옮겨야 하는데, 옮겨 갈 프로그램에 이미 `result`전역 변수가 있다면 둘 중 하나는 이름을 바꿔야 한다.
- 이는 재사용을 불편하게 한다.
- 따라서 전역 변수는 함수의 독립성을 강조하는 C 언어의 장점을 퇴색시킨다.

> #### 전역 변수는 꼭 필요한 경우에만 사용하자
> 
> - 특히 여러 라이브러리를 사용할 경우 전역 변수에 대한 중복 오류가 발생하면 문제 해결이 힘들다.
> - 라이브러리 소스 코드는 직접 수정할 수 없기 때문에 불가능한 작업이다.
> - 따라서 프로그램을 만들 때는 전역 변수는 꼭 필요한 경우에만 사용하는 습관을 들이자.

### 지역 변수와 전역 변수의 이름이 같다면?

- 변수의 이름 중복 문제는 지역 변수와 전역 변수 간에 더 큰 문제가 발생할 수 있다.
- 두 변수는 서로 성격이 달라서 이름이 같더라도 오류로 처리되지 않기 때문이다.
- C 언어 문법은 전역보다 지역을 우선해서 처리한다.
- 따라서 지역 변수와 전역 변수의 이름이 같으면 지역 변수를 먼저 처리하기 때문에 주의가 필요하다.
- 예제: 전역 변수와 지역 변수의 이름이 같을 때 문제점 살펴보기
```c
#include <stdio.h>

int result;  // 전역 변수로 특별한 초기화 값이 없으면 0으로 초기화된다

void Sum(int data1, int data2) {
    int result;  // 지역 변수로 초기화되어 있지 않다
    // 지역 변수의 우선순위가 높기 때문에 연산 결과 값은 전역 변수 result가 아닌 지역 변수 result에 저장된다
    result = data1 + data2;
}

void main() {
    Sum(5, 3);
    printf("5 + 3 = %d\n", result);
}
```
```text
5 + 3 = 0
```
- `Sum`함수의 지역 변수 `result`와 전역 변수 `result`이름이 중복되었지만 변수 형식이 달라서 오류로 처리되지 않는다.
- 이름이 중복되는 경우에 지역 변수가 우선 처리되기 때문에 `data1 + data2`값은 지역 변수 `result`에 저장되고 전역 변수 `result`에는 아무 값도 대입되지 않는다.
- 따라서 전역 변수를 선언할 때 자동으로 초기화된 0값을 유지한다.
- 그렇기 때문에 `main`함수에서 전역 변수 `result`값을 출력하면 0이 나온다.
- `Sum`함수에서는 `result`가 전역 변수와 이름이 중복되어, 지역 변수나 전역 변수의 이름을 변경하기 전에는 전역 변수 `result`를 사용할 수 없다.
- 이런 문제가 근본적으로 발생하지 않도록 전역 변수 앞에 `g_`와 같은 접두어를 사용하여 `int g_result;`로 선언하는 것이 좋다.

## 11-3. extern 키워드

### 소스 파일을 분리할 때 발생하는 오류

- 프로그래밍을 하면서 소스 코드가 길어지면 파일 한개로 관리하는 것보다 여러 개의 파일로 나누어서 관리하는 것이 더 좋다.
- 연관이 높은 함수끼리 묶어서 파일 여러 개를 만들게 되면 소스 코드에 변경된 부분이 있을 떄에도 변경된 파일만 다시 컴파일하면 되므로 컴파일 드는 시간도 줄어든다.
- 예를 들어 위의 소스 코드에서 작업의 편의를 위해 `Sum`함수를 포함하는 `Sum.c`파일과 `main`함수를 포함하는 `Main.c`파일로 분리했다고 가정해 보자.
- 전역 변수를 그대로 가지고 있는 `Sum.c`파일은 오류가 나지 않지만, 파일이 분리되면서 전역 변수 선언을 참조하지 못하는 `Main.c`파일은 `result`를 사용한 위치에서 오류가 발생한다.
- 이 오류를 해결하기 위해 `Main.c`파일에 `int result;`라고 전역 변수를 또 추가하면 컴파일은 통과할 것이다.
- 하지만 링크할 때 프로젝트에 같은 이름의 전역 변수가 두 개 존재한다고 링크 오류가 발생한다.
- 이런 문제를 해결하려면 같은 프로젝트 안에 존재하는 전역 변수를 참조하겠다는 의미로 `extern`키워드를 사용해 `Main.c`파일에 `result`변수를 추가한다.<br>
> `Sum.c`:
> ```c
> int result = 0;  // 전역 변수
> 
> void Sum(int data1, int data2) {
>     result = data1 + data2;
> }
> ```

> `Main.c`:
> ```c
> #include <stdio.h>
> 
> // Sum 함수 원형(Prototype)
> void Sum(int, int);
> extern int result;
> void main() {
>     Sum(5, 3);
>     printf("5 + 3 = %d\n", result);
> }
> ```

### extern 키워드를 사용할 때 주의할 점

- `extern`키워드를 사용할 때 주의할 점은 다음과 같다.
> `A.c`:
> ```c
> // 전역 변수들
> int g_data1 = 0;
> int g_data2 = 0;
> int g_data5 = 0;
> ...
> ```
> `B.c`:
> ```c
> int g_data;  // 1.
> extern int g_data2;  // 2.
> extern int g_data3;  // 3.
> extern int g_data4 = 0;  // 4.
> extern int g_data5 = 0;  // 5.
> ...
> ```
1. `A.c`파일에 같은 이름의 `g_data1`전역 변수가 있기 때문에 링크 오류가 발생한다.
2. `A.c`파일에 선언된 `g_data2`전역 변수를 정상적으로 `extern`참조한다.
3. `A.c`파일에 선언되지 않은 전역 변수를 `extern`참조했으므로 오류로 처리된다.
4. `extern`참조에서 초기화를 사용했기 때문에 일반 전역 변수로 처리된다.(오류가 아니다)
5. `extern`참조에서 초기화를 사용했기 때문에 일반 전역 변수로 처리된다. 그런데 `A.c`파일에도 `g_data5`전역 변수가 선언되어 있기 때문에 중복되었다고 오류로 처리된다.

## 11-4. static 키워드

- 다른 사람들이 개발한 라이브러리에 포함된 전역 변수들의 문제라면 상황이 심각해질 수 있다.
- 이러한 문제가 발생하는 근본적인 이유는 전역 변수의 사용 범위가 프로그램 소스 전체 영역이기 때문이다.
- 그래서 C 언어는 전역 변수의 사용 범위를 제한할 수 있는 `static`키워드를 제공한다.

### 특정 소스 파일에서만 전역 변수 사용하기

- 전역 변수를 선언하고 해당 전역 변수의 사용 범위를 변수를 선언한 소스 파일로 제한하고 싶다면 전역 변수 앞에 `static`키워드를 사용하면 된다.
- 이렇게 하면 다른 소스 파일에서 이 전역 변수에 `extern`키워드를 사용할 수 없을 뿐만 아니라 같은 이름의 전역 변수를 다른 소스 파일에서 선언해도 오류가 발생하지 않는다.
- 즉 같은 이름의 전역 변수를 두 개 선언하더라도 `static`키워드를 사용하면 둘 다 별개의 전역 변수로 사용할 수 있다.

> `A.c`:
> ```c
> // 전역 변수들
> int g_data1 = 0;
> static int g_data2 = 0;
> static int g_data3 = 0;
> ...
> ```
> `B.c`:
> ```c
> int g_data1;  // 1.
> int g_data2;  // 2.
> extern int g_data3;  // 3.
> ...
> ```
1. `A.c`파일에 같은 이름의 `g_data1`전역 변수가 있기 때문에 링크 오류가 발생한다.
2. `A.c`파일의 `g_data2`와 `B.c`의 `g_data2`는 `static`으로 구별되어 별개의 전역 변수로 처리된다.
3. `g_data3`는 `static`으로 선언된 전역 변수라서 `extern`참조할 수 없기 때문에 오류로 처리된다.

> #### 소스 코드가 세 개 이상의 파일로 나뉜다면?
> 
> - 소스 코드가 세 개의 파일 `A.c`, `B.c`, `C.c`로 구분되어 있는 경우에, `A.c`파일에 `static int g_data;`형식으로 전역 변수를 선언하고 `B.c`파일에 `int g_data;`형식으로 전역 변수를 선언했다면 두 `g_data`전역 변수는 별개로 사용되기 때문에 선언 오류가 발생하지 않는다.
> - 그리고 `B.c`파일에 선언한 `g_data`전역 변수는 `A.c`파일에는 같은 이름의 전역 변수가 있어서 사용할 수 없고, `B.c`파일에서는 당연히 사용할 수 있다.
> - `C.c`파일에서는 `extern`키워드로 `g_data`전역 변수를 사용할 수 있다.

### 특정 함수에서만 전역 변수 사용하기

- 전역 변수를 특정 함수 안에서만 사용하고 싶다면 해당 전역 변수를 사용하고 싶은 함수로 옮기고 그 앞에 `static`키워드를 적어주면 된다.
- 함수 안에 선언한 변수들은 지역 변수로 처리되어 함수가 호출될 때 만들어지고 호출이 끝나면 사라지지만, `static`키워드를 사용한 지역 변수는 전역 변수로 처리되어 호출 여부에 상관없이 자신이 가지고 있는 값을 유지한다.

> #### 1. 지역 변수를 사용한 경우
> 
> ```c
> #include <stdio.h>
> 
> void Test() {
>     int data = 0;
>     printf("%d, ", data++);
> }
> 
> void main() {
>     int i;
>     for(i = 0; i < 5; i++) Test();
> }
> ```
> ```text
> 0, 0, 0, 0, 0,
> ```
> - `Test`함수에 사용한 `data`변수는 지역 변수라서 함수가 호출될 때마다 만들어지고 0으로 초기화된다.
> - 따라서 그 값을 출력하면 0이 나온다.
> - `data++`를 사용하는 코드가 있지만 함수 호출이 끝나면 `data`변수도 사라지기 때문에 이 값은 유지되지 않는다.
> - 그래서 출력 결과가 0만 나오게 된다.
> 
> #### 2. static + 지역 변수를 사용한 경우
> 
> ```c
> #include <stdio.h>
> 
> void Test() {
>     static int data = 0;
>     printf("%d, ", data++);
> }
> 
> void main() {
>     int i;
>     for(i = 0; i < 5; i++) Test();
> }
> ```
> ```text
> 0, 1, 2, 3, 4,
> ```
> - `Test`함수에 사용한 `data`변수는 앞에 `static`키워드를 사용해 이 함수에서만 사용할 수 있는 전역 변수이다.
> - 따라서 `Test`함수의 호출 여부와 상관없이 `data`변수는 자신의 값을 유지하기 때문에 처음 호출되었을때는 0이 출력되지만, `data++`코드가 적용되어 다음 호출할 때에는 1씩 증가한 값이 출력된다.

#### const 키워드도 알아 두자!

- 프로그래밍을 하다 보면 자신이 만든 함수를 다른 사람에게 제공하는 경우가 있다.
- 이런 경우 함수를 사용할 때 주의 사항을 매뉴얼로 만들어서 제공하거나 소스 코드에 주석을 달아서 알려 준다.
- 예를 들어 다음과 같이 `GetArea`함수를 제공할 때, 이 함수의 첫 번째 인자 값은 변경하지 말라고 주석으로 강조해 두었다.
- 그런데 사용자가 그 뜻을 잘못 파악했거나 실수로 첫 번째 인자의 값을 바꾸게 되면 이것에 대해서 오류가 나지 않기 때문에 버그가 생기더라도 찾기가 쉽지 않다.
```c
// GetArea 함수의 첫 번째 인자 pi값은 절대 변경하지 말 것
double GetArea(double pi, double radius, int limit) {
    double result;
    pi = 3.14;  // 사용자가 임의로 바꾸면 안 될 부분
    result = pi * radius * radius;
    return result;
}
```
- 그래서 주의사항을 좀 더 강력하게 알려주기 위해 변경하지 말아야 할 변수를 변경하는 경우에 문법적으로 오류가 발생하도록 `const`키워드를 사용한다.

#### const 키워드를 사용하는 방법

- `const`키워드는 constant의 약자로, 변수를 상수처럼 쓰고 싶을 때 사용한다.
- 변수를 상수처럼 사용한다는 뜻은 변수의 값을 변경하지 않겠다는 의미이다.
- 만약 프로그래머가 실수로 `const`가 명시된 변수 값을 변경하면 번역할 때 오류가 발생한다.
```c
// GetArea 함수의 첫 번째 인자 pi값은 절대 변경하지 말 것
double GetArea(const double pi, double radius, int limit) {
    double result;
    pi = 3.14;  // const 변수를 사용자가 임의로 변경하면 번역할 때 오류 불생
    result = pi * radius * radius;
    return result;
}
```
- 결국 `const`키워드는 변수의 속성이나 기능 자체를 변경하는 것이 아니다.
- 컴파일할 때 `const`키워드를 사용한 변수의 값이 변경되면 프로그래머에게 문법 오류로 알려 주는 역할을 한다.
- 즉 소스 코드를 작성한 사람의 의도를 분명하게 표현하는 문법이며 실수 방지를 위해 사용한다.
