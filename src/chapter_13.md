# 13. 포인터

## 13-1. 운영체제의 메모리 관리 방식

### 운영체제와 프로그래밍

- 지금까지는 변수를 사용하여 메모리에 데이터를 저장하거나 읽었다.
- 이렇게 C 언어 소스 코드에서 사용한 변수들은 컴파일 작업 후 기계어로 변경되면 모두 메모리 주소로 바뀌어서 적용된다.

![변수 컴파일 작업 후](./images/variable_concept.png)

- 결국 기계어에서는 변수 이름보다 변수가 위치한 메모리의 주소가 훨씬 중요하다.
- 즉 변수 이름을 사용하지 않더라도 변수의 주소만 알고 있다면 변수 값을 읽거나 바꿀 수 있다는 뜻이다.
- 그런데 컴퓨터 시스템의 메모리는 운영체제가 관리하고 있다.
- 따라서 메모리 주소의 사용법을 배우기 전에 운영체제가 메모리를 어떻게 관리하는지를 먼저 알아야 한다.
- 운영체제(Operating System)는 컴퓨터 시스템을 효과적으로 관리해 주고 시스템이 가지고 있는 자원을 사용자 또는 프로그램이 잘 이용할 수 있도록 서비스해 주는 소프트웨어이다.
- 예를 들어 윈도우, 리눅스, 유닉스와 같은 소프트웨어가 운영체제이다.

#### 32비트 운영체제와 64비트 운영체제

- 64비트 운영체제가 보급됨에 따라 운영체제에서 실행되는 프로그램도 32비트 프로그램과 64비트 프로그램으로 나누어서 개발할 수 있다.
- 실제로 개발 현장에서는 특별한 경우가 아니라면 32비트 방식으로 개발하는 경우가 많다.
- 32비트 방식으로 개발해도 32비트 운영체제 또는 64비트 운영체제에서 모두 동작하기 때문이다.

#### 64비트 운영체제의 장단점

- 운영체제가 64비트를 지원하는 건 많은 이점이 있다.
- 동시 처리 능력이나 메모리의 확장성 같은 부분에서는 선택의 문제가 아니라 반드시 64비트로 사용해야 하는 경우도 있다.
- 예를 들어 32비트 운영체제는 우리가 메모리라고 부르는 RAM을 4GB(기가바이트, 2<sup>30</sup>)밖에 사용하지 못하지만 64비트 운영체제에서는 16EB(엑사바이트, 2<sup>60</sup>)까지
  사용할 수 있다.
- 따라서 자신의 시스템이 RAM을 4GB이상 사용한다면 64비트 운영체제를 설치해야 메모리를 100% 다 사용할 수 있는 것이다.
- 하지만 64비트 운영체제가 장점만 있는 것은 아니다.
- 64비트 운영체제는 데이터의 기본 처리 단위가 64비트라는 뜻이기 때문에 기본적으로 메모리 사용량이 많다.
- '운영체제나 프로그램이 몇 비트인가?'에 대해 이야기한 이유는 이 방식에 따라서 데이터를 처리하는 기본 단위가 달라지기 때문이다.
- 4장에서 자료형을 설명할 때 `int`형을 4바이트라고 한 이유는 32비트 운영체제를 기준으로 설명했기 때문이다.
- 예를 들어 C 언어의 `int`형 개념은 운영체제의 비트 수와 일치하기 때문에 32비트 운영체제에서는 `int`형이 32비트이다.

### 메모리 주소 지정 방식

- 운영체제는 메모리 주소를 1바이트 단위로 관리한다.
- 운영체제마다 관리하는 방식에 차이가 있지만 32비트 윈도우 운영체제의 경우에 0~4,294,967,295번지까지 1바이트 단위로 주소가 매겨져 있다.
- 번지수 4,294,967,295는 2<sup>32</sup>-1을 계산한 결과이다.
- 운영체제가 32비트이고 시작 주소가 1이 아니고 0이기 때문이다.
- 메모리를 사용하려면 반드시 사용할 주소를 지정해야 하고 메모리가 1바이트 단위로만 사용되는 것은 아니기 때문에 프로그래머가 메모리를 사용할 때 한 번에 읽거나 저장할 크기를 명시해야 한다.
- 예를 들어 100번지, 101번지 이렇게 두 개 바이트를 사용하고 싶다면 '100번지부터 2바이트 크기만큼 메모리를 사용하겠다'라는 형식으로 표기해 주어야 한다.

### 직접 주소 지정 방식

- 직접 주소 지정 방식은 메모리를 사용할 때 프로그래머가 사용할 메모리 주소를 직접 적는 방식이다.
- 예를 들어 '102번지에 1042라는 값을 2바이트 크기로 저장하겠다'라고 이야기하는 것이 직접 주소 지정 방식이다.
- 102번지라는 주소를 직접적으로 표기했기 때문이다.

![직접 주소 지정 방식](./images/memory_diagram_1.png)

- 메모리를 사다리 모양으로 그려서 하나씩 검증해 보는 것이 개념을 이해하는 데 도움이 된다.
- 102번지에 1042 값이 대입되었는데 이 값이 2바이트에 걸쳐서 표현되어 있다.
- 그런데 위 그림은 단순화하여 그린 것이라 실제 메모리의 형태는 아니다.
- 실제 메모리에서 10진수 1042는 두 개의 바이트에 각각 4와 18로 나뉘어 저장되기 때문에 다음과 같이 그림을 그려야 한다.

![직접 주소 지정 방식](./images/memory_diagram_2.png)

> #### 1042가 왜 4와 18로 나누어질까?
>
> - 1042값이 왜 4와 18로 나뉘어서 저장되는지 이해하려면 1042값을 2진수 값으로 바꿔 보면 된다.
> - 2진수 한 자리를 저장하기 위해서는 1비트가 필요하기 때문에 2바이트(16비트)에 맞도록 총 16자리의 2진수로 표시하면 다음과 같다.
> ```text
> 0000 0100   0001 0010  // 1024
>    (4)        (18)
> ```
> - 결국 1042 값은 8비트에 저장할 수 없기 때문에 두 개의 8비트에 4와 18로 나뉘어 저장되는 것이다.
> - 그런데 위의 그림에서 8비트씩 메모리에 옮길 때 102번지에 18, 103번지에 4가 대입되어 있다.
> - 숫자를 적을 때 큰 숫자부터 적는 게 일반적이라서 102번지에 4가 저장되는 게 맞다고 생각할 수도 있지만, 이 그림은 윈도우 운영체제를 기준으로 그린 것이다.
> - 윈도우 운영체제는 리틀 엔디언이라는 바이트 정렬을 사용하여 숫자를 표현하기 때문에 우리가 생각하는 것과 반대 방향으로 숫자가 배열된다.

#### 16진법으로 메모리 형태 표시하기

- 우리가 자주 쓰는 숫자는 대부분 10진수이다.
- 컴퓨터 내부에서는 0과 1, 즉 2진수로 정보를 처리한다.
- 파일을 압축하는 연산이나 동영상 처리, 심지어 전화 통화까지도 모두 비트 단위인 2진수 패턴으로 작업할 수 있다.
- 그런데 C 언어에서는 2진수를 직접 사용하는 방법을 제공하지 않는다.
- 따라서 C 언어로 프로그래밍할 때는 2진수에 가장 가까운 표현법인 16진수를 자주 사용한다.
- 16진법은 한 자릿수를 표현하는 데 16개의 문자를 사용하기 때문에 16진수의 한 자릿수는 4비트(2<sup>4</sup>=16)로 표시할 수 있다.
- 결국 16진수로 표현된 숫자는 두 자리씩 자르면 1바이트를 의미하므로 숫자를 바이트 단위로 나누기가 편리하다.
- 예를 들어 10진법으로 쓰인 숫자 1042를 바이트 단위로 나누려면 2진법으로 먼저 변환하고, 또 다시 바이트 단위로 나누어야 한다.
- 10진수 1042를 처음부터 16진수로 저장했다면 어떨까?
- 1042값은 16진수 표기법으로 `0x0412`이므로 한 바이트에 `0x04`가 저장되고 나머지 바이트에 `0x12`가 저장된다.
- 이렇게 C 언어로 프로그래밍할 때 바이트 단위로 작업을 하면, 데이터를 저장할 때 메모리 공간을 훨씬 효율적으로 사용할 수 있다.
- 메모리에 저장하는 값들과, 주소도 16진수로 표기해보자.

```text
0x0412 값을 0x00000066 번지에 2바이트 크기로 대입하라.
```

![16진법으로 메모리 형태 표시하기](./images/memory_diagram_3.png)

### 직접 주소 방식은 C 언어의 '변수' 문법과 같다

- 지금까지 메모리에서 '직접 주소 지정 방식'을 살펴보았다.
- '0x00000066 번지에 0x0412 값을 2바이트 크기로 대입하라.'는 명령을 좀 더 정확하게 이해하기 위해 컴퓨터가 사용하는 기계어와 가장 가까운 어셈블리 언어로 표현해 보면 다음과 같다.

![어셈블리 언어로 표현해 보기](./images/memory_diagram_4.png)

- 어셈블리어에서 `mov`명령은 move의 줄임 표현이고 `mov A, B`명령은 A에 B값을 대입하라는 뜻이다.
- `word ptr[]`명령은 `[]`에 명시된 주소에 가서 word(2바이트) 단위로 값을 읽거나 쓰겠다는 의미이다.
- C 언어와 달리 어셈블리어에서는 16진수를 표시할 때 숫자 끝에 `h`를 붙인다.
- C 언어는 '변수'라는 개념으로 직접 주소 지정 방식을 사용한다.
- C 언어에서 변수를 사용하면 변수에 값을 대입하는 소스 코드가 위와 같은 어셈블리어 형태의 기계어로 번역된다.

> #### 기계어와 어셈블리어가 무엇인지 좀 더 알아보자
> 
> - 컴퓨터가 사용하는 2진 숫자로 나열된 언어를 기계어(Machine Language)라고 한다.
> - 실행 파일(Executable File, *.exe)이라고 부르는 것이 기계어로 구성된 파일이다.
> - 하지만 이 파일은 숫자로 이루어져 있어서 이해하기 어렵기 때문에, 형식은 비슷하면서 숫자로 배열된 명령을 영단어로 변경해서 보여주는 언어가 어셈블리(Assembly) 언어이다.
> - 어셈블리 언어는 기계어에 가장 가까운 저급 언어(Low-level language)이므로 성능 평가나 시스템 원리를 설명할 때 많이 사용한다.
> - `mov`, `word`처럼 자주 사용하는 몇 가지 명령과 레지스터(Register, CPU 내부에 있는 연산 가능한 메모리)를 공부해서 어셈블리 언어로 작성된 소스 코드를 보고 이해할 정도까지만 알아두자.

- C 언어는 변수라는 개념으로 메모리 주소를 직접 적지 않으면서도 직접 주소 지정 방식을 사용한다.
- 번역기의 도움을 받아서 내부적으로 변수가 주소로 변환되어 결과적으로는 직접 주소 지정 방식을 사용하게 되는 것이다.
- 앞에서 어셈블리어로 작성한 명령을 C 언어의 변수 문법으로 재구성해 보면 다음과 같다.
```c
short birthday;     // birthday가 메모리 주소 0x00000066에 위치한다고 가정함
birthday = 0x0412;  // mov word ptr[00000066h], 0412h 로 번역함
```

- C 언어는 왜 어셈블리어나 기계어처럼 주소를 직접 사용하지 않고 변수라는 개념을 사용할까?