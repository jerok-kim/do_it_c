# 7. 연산자

## 7-1. 기본 연산자

### 대입 연산자

- C 언어에서 대입 연산자는 `=` 기호로 나타내며 변수에 상수 값 또는 다른 변수 값을 대입할 떄 사용한다.

```c
#include <stdio.h>

void main() {
    int data1, data2;
    data1 = 5;      // data1 변수에 상수 5를 대입함
    data2 = data1;  // data2 변수에 data1 변수 값 5를 대입함
    printf("data1 = %d, data2 = %d\n", data1, data2);
}
```

```text
data1 = 5, data2 = 5
```

### 산술 연산자

- +, -, *, /, %는 산술 연산자로 각각 더하기, 빼기, 곱하기, 나누기, 나머지 연산을 뜻한다.
- 나눗셈의 경우에는 결과 값이 몫과 나머지로 나오기 때문에 몫은 `/`연산자를 이용하여 구하고 나머지는 `%`연산자를 사용하여 구한다.

```c
#include <stdio.h>

void main() {
    int data1 = 5, data2 = 3;     // 두 변수의 초기값을 5와 3으로 설정함

    int result1 = data1 + data2;  // 덧셈
    int result2 = data1 * data2;  // 곱셈
    int result3 = data1 / data2;  // 나눗셈(몫)
    int result4 = data1 % data2;  // 나눗셈(나머지)

    printf("result : %d, %d, %d, %d\n", result1, result2, result3, result4);
}
```

```text
result : 8, 15, 1, 2
```

### 증감 연산자

- 컴퓨터에서는 값이 순차적으로 증가하거나 감소하는 경우가 많다.
- C 언어에서는 변수가 가지고 있는 값을 1 증가시키는 `++`증가 연산자와 1 감소시킬 수 있는 `--`감소 연산자를 제공한다.
- 덧셈 연산자(이항 연산자)

```c
int i = 5;
i = i + 1;  // i값에 1을 더하고 다시 i에 대입됨
```

- 증가 연산자(단항 연산자)

```c
int i = 5;
i++;  // i값을 1 증가시킴. i에 6이 대입됨
```

- 결과적으로 두 방법 모두 i 값이 6이 되는 것은 같다.
- 하지만 덧셈 연산자는 2개의 항을 갖는 이항 연산자이므로 두 개의 메모리가 연산에 사용되고, 증가 연산자는 단항 연산자이기 때문에 한 개의 메모리만 연산에 사용된다.
- 결과적으로 한 개의 메모리만 사용하는 단항 연산자의 연산 속도가 더 빠르다.
- 그리고 코드 구성도 간단해지기 때문에 단순히 1을 증가시키거나 1을 감소시킬 목적이라면 증감 연산자를 사용하는 것이 더 좋다.

#### 증감 연산자의 전위형과 후위형

- 증감 연산자는 다른 연산자들과 달리 변수 앞뒤에 사용할 수도 있다.
- 예를 들어 `i++`(후위형, Postfix)도 가능하지만 `++i`(전위형, Prefix)도 가능하다는 뜻이다.
- 이는 `--`도 마찬가지이다.
- 전위형과 후위형 모두 자기 자신이 1 증가 또는 1 감소하는 것은 같지만, 추가로 함께 연산을 하는 다른 연산자가 있는 경우에는 결과 값이 달라질 수도 있다.
- 전위형

```c
int i = 5, sum;
sum = ++i;
// 자신의 값을 먼저 증가시켜 6을 만든 뒤 sum에 6을 대입함. i와 sum 모두 6이 됨
```

- 후위형

```c
int i = 5, sum;
sum = i++;
// i의 값 5를 sum에 먼저 대입하고 i를 증가시킴. i는 6이고 sum은 5가 됨
```

- 즉 전위형의 경우 값을 먼저 증감한 후에 연산을 하고 후위형은 연산을 하고 난 후에 값을 증감하는 것을 알 수 있다.

### 관계 연산자

- 산술 연산(Arithmetic Operation)이 결과 값은 숫자로 나오지만, 관계 연산(Relational Operation)이나 논리 연산(Logical Operation)이 결과 값은 진리값(참, 거짓)
  으로 나온다.
- 예를 들어 '1과 2는 같다'라는 문장은 관계 연산이 사용된 것이고 실제로 1과 2는 같지 않기 때문에 이 문장에 대한 결과 값은 거짓이 된다.
- 그런데 컴퓨터가 연산의 결과 값을 '참', '거짓'과 같은 문자열로 저장한다면 연산 속도가 떨어질 것이다.
- 따라서 관계 연산의 결과 값은 참이면 1, 거짓이면 0으로 처리된다.
- 관계 연산자를 사용하면 두 수치 값을 비교하여 그 결과 값을 참(1) 또는 거짓(0)으로 얻을 수 있으며 종류는 다음과 같다.

| 관계 연산자 | 연산 특성            |
|--------|------------------|
| A < B  | A가 B보다 작으면 참     |
| A > B  | A가 B보다 크면 참      |
| A <= B | A가 B보다 작거나 같으면 참 |
| A >= B | A가 B보다 크거나 같으면 참 |
| A == B | A와 B가 같으면 참      |
| A != B | A와 B가 같지 않으면 참   |

- C 문버에서 '같다'라는 관계 연산자는 =를 두 개 사용하여 `==`라고 적는다.
- 또한 '같지 않다'는 관계를 나타내는 연산자는 `!=`이다.
- `!`(논리 연산자)는 부정(Not)을 의미하기 때문에 =앞에 적어 '같지 않다'라는 관계 연산자를 만든다.

```c
#include <stdio.h>

void main() {
    int data1 = 5, data2 = 3;      // 두 변수에 초기값을 5와 3으로 설정함

    // 관계 연산 테스트
    int result1 = data1 > 7;       // 5는 7보다 작으므로 거짓
    int result2 = data2 <= data1;  // 3은 5보다 작으므로 참
    int result3 = data2 == 7;      // 3은 7과 같지 않으므로 거짓
    int result4 = data2 != data1;  // 3은 5와 다르므로 참

    // 관계 연산의 결과 값은 0 또는 1임
    printf("result : %d, %d, %d, %d\n", result1, result2, result3, result4);
}
```

```text
result : 0, 1, 0, 1
```

### 논리 연산자

- A와 B의 상황을 일정한 규칙(AND, OR, NOT)으로 연결해주는 연산자가 '논리 연산자'이고 A와 B는 진리값(참, 거짓)을 사용한다.
- 논리 연산자도 관계 연산자처럼 연산의 결과 값은 참(1) 또는 거짓(0)으로 나온다.
- 하지만 연산할 때 사용하는 숫자가 0, 1만 존재하는 것은 아니기 때문에, 0만 거짓으로 간주하고 0이 아닌 모든 값을 '참'으로 판단한다.
- C 언어에서 논리 연산자 AND는 `&&`키워드를, OR는 `||`키워드를, NOT은 `!`키워드를 사용한다.
- AND 연산자와 OR 연산자는 이항 연산자이고 NOT 연산자는 단항 연산자이다.

| A     | B     | A AND B 연산 | A OR B 연산 | NOT A 연산 |
|-------|-------|------------|-----------|----------|
| 거짓(0) | 거짓(0) | 거짓(0)      | 거짓(0)     | 참(1)     |
| 거짓(0) | 참(1)  | 거짓(0)      | 참(1)      | 참(1)     |
| 참(1)  | 거짓(0) | 거짓(0)      | 참(1)      | 거짓(1)    |
| 참(1)  | 참(1)  | 참(1)       | 참(1)      | 거짓(1)    |

- 연산 규칙을 정리해 보면 다음과 같다.

| 논리 연산자 | 연산 특정                                           |
|--------|-------------------------------------------------|
| AND    | A와 B가 모두 참이어야 결과 값이 참(1), 하나라도 거짓이면 결과 값은 거짓(0) |
| OR     | A 또는 B가 참이면 결과 값이 참(1), 둘 다 거짓일 때만 결과 값이 거짓(0)  |
| NOT    | A가 거짓이면 결과 값이 참(1), A가 참이면 결과 값이 거짓(0)          |

- AND 연산의 특징은 연산에 참여하는 A, B 진리값이 둘 다 참(1)이어야 결과 값이 참(1)이 나오고,
- OR 연산의 특징은 A, B 진리값이 둘 다 거짓(0)인 경우에만 결과 값이 거짓(0)이 나온다.
- NOT 연산은 현재 가지고 있는 진리값이 반전(거짓(0)이면 참(1), 참(1)이면 거짓(0))된다.

```c
#include <stdio.h>

void main() {
    int data1 = 5, data2 = 3;  // 두 변수에 초기값을 5와 3으로 설정

    // OR 연산자
    int result1 = 0 || 1;

    // AND 연산자. 3 && -1 은 1 && 1과 같기 때문에 결과 값은 참
    int result2 = 3 && -1;

    // OR 연산자. data1 == 3은 거짓, data2 == 3은 참
    int result3 = data1 == 3 || data2 == 3;

    // AND 연산자. data1 == 3은 거짓, data2 == 3은 참
    int result4 = data1 == 3 && data2 == 3;

    // data1은 0이 아니라서 참. 참에 NOT 연산을 하면 거짓
    int result5 = !data1;

    // 관계 연산의 결과 값은 0 또는 1
    printf("result : %d, %d, %d, %d, %d\n", result1, result2, result3, result4, result5);
}
```

```text
result : 1, 1, 1, 0, 0
```

> #### 논리 연산자의 특성을 이용해 조건 수식 구성하기
> 
> - 논리 연산자는 A, B 진리값을 사용하여 AND 와 OR 연산을 수행할 때 A만으로도 연산 결과를 판단할 수 있는 경우에는 B를 수행하지 않는다.
> - 예를 들어 `A && B`연산에서 A가 거짓(0)이면 B의 진리값을 보지 않고도 결과 값이 거짓임을 알 수 있고, `A || B`연산에서 A가 참(1)이면 B의 진리값을 몰라도 결과 값이 참 임을 알 수
>   있다.
> 
> ```c
> data > 3 && data++;
> ```
> 
> - `data`값이 3보다 큰 경우:
>     - 이 수식은 `data`가 3보다 큰 값을 가지면 A 연산(`data > 3`)이 참이 된다.
>     - 따라서 B 연산(`data++`)이 참인지 거짓인지에 따라 논리 연산자의 결과 값이 달라지기 때문에 `data++`연산이 무조건 수행된다.
>     - 즉 `data`가 5일 때 위 명령문을 수행하고 나면 `data`는 6이 된다.
> - `data`값이 3보다 작거나 같은 경우:
>     - 반대로 `data`가 3보다 작거나 같다면 A 연산이 거짓이 되어 B 연산을 확인해보지 않아도 결과 값은 거짓이 된다.
>     - 따라서 `data++`는 수행되지 않는다.
>     - 즉 `data`가 2일 때 위 명령문을 수행하고 나면 `data`는 여전히 2이다.
> 
> ```c
> data > 3 || data++;
> ```
> 
> - `data`값이 3보다 큰 경우:
>     - 이 수식은 `data`가 3보다 큰 값을 가지면 A 연산(`data > 3`)이 참이 되어 B 연산(`data++`)을 확인해보지 않아도 결과 값이 참이 된다.
>     - 따라서 `data++`는 수행되지 않는다.
>     - 즉 `data`가 5일 때 위 명령문을 수행하고 나면 `data`는 여전히 5이다.
> - `data`값이 3보다 작거나 같은 경우:
>     - 반대로 `data`가 3보다 작거나 같다면 A 연산이 거짓이 되어 B 연산이 참인지 거짓인지에 따라 논리 연산자의 결과 값이 달라지기 때문에 `data++`연산이 수행된다.
>     - 즉 `data`가 2일 때 위 명령문을 수행하고 나면 `data`는 3이 된다.

## 7-2. 연산자 우선순위와 연산 방향

### 연산자 우선순위란?

- 연산자 우선순위는 하나의 수식에서 연산자를 여러 개 사용했을 때, 어떤 연산자를 먼저 연산할 것인지 정해 놓은 것이다.
- 다음은 C 언어 연산자들의 우선순위를 정리한 표이다.

| 순위  | 종류             | 연산자                                                    | 연산방향 |
|-----|----------------|--------------------------------------------------------|------|
| 1   | 괄호, 배열, 구조체    | ()(후위 증가) . [](후위 감소) ->                               | →    |
| 2   | 단항 연산자         | (자료형) *(간접) &(주소) ! ~(비트 NOT) ++ -- +(부호) -(부호) sizeof | ←    |
| 3   | 승제 연산자         | * / %                                                  | →    |
| 4   | 가감 연산자         | + -                                                    | →    |
| 5   | 시프트(Shift) 연산자 | << >>                                                  | →    |
| 6   | 비교 연산자         | < <= > >=                                              | →    |
| 7   | 등가 연산자         | == !=                                                  | →    |
| 8   | 비트 연산자 AND     | &                                                      | →    |
| 9   | 비트 연산자 XOR     | ^                                                      | →    |
| 10  | 비트 연산자 OR      | ¦                                                      | →    |
| 11  | 논리 연산자 AND     | &&                                                     | →    |
| 12  | 논리 연산자 OR      | ¦¦                                                     | →    |
| 13  | 조건 연산자         | ? :                                                    | ←    |
| 14  | 대입 연산자         | = *= /= += -= %= <<= >>= &= ^= ¦=                      | ←    |
| 15  | 나열 연산자         | ,                                                      | →    |

### 우선순위가 같은 연산자라면? 연산 방향을 확인하자!

- 연산자 우선순위가 같은 연산자들에 대해서도 어떤 연산자를 먼저 연산할 것인지를 정해 놓았는데, 이것이 '연산 방향'이다.
- 연산 수식을 구성할 때 연산자의 개별적인 우선순위 외에 연산 방향도 잘 고려해야 한다.
